--[[
what to track ...
- over a time range, sequentially go through all earthquakes
- as you add them, look through all previous points and consider the great-arc with this point (subject to angle constraints)
- report how well this new great-arc compares to older ones (i.e. is this new earthquake on a great-arc that already exists?)
	- by comparing dot of its axis with previous circles' axis
- as we get too old, throw out old points and their respective great-arcs 
--]]

local vec3d = require 'vec-ffi.vec3d'

local dayInSec = 60 * 60 * 24
-- [=======[ download data
local fromdatestr = os.date('%Y-%m-%d', os.time() - dayInSec * 31)
local todatestr = os.date('%Y-%m-%d', os.time() - dayInSec)
local basefn = fromdatestr..' to '..todatestr
local csvpath = path(basefn..'.csv')
local csvstr
if not csvpath:exists() then
	print'downloading...'
	local https = require 'ssl.https'

	csvstr = assert(https.request('https://earthquake.usgs.gov/fdsnws/event/1/query.csv?starttime='..fromdatestr..'%2000:00:00&endtime='..todatestr..'%2023:59:59&minmagnitude=2.5&orderby=time'))
	assert(csvpath:write(csvstr))
else
	csvstr = assert(csvpath:read())
end
local csvdata = assert(require 'csv'.string(csvstr))
local earthquakes = csvdata.rows
csvdata:setColumnNames(earthquakes:remove(1))
--]=======]

-- [===[ BEGIN COPY FROM run.rua
local rotateX = |v, theta| do
	local c, s = math.cos(theta), math.sin(theta)
	return vec3d(
		v.x,
		v.y * c - v.z * s,
		v.y * s + v.z * c)
end
local rotateY = |v, theta| do
	local c, s = math.cos(theta), math.sin(theta)
	return vec3d(
		v.x * c + v.z * s,
		v.y,
		v.x * s - v.z * c)
end
local latLonToXYZ = |eq| do
	local v = vec3d(0, 0, 1)   -- z+ is default
	v = rotateX(v, -math.rad(eq.latitude))
	v = rotateY(v, math.pi - math.rad(eq.longitude))
	return v
end
--]===] -- END COPY FROM run.rua

earthquakes = earthquakes:mapi(|eq| do
	-- map from csv index to k/v object
	local neq = {}
	for _,k in ipairs(csvdata.columns) do
		neq[k] = eq[k]
	end
	-- add preprocessed fields	
	local Y,m,d,H,M,S = neq.time:match'^(%d%d%d%d)%-(%d%d)%-(%d%d)T(%d%d):(%d%d):(%d%d%.%d%d%dZ)$'
	assert(Y)	-- ... and the others should be there too
	neq.ostime = os.time{year=Y, month=m, day=d, hour=H, min=M, sec=S}
	neq.xyz = latLonToXYZ(neq)
	return neq
end):sort(|a,b| a.ostime < b.ostime)	-- oldest first


-- tolerance of how close a quake must be to a previous circle to consider along the geodesic
local quakeAlignWithPreviousGeodesicAngleThreshold = math.rad(1)	-- in radians
--local quakeAlignWithPreviousGeodesicAngleThreshold = math.rad(5)	-- in radians
--local quakeAlignWithPreviousGeodesicAngleThreshold = math.rad(15)	-- in radians

-- how far back we want to look when comparing great-arcs 
local considerationTimeWindowSize = dayInSec	-- in seconds
--local considerationTimeWindowSize = 3 * dayInSec	-- in seconds

local activeCircles = table()	-- holds indexes into 'allCircles'
local allCircles = table()
local oldestEarthquakeIndex = 1
for i,eq in ipairs(earthquakes) do
	local v = eq.xyz
	
	-- see how close it is to all other circles on file
	local touchingCircles = table()
	for _,ci in ipairs(activeCircles) do
		local c = allCircles[ci]
		local angle = math.acos(c.axis:dot(v))
		-- if we were right on the plane then we would be right at 90' with the axis.
		-- see how far the angle we make with the axis is from 90'
		if math.abs(angle - .5 * math.pi) < quakeAlignWithPreviousGeodesicAngleThreshold then
			-- TODO take note (or even filter?) based on the angle distance between us and the prevoius points that it took to form this geodesic?
			-- what if all new quakes happen to be along geodesics but >90' of old geodesic points? (or whatever our geodesic creation angle criteria is)
			touchingCircles:insert{circle=ci, angle=angle}
		end
	end
	local numCirclesChecked = #activeCircles

	-- now do our typical building of great-arcs based on our other angle criteria
	local oldCircleCount = #activeCircles
	for j=oldestEarthquakeIndex,i do
		local eq2 = earthquakes[j]
		local v2 = eq2.xyz
		local torque = v:cross(v2)	-- TODO times pair of earthquake magnitudes or something?
		local axisLen = torque:length()
		local axis = torque * (1 / (math.max(axisLen, 1e-15)))	
		local influence = axisLen * 10^eq.mag * 10^eq2.mag
		local angle = math.acos(v:dot(v2))
		if math.rad(10) < angle and angle < math.rad(90) then	-- if I weight by cross then that'll make the 0' and 180' angles diminish ... nah, there's still a lot of noise unless I turn down the alpha ... then it's hard to highlight any geodesics ...
			local circle = {
				axis = axis,
				angle = math.pi * .5,
				indexes = {i, j},
				-- [[ used for rendering
				color = vec3d(1, .3, .07) * influence,
				centerPos = (v + v2):normalize(),	-- midpoint between two earthquake lines
				centerAngle = .5 * angle,			-- half the angle between them
				--]]
			}
			allCircles:insert(circle)
			activeCircles:insert(#allCircles)
		end
	end
	-- now recalculate the oldest point index t consider (basd on our time window)
	while oldestEarthquakeIndex < i
	and eq.ostime - earthquakes[oldestEarthquakeIndex].ostime > considerationTimeWindowSize 
	do
		oldestEarthquakeIndex+=1 
	end
	-- and throw out old circles
	for j=oldCircleCount,1,-1 do
		local ci = activeCircles[j]
		local c = allCircles[ci]
		if c.indexes[1] < oldestEarthquakeIndex
		or c.indexes[2] < oldestEarthquakeIndex
		then
			activeCircles:remove(j)
		end
	end

	-- collect unique points to all circles of this point
	local uniquePointIndexes = {}
	uniquePointIndexes[i] = true
	for _,t in ipairs(touchingCircles) do
		local ci = t.circle
		local c = allCircles[ci]
		uniquePointIndexes[c.indexes[1]] = true
		uniquePointIndexes[c.indexes[2]] = true
	end
	eq.touchingCircles = touchingCircles
	eq.uniquePoints = uniquePoints	-- do I need a list of all points that are on all circles that are touching this point? or nah?

	--[[
	print('i='..i
		..' t='..eq.time
		..' touch='..#touchingCircles
		..' lat='..eq.latitude
		..' lon='..eq.longitude
		..' xyz='..eq.xyz
		..' mag='..eq.mag
		..' place='..eq.place
		..' check='..numCirclesChecked
		..' numPtsNow='..(i-oldestEarthquakeIndex+1)
		..' numArcsNow='..#activeCircles
	)
	--]]
	--[[ show what it's touching?
	print'\tcircles:'
	for _,t in ipairs(touchingCircles) do
		local ci = t.circle
		local c = allCircles[ci]
		print('\t\t'
			..' index='..c.indexes[1]..','..c.indexes[2]
			--..' index='..table.concat(c.indexes,',')	-- why would this segfault?
			..' angle='..t.angle
			..' axis='..c.axis
		)
	end
	print'\tpoints:'
	for _,j in ipairs(table.keys(uniquePointIndexes):sort()) do
		print('\t\t'..j..' '..earthquakes[j].xyz)
	end
	--]]
end

--[[ big and slow
-- map out the vec3d's
for _,eq in ipairs(earthquakes) do
	eq.xyz = {eq.xyz:unpack()}
end
for _,c in ipairs(allCircles) do
	c.axis = {c.axis:unpack()}
end
local luapath = path(basefn..'.lua')
luapath:write(tolua{
	earthquakes = earthquakes,
	circles = allCircles,
})
--]]

return {
	earthquakes = earthquakes,
	circles = allCircles,
	considerationTimeWindowSize = considerationTimeWindowSize, 
}
