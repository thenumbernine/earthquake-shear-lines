-- Lua os.time calls mktime, which converts Y m d H M S to timestamp... with your timezone baked in.
-- 	timegm
require 'ffi.req' 'c.time'

local dayInSec = 60 * 60 * 24

-- takes in a timestamp (your timezone? do timestamps consider timezone, or are they all UTC?)
-- spits out UTC date info
-- TODO add a first 'format' option that formats this... ?
local timegm = |t|do
	local ts = ffi.new'struct tm[1]'
	ts[0].tm_year = (t.year or 1900) - 1900
	ts[0].tm_mon = (t.month or 1) - 1
	ts[0].tm_mday = t.day or 0
	ts[0].tm_hour = t.hour or 12
	ts[0].tm_min = t.min or 0
	ts[0].tm_sec = t.sec or 0
	ts[0].tm_isdst = t.isdst or false
	return ffi.C.timegm(ts)
end

local time = ||ffi.C.time(nil)

-- takes in UTC date info, spits out a timestamp
-- pass it unix timestamp, or nil for the current time
-- returns a date stucture with .year .month .day .hour .min .sec .isdst hopeully with the same range as Lua's os.date
local gmtime
do
	local tp = ffi.new'time_t[1]'
	gmtime = |t|do
		tp[0] = t or time()
		local ts = ffi.C.gmtime(tp)
		return {
			year = ts[0].tm_year + 1900,
			month = ts[0].tm_mon + 1,
			day = ts[0].tm_mday,
			hour = ts[0].tm_hour,
			min = ts[0].tm_min,
			sec = ts[0].tm_sec,
			isdst = ts[0].tm_isdst ~= 0,
		}
	end
end

return {
	time = time,
	timegm = timegm,
	gmtime = gmtime,
	dayInSec = dayInSec,
}
