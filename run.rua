#!/usr/bin/env rua
local template = require 'template'
local sdl = require 'sdl'
local gl = require 'gl'
local GLSceneObject = require 'gl.sceneobject'
local GLArrayBuffer = require 'gl.arraybuffer'
local GLProgram = require 'gl.program'
local GLGeometry = require 'gl.geometry'
local GLTex2D = require 'gl.tex2d'
local GLGradientTex2D = require 'gl.gradienttex2d'
local ig = require 'imgui'
local vec2d = require 'vec-ffi.vec2d'
local vec3d = require 'vec-ffi.vec3d'
local vector = require 'ffi.cpp.vector-lua'

local CLEnv = require 'cl.obj.env'
local clnumber = require 'cl.obj.number'

local Planets = require 'solarsystem.planets'
local Julian = require 'solarsystem.julian'

local basisFor = require 'basis'.basisFor
local rotateX = require 'basis'.rotateX
local rotateY = require 'basis'.rotateY
local rotateZ = require 'basis'.rotateZ

local charts = require 'charts'.charts
local chartCode = require 'charts'.chartCode
local chartCNames = require 'charts'.chartCNames

local getDayCache = require 'earthquakes'.getDayCache
local checkTime = require 'earthquakes'.checkTime
local earthquakes = require 'earthquakes'.earthquakes
local checkDuration = 60*5	-- re-check every 5 mins

local flares = require 'flares'

local time = require 'time'.time
local timegm = require 'time'.timegm
local gmtime = require 'time'.gmtime

local calcCircles = require 'circles'


local dayInSec = 60 * 60 * 24

local COMPUTE_TIDES = true

local intptr = ffi.new'int[1]'
local int = |x| do intptr[0] = x return intptr end

local doubleptr = ffi.new'double[1]'
local double = |x| do doubleptr[0] = x return doubleptr end

for _,name in ipairs(chartCNames) do
	chartCode ..= '\nuniform float weight_'..name..';'
end

chartCode ..= [[

//////// BEGIN GLSL THAT'S ALSO IN MY EARTH MAGNETIC FIELD MODEL CODE
// ported from WMM2020 GeomagnetismLibrary.c
// expects xyz in cartesian units earth-semimajor-axis
// output is in (radians, radians, km)
// TODO just use charts.WGS84:chartInv(x,y,z) ?  or use this there?
vec3 cartesianToLatLonWGS84(vec3 pos) {
	// lowercase WGS84_a is in km, uppercase WGS84_a is in m ... i know i need to fix this ...
	pos *= WGS84_a;	// convert from semimajor-axis units to km
	float modified_b = pos.z < 0. ? -WGS84_b : WGS84_b;
	float r = length(pos.xy);

	float e = (modified_b * pos.z - (WGS84_a * WGS84_a - modified_b * modified_b)) / (WGS84_a * r);
	float f = (modified_b * pos.z + (WGS84_a * WGS84_a - modified_b * modified_b)) / (WGS84_a * r);
	float p = (4. / 3.) * (e * f + 1.);
	float q = 2. * (e * e - f * f);
	float d = p * p * p + q * q;

	float v;
	if  (d >= 0.) {
		v = pow(sqrt(d) - q, 1./3.) - pow(sqrt(d) + q, 1./3.);
	} else {
		v = 2. * sqrt(-p) * cos(acos(q / (p * sqrt(-p))) / 3.);
	}

	if (v * v < abs(p)) {
		v = -(v * v * v + 2. * q) / (3. * p);
	}

	float g = (sqrt(e * e + v) + e) / 2.;
	float t = sqrt(g * g + (f - v * g) / (2. * g - e)) - g;

	float phi = atan((WGS84_a * (1. - t * t)) / (2. * modified_b * t));	// latitude

	float height = (r - WGS84_a * t) * cos(phi) + (pos.z - modified_b) * sin(phi);
	float lambda = atan(pos.y, pos.x);	// longitude
	lambda += M_PI;
	lambda = mod(lambda, 2. * M_PI);
	lambda -= M_PI;
	// longitude = lambda = range of [-pi, pi]
	return vec3(phi, lambda, height * 1e+3);		// km back to m
}
//////// END GLSL THAT'S ALSO IN MY EARTH MAGNETIC FIELD MODEL CODE

vec2 vec2exp(float rad) {
	return vec2(cos(rad), sin(rad));
}

vec3 rotateX(vec3 v, float rad) {
	vec2 cs = vec2exp(rad);
	return vec3(
		v.x,
		v.y * cs.x - v.z * cs.y,
		v.y * cs.y + v.z * cs.x);
}

vec3 rotateY(vec3 v, float rad) {
	vec2 cs = vec2exp(rad);
	return vec3(
		v.x * cs.x + v.z * cs.y,
		v.y,
		-v.x * cs.y + v.z * cs.x);
}

vec3 rotateZ(vec3 v, float rad) {
	vec2 cs = vec2exp(rad);
	return vec3(
		v.x * cs.x - v.y * cs.y,
		v.x * cs.y + v.y * cs.x,
		v.z);
}

// hmm, floating point accuracy issue ...
vec2 applyLatLonRoll0(vec2 latlon) {
#if 0 // wgs84
	vec3 pos = chart_WGS84(vec3(latlon, 0.));
	return cartesianToLatLonWGS84(pos / WGS84_a).xy * (180. /  M_PI);
#else // sphere
	vec3 pos = chart_sphere(vec3(latlon, 0.));
	pos.xyz = pos.zxy;

	vec2 latcs = vec2exp(latlonroll0.x * M_PI / 180.);
	vec2 loncs = vec2exp(latlonroll0.y * M_PI / 180.);
	vec2 rollcs = vec2exp(latlonroll0.z * M_PI / 180.);
	pos = rotateX(pos, latlonroll0.z * M_PI / 180.);
	pos = rotateY(pos, latlonroll0.x * M_PI / 180.);
	pos = rotateZ(pos, latlonroll0.y * M_PI / 180.);

	// chartInv_sphere expects north pole to be z+, prime meridian to be x+
	pos.zxy = pos.xyz;
	return chartInv_sphere(pos).xy;
#endif
}

// hmm, floating point accuracy issue ...
vec2 applyLatLonRoll0Inv(vec2 latlon) {
#if 0 // wgs84
	vec3 pos = chart_WGS84(vec3(latlon, 0.));
	return cartesianToLatLonWGS84(pos / WGS84_a).xy * (180. /  M_PI);
#else // sphere
	vec3 pos = chart_sphere(vec3(latlon, 0.));
	pos.xyz = pos.zxy;

	vec2 latcs = vec2exp(latlonroll0.x * M_PI / 180.);
	vec2 loncs = vec2exp(latlonroll0.y * M_PI / 180.);
	vec2 rollcs = vec2exp(latlonroll0.z * M_PI / 180.);

	pos = rotateZ(pos, -latlonroll0.y * M_PI / 180.);
	pos = rotateY(pos, -latlonroll0.x * M_PI / 180.);
	pos = rotateX(pos, -latlonroll0.z * M_PI / 180.);

	// chartInv_sphere expects north pole to be z+, prime meridian to be x+
	pos.zxy = pos.xyz;
	return chartInv_sphere(pos).xy;
#endif
}


]]

local drawPlanetClasses = table.filter(Planets.planetClasses, |c| c.name ~= 'earth' and c.name ~= 'EM_Bary')
-- should I do some geometry-index stuff too or nah?
local drawPlanetAngles = table{
	1, 5, 15, 30, 45, 60, 90, 120, 135, 150, 175, 179
}

-- this is only used for the ui, while the CL planetPos list has all of them, so that I can indivivdually index into it or something idk
local calcPlanetClasses = table.filter(Planets.planetClasses, |c| c.name ~= 'EM_Bary')

local weightFields = chartCNames:mapi(|name| 'weight_'..name)
local vars = table(
	weightFields:mapi(|name| (name == 'weight_Equirectangular' and 1 or 0, name)),
	{
		showOnlySelectedEarthquakeArcs = true ,	-- true = show only selected earthquake circle, false = show all
		normalizeWeights = true,
		drawEarth = true,
		drawEarthquakes = true,
		pointSize = .005,		-- but make it proportional to size in view maybe? like USGS does?
		drawGreatArcs = true,
		greatArcAlpha = .1,
		lineWidth = 1,
		angleFade = 1,
		forceTexAlpha = .5,
		calcVertTides = false,
		calcHorzTides = false,
		calcVertGrav = true,
		calcHorzGrav = false,
		drawPlanets = drawPlanetClasses:mapi(|c|(
			c.name == 'sun' or c.name == 'moon',
			c.name
		)),	-- drawPlanets[name] = true
		calcPlanets = table.mapi(Planets.planetClasses, |c|(
			c.name == 'sun' or c.name == 'moon' or c.name == 'earth',
			c.name
		)),	-- calcPlanets[name] = true
		drawPlanetAngles = drawPlanetAngles:mapi(|x|(true,x)),
		-- trying to fine-tune this one, wonder why I have to ...
		-- is my julian date calculator off?
--[[
UTC time                    my julian day #  juliandate.org's julian-day-#  = timeanddate.com's (but they don't use hours etc / fractions)
2025-06-04 13:22:35.790 = 2460831.0573587   = 2460830.72361                 = 25155
... difference = 0.33350199973211
2025-05-04 00:00:14.865 = 2460799.500172    = 2460799.16667                 = 25124
... difference = 0.33374869963154
so my julian date is 8 hours ahead = my time zone, hmmmmmm is his timezone-offset? is mine?
--]]
		--julianBaseAngle = 148,	-- based on the quake at 2025-05-04-00:00:00
		julianBaseAngle = 107,		-- based on the quake at 2025-06-04-13:22:00
		--[=[ TODO
		drawAxisTorques = true,
		axisTorquePointSize = 3,
		--]=]
		lat0 = 0,		-- degrees
		lon0 = -155,	-- degrees
		roll0 = 0,		-- degrees
		earthquakeIndex = #earthquakes,
	}
):setmetatable(nil)


local selQuakeJulianDate, planets
local rotateFromSolarToEarthFrame = |v| do
	v = rotateZ(v,
		math.rad(vars.julianBaseAngle)
		+ ((selQuakeJulianDate % 1) + .5) * -2 * math.pi * (
			-- convert from sinodic day (24 hours = 360 degrees x ())
			-- ... to sidereal day
			1 / (1 - 1 / 365.25)
		)
	)
	return v
end


local earthquakeWindowStartIndex
local earthquakeWindowEndIndex
local flareWindowStartIndex = 0
local flareWindowEndIndex = 0
local recalculateOldestEarthquakeIndex = ||do
	-- TODO with bisect
	local windowStartTime = earthquakes[vars.earthquakeIndex].ostime - calcCircles.timeWindowInDays * dayInSec
	local windowEndTime = earthquakes[vars.earthquakeIndex].ostime + calcCircles.timeWindowInDays * dayInSec
	
	earthquakeWindowStartIndex = vars!.earthquakeIndex
	for i=vars.earthquakeIndex,1,-1 do
		if earthquakes[i].ostime < windowStartTime then break end
		earthquakeWindowStartIndex = i
	end
	earthquakeWindowEndIndex = vars!.earthquakeIndex
	for i=vars.earthquakeIndex,#earthquakes do
		if earthquakes[i].ostime > windowEndTime then break end
		earthquakeWindowEndIndex = i
	end

	if #flares > 0 then
		flareWindowStartIndex = #flares
		for i=#flares,1,-1 do
			if flares[i].ostime < windowStartTime then break end
			flareWindowStartIndex = i
		end
		flareWindowEndIndex = flareWindowStartIndex
		for i=flareWindowStartIndex,#flares do
			if flares![i]!.ostime > windowEndTime then break end
			flareWindowEndIndex = i
		end
	end
end


local App = require 'imgui.appwithorbit'()
App.title = 'Earthquake Geodesics'
App.viewDist = 2

local allCircles, circlesMadeByQuakes
App.recalcAllCircles=|:|do
	allCircles = calcCircles.calcCircles(earthquakes)

	-- should this be based on what quakes are within 60' and caused me to flag the geodesic?
	-- or should this be on what quakes are subsequently within 1' or 5' or so of that geodesic after-the-fact?
	-- doing the former first ...
	circlesMadeByQuakes = {}
	for ci,c in ipairs(allCircles) do
		for _,i in ipairs(c.indexes) do
			circlesMadeByQuakes[i] ??= table()
			circlesMadeByQuakes[i]:insert(ci)
		end
	end

	self:refreshRelevantCircles()	-- TODO don't recalc all circles, just recalc indexes used
end

App.initGL = |:| do
	App.super.initGL(self)
	self.view.ortho = true
	self.view.orthoSize = 3
	-- [=====[ BEGIN CLIP FROM GEOGRAPHIC-CHARTS
	local vertexes = table()
	local idivs = 100
	local jdivs = 200
	for i=0,idivs do
		local u = i/idivs
		--local phi = math.rad((u * 2 - 1) * 90)
		for j=0,jdivs do
			local v = j/jdivs
			--local lambda = math.rad((v * 2 - 1) * 180)
			vertexes:insert(u * 180 - 90)	-- lat, lon = u, v
			vertexes:insert(v * 360 - 180) -- transposed from texcoord space in texcoord space
		end
	end
	self.vertexBuf = GLArrayBuffer{
		data = vertexes,
		dim = 2,
	}:unbind()

	local geometries = table()
	for jbase=0,jdivs-1 do
		local indexes = table()
		for i=0,idivs do
			for jofs=1,0,-1 do
				local j = jbase + jofs
				indexes:insert(j + (jdivs + 1) * i)
			end
		end
		geometries:insert(GLGeometry{
			mode = gl.GL_TRIANGLE_STRIP,
			indexes = {
				data = indexes,
			},
			vertexes = self.vertexBuf,
		})
	end

	local texWrap = {
		s = gl.GL_REPEAT,
		--t = gl.GL_CLAMP_TO_EDGE,
		t = gl.GL_CLAMP_TO_BORDER,
	}

	self.globeObj = GLSceneObject{
		program = {
			version = 'latest',
			precision = 'best',
			vertexCode = template([[
layout(location=0) in vec2 vertex;
out vec2 texcoordv;
out vec3 posv;

uniform mat4 mvProjMat;
uniform bool chartIs3D;
uniform vec3 latlonroll0;

<?=chartCode?>

void main() {
	vec2 vtxofs = applyLatLonRoll0Inv(vertex);

	//(lat, lon) in [0, 1]
	texcoordv = vec2(
		vtxofs.y / 360. + .5,
		vtxofs.x / 180. + .5
	);

	vec3 coords = vec3(
		mod(vertex.x + 90., 180.) - 90.,	// lat in deg, [-90, 90]
		mod(vertex.y + 180., 360.) - 180.,	// lon in deg, [-180, 180]
		0.);						// height in meters

	vec3 pos = 0.
<? for _,name in ipairs(chartCNames) do
?>		+ weight_<?=name?> * chart_<?=name?>(coords)
<? end
?>	;

	//from meters to normalized coordinates
	pos /= WGS84_a;

	if (chartIs3D) {
		pos = vec3(pos.z, pos.x, pos.y);
	}
	posv = pos;

	// lets see the grid over it
	pos *= .99;

	gl_Position = mvProjMat * vec4(pos, 1.);
}

]], 		{
				chartCode = chartCode,
				chartCNames = chartCNames,
			}),

-- [=[
		geometryCode = [[
layout (triangles) in;
layout (triangle_strip, max_vertices = 3) out;

in vec2 texcoordv[];
out vec2 texcoordg;

in vec3 posv[];

void main() {
	vec3 dlen = vec3(
		length(posv[1] - posv[0]),
		length(posv[2] - posv[1]),
		length(posv[0] - posv[2]));
	if (dlen.x > .25 || dlen.y > .25 || dlen.z > .25)
	{
		return;
	}

	gl_Position = gl_in[0].gl_Position;
	texcoordg = texcoordv[0];
	EmitVertex();

	gl_Position = gl_in[1].gl_Position;
	texcoordg = texcoordv[1];
	if (texcoordv[1].x - texcoordv[0].x > .5) {
		texcoordg.x -= 1.;
	}
	if (texcoordv[1].x - texcoordv[0].x < -.5) {
		texcoordg.x += 1.;
	}
	EmitVertex();

	gl_Position = gl_in[2].gl_Position;
	texcoordg = texcoordv[2];
	if (texcoordv[2].x - texcoordv[0].x > .5) {
		texcoordg.x -= 1.;
	}
	if (texcoordv[2].x - texcoordv[0].x < -.5) {
		texcoordg.x += 1.;
	}
	EmitVertex();

	EndPrimitive();
}
]],
--]=]


			fragmentCode = template[[
in vec2 texcoordg;
out vec4 fragColor;

uniform sampler2D earthTex;
uniform sampler2D forceTex;
uniform sampler2D gradientTex;

uniform float alpha;
uniform float forceTexAlpha;

void main() {
	vec2 uv = vec2(texcoordg.x, 1. - texcoordg.y);
	fragColor = texture(earthTex, uv);
	float force = texture(forceTex, uv).r;
	vec4 forceColor = texture(gradientTex, vec2(force, .5));
	fragColor = mix(fragColor, forceColor, forceTexAlpha);
	fragColor.a = alpha;
}
]],
			uniforms = {
				earthTex = 0,
				forceTex = 1,
				gradientTex = 2,
				alpha = .5,
			},
		},
		vertexes = self.vertexBuf,
		geometries = geometries,
		texs = {
			GLTex2D{
				filename = 'earth-color.png',
				magFilter = gl.GL_LINEAR,
				--minFilter = gl.GL_NEAREST,
				minFilter = gl.GL_LINEAR_MIPMAP_LINEAR,
				generateMipmap = true,
				wrap = texWrap,
			}:unbind(),
		},
		uniforms = {
			weight_Equirectangular = 1,
			weight_Azimuthal_equidistant = 0,
			weight_Mollweide = 0,
			weight_WGS84 = 0,
		},
	}
	--]=====] END CLIP FROM GEOGRAPHIC-CHARTS


	-- [=====[ BEGIN EARTHQUAKES
	self.earthquakeLatLonPointObj = GLSceneObject{
		program = {
			version = 'latest',
			precision = 'best',
			vertexCode = template([[
layout(location=0) in vec3 vertex;
layout(location=1) in vec2 texcoord;
out vec2 texcoordv;
flat out float beforeOrAfterHiliteIndex;

uniform mat4 mvProjMat;
uniform bool chartIs3D;
uniform vec3 latlonroll0;
uniform float pointSize;
uniform uint hiliteIndex;

<?=chartCode?>

void main() {
	texcoordv = texcoord;

	float alt = 1e+3;
	if (gl_VertexID >= hiliteIndex * 6 && gl_VertexID < (hiliteIndex + 1) * 6) {
		beforeOrAfterHiliteIndex = 0.;
		alt *= 2.;
	} else if (gl_VertexID < hiliteIndex * 6) {
		beforeOrAfterHiliteIndex = -1.;
	} else {	// gl_VertexID >= (hiliteIndex + 1) * 6
		beforeOrAfterHiliteIndex = 1.;
	}

	vec2 vtxofs = applyLatLonRoll0(vertex.xy);

	vec3 coords = vec3(
		mod(vtxofs.x + 90., 180.) - 90.,	// lat in deg, [-90, 90]
		mod(vtxofs.y + 180., 360.) - 180.,	// lon in deg, [-180, 180]
		alt);				// height in meters

	vec3 pos = 0.
<? for _,name in ipairs(chartCNames) do
?>		+ weight_<?=name?> * chart_<?=name?>(coords)
<? end
?>	;
	pos /= WGS84_a;	//from meters to normalized coordinates

	if (chartIs3D) {
		pos = vec3(pos.z, pos.x, pos.y);
	}


	mat3 e = mat3(vec3(0.), vec3(0.), vec3(0.))
<? for _,name in ipairs(chartCNames) do
?>		+ weight_<?=name?> * chart_<?=name?>_basis(vec3(coords.xy, 0.))
<? end
?>	;
	float magn = vertex.z;
	pos += (texcoord.x * e[0] + texcoord.y * e[1]) * pointSize * magn;

	gl_Position = mvProjMat * vec4(pos, 1.);
}

]], 		{
				chartCode = chartCode,
				chartCNames = chartCNames,
			}),
			fragmentCode = [[
in vec2 texcoordv;
flat in float beforeOrAfterHiliteIndex;
out vec4 fragColor;
void main() {
	float lenSq = dot(texcoordv, texcoordv);
	if (lenSq > 1.) discard;
	if (beforeOrAfterHiliteIndex == 0.) {
		fragColor = vec4(1., 1., 0., 1.);
	} else if (beforeOrAfterHiliteIndex < 0.) {
		fragColor = vec4(1., 0., 0., 1.);
	} else { 	// if (beforeOrAfterHiliteIndex > 0.) {
		fragColor = vec4(0., 1., 0., 1.);
	}
	if (lenSq > .9*.9) {
		fragColor = vec4(0., 0., 0., 1.);
	}
}
]],
		},
		geometry = {
			mode = gl.GL_TRIANGLES,
		},
		vertexes = {
			dim = 3,
			useVec = true,
		},
		attrs = {
			texcoord = {
				buffer = {
					dim = 2,
					useVec = true,
				},
			},
		},
	}
	-- TODO .useVec with .data ... atm it just overwrites .data

	local quadVtxs = {
		{0, 0},
		{1, 0},
		{0, 1},
		{0, 1},
		{1, 0},
		{1, 1}
	}
	local vertexGPU = self.earthquakeLatLonPointObj.attrs.vertex.buffer
	local texcoordGPU = self.earthquakeLatLonPointObj.attrs.texcoord.buffer
	local vertexCPU = vertexGPU:beginUpdate()
	local texcoordCPU = texcoordGPU:beginUpdate()
	for i,eq in ipairs(earthquakes) do
		-- latitude: S = negative, N = positive
		-- longitude: W = negative, E = positive
--print(i, eq.latitude, eq.longitude)
		for _,v in ipairs(quadVtxs) do
			vertexCPU:emplace_back()[0]:set(eq.latitude, eq.longitude, eq.mag)
			texcoordCPU:emplace_back()[0]:set(v[1] * 2 - 1, v[2] * 2 - 1)
		end
	end
	assert.eq(#vertexCPU, 6 * #earthquakes)
	vertexGPU:endUpdate()
	texcoordGPU:endUpdate()
	--]=====] END EARTHQUAKES

	local numCircleDivs = 200
	self.circlesObj = GLSceneObject{
		-- TODO geometry shader the resolution? or can they even spit out that many vertexes?
		vertexes = {
			dim = 1,
			data = range(numCircleDivs):mapi(|i| (i-.5)/numCircleDivs),
		},
		geometry = {
			mode = gl.GL_LINE_LOOP,
		},
		program = {
			version = 'latest',
			precision = 'best',
			vertexCode = template([[
layout(location=0) in float vertex;
out vec3 posv;
out vec4 colorv;

uniform vec3 color;	// base color
uniform vec3 axis, axis2, axis3;	// axis dual = basis of circle
uniform float declinationFromAxis;	// ... in radians
uniform float influence;	// additive influence,
uniform float angleFade;	// how much to fade out from the centerPos / centerAngle
uniform vec4 centerPos;	// .w = cos(centerAngle)


uniform mat4 mvProjMat;
uniform bool chartIs3D;
uniform vec3 latlonroll0;	// used for texturing, TODO FIXME proper 3d transform

<?=chartCode?>

void main() {
	float theta = vertex * 2. * M_PI;

	float decl = cos(declinationFromAxis);
	float phi_r = sin(declinationFromAxis);

	vec3 v = axis * decl + phi_r * (axis2 * cos(theta) + axis3 * sin(theta));
	float cosAngle = dot(v, centerPos.xyz);
	float alpha = clamp(cosAngle * centerPos.w + angleFade, 0., 1.);
	colorv = vec4(color * influence, alpha);

	vec2 latlon = cartesianToLatLonWGS84(v).xy;
	// ... to degrees
	latlon.x *= 180. / M_PI;	//[-90, 90]
	latlon.y *= 180. / M_PI;	//[-180, 180]

	vec2 latlonofs = applyLatLonRoll0(latlon);

	//////// BEGIN CODE MATCHING CHART CODE ABOVE
	vec3 coords = vec3(
		mod(latlonofs.x + 90., 180.) - 90.,	// lat in deg, [-90, 90]
		mod(latlonofs.y + 180., 360.) - 180.,	// lon in deg, [-180, 180]
		2e+3);						// height in meters

	vec3 pos = 0.
<? for _,name in ipairs(chartCNames) do
?>		+ weight_<?=name?> * chart_<?=name?>(coords)
<? end
?>	;

	//from meters to normalized coordinates
	pos /= WGS84_a;

	if (chartIs3D) {
		pos = vec3(pos.z, pos.x, pos.y);
	}
	posv = pos;
	gl_Position = mvProjMat * vec4(pos, 1.);
	//////// END CODE MATCHING CHART CODE ABOVE
}
]],			{
				chartCode = chartCode,
				chartCNames = chartCNames,
			}),

-- [=[ but really just don't use this, just cull the vertexes in the array buffer
-- then again, this does let me split up line loops.
			-- lets see if we can hide lines that loop from lon=-180 to lon=+180 and go across the equirectangular/mollweide/most 2D projections
			-- TODO I could use this for the circle tesselation to begin with.  just pass the angle + axis.
			-- TODO TODO once I do that, I could also just do the cartesian-to-wgs84 in the fragment, then apply the charts in the fragment.
			geometryCode = [[
layout (lines) in;
layout (line_strip, max_vertices = 2) out;

in vec4 colorv[];
in vec3 posv[];
out vec4 colorg;

void main() {
	float dlen = length(posv[1] - posv[0]);
	if (dlen > .25) {
		return;
	}

	gl_Position = gl_in[0].gl_Position;
	colorg = colorv[0];
	EmitVertex();

	gl_Position = gl_in[1].gl_Position;
	colorg = colorv[1];
	EmitVertex();

	EndPrimitive();
}
]],
--]=]
			fragmentCode = [[
in vec4 colorg;		// using geometry shader
//in vec4 colorv;	// not using geometry shader
out vec4 fragColor;
uniform float alpha;
void main() {
	fragColor = colorg;
	//fragColor = colorv;
	fragColor.a *= alpha;
}
]],
		},
	}



	gl.glEnable(gl.GL_DEPTH_TEST)


	--[=[ build here
	-- show axii of circles
	self.pairCrossPointsObj = GLSceneObject{
		program = {
			version = 'latest',
			precision = 'best',
			vertexCode = template([[
layout(location=0) in vec2 vertex;
uniform mat4 mvProjMat;
uniform bool chartIs3D;
uniform vec3 latlonroll0;

<?=chartCode?>

void main() {
	vec2 vtxofs = applyLatLonRoll0(vertex);

	//////// BEGIN CODE MATCHING CHART CODE ABOVE
	vec3 coords = vec3(
		mod(vtxofs.x + 90.., 180.) - 90.,	// lat in deg, [-90, 90]
		mod(vtxofs.y + 180., 360.) - 180.,	// lon in deg, [-180, 180]
		2e+3);						// height in meters

	vec3 pos = 0.
<? for _,name in ipairs(chartCNames) do
?>		+ weight_<?=name?> * chart_<?=name?>(coords)
<? end
?>	;

	//from meters to normalized coordinates
	pos /= WGS84_a;

	if (chartIs3D) {
		pos = vec3(pos.z, pos.x, pos.y);
	}
	gl_Position = mvProjMat * vec4(pos, 1.);
	//////// END CODE MATCHING CHART CODE ABOVE

}
]],			{
				chartCode = chartCode,
				chartCNames = chartCNames,
			}),
			fragmentCode = [[
out vec4 fragColor;
void main() {
	fragColor = vec4(1., 1., 1., 1.);
}
]],
},
		geometry = {
			mode = gl.GL_POINTS,
		},
		vertexes = {
			dim = 3,
			useVec = true,
		},
	}

	local pairCrossPoints = self.pairCrossPointsObj.attrs.vertex.buffer.vec
	circles = table()
	for i1=1,#earthquakes-1 do
		local e1 = earthquakes[i1]
		for i2=i1+1,#earthquakes do
			local e2 = earthquakes[i2]
			local v1 = latLonToXYZ(e1)
			local v2 = latLonToXYZ(e2)
			local torque = v1:cross(v2)	-- TODO times pair of earthquake magnitudes or something?
			local axisLen = torque:length()
			local axis = torque * (1 / (math.max(axisLen, 1e-15)))
			local influence = axisLen * 10^e1.mag * 10^e2.mag
			-- hmm proper torque would be based on radius from earth ... so consider depth?

			-- hmmmmm
			-- if ponits are 180' or if they are next to each other then we want no infuence ...
			-- ... .maybe I souldn't nrmlize with the cross produt ...
			-- and then I should look at the point-cloud of the axis' ...
			for s=-1,1,2 do
				local x,y,z = (s * torque):unpack()
				local phi, lambda = cartesianToLatLonWGS84(z,x,y)	-- hmm ...
				pairCrossPoints:insert((((math.deg(phi) + 90) / 180) % 1) * 180 - 90)
				pairCrossPoints:insert((((math.deg(lambda) + 180) / 360) % 1) * 360 - 180)
			end

			local angle = math.acos(v1:dot(v2))
			--if math.rad(15) < angle and angle < math.rad(60) then		-- threshold angle for point pairs for inserting a great-arc
			if math.rad(10) < angle and angle < math.rad(90) then	-- if I weight by cross then that'll make the 0' and 180' angles diminish ... nah, there's still a lot of noise unless I turn down the alpha ... then it's hard to highlight any geodesics ...
				circles:insert{
					axis = axis,
					angle = math.pi * .5,
					color = vec3d(1, .3, .07) * influence,
					centerPos = (v1 + v2):normalize(),	-- midpoint between two earthquake lines
					centerAngle = .5 * angle,	-- half the angle between them
				}
			end
		end
	end
	self.pairCrossPointsObj:endUpdate()
	--]=]
	--[=[ or TODO all circles and just hide/show the ones associated with the current quake ...
	circles = allCircles
	--]=]



if COMPUTE_TIDES then
	-- while we're here, let's compute the tidal and gravitational forces of our planets ...
	-- TODO take it from my solarsystem project where I'm already doing this
	-- but compute shader? does GL support double buffers? I don't think so . . .
	-- maybe I have to use OpenCL now

	self.clsize = {200,100}		-- or maybe "forceTexDim" or something
	self.clvolume = self.clsize[1] * self.clsize[2]
	self.env = CLEnv{
		verbose = true,
		useGLSharing = false,
		precision = 'double',
		-- TODO how about a getter-for-cmdline-obj ?
		--getPlatform = CLEnv.getterForIdent(cmdline.platform, 'platform'),
		--getDevices = CLEnv.getterForIdent(cmdline.device, 'device'),
		--deviceType = CLEnv.getDeviceTypeFromCmdLine(...),
		size = self.clsize,
	}

	self.calcTideAndGravProgram = self.env:program{
		code = template([[
real rad(real d) {
	return d * M_PI / 180.;
}

constant const real WGS84_a = 6378137.;		// m
constant const real WGS84_b = 6356752.3142;	// m @ polar radius
constant const real WGS84_esq = 1. - WGS84_b * WGS84_b / (WGS84_a * WGS84_a);
constant const real WGS84_e = <?=clnumber(WGS84_e)?>;//sqrt(WGS84_esq); ... but no constexpr in CL .c ... have to upgrade to clcpp but then you need to rope in spirv compiler ... too much drama ...
constant const real WGS84_flattening = 1. - WGS84_b / WGS84_a;
constant const real WGS84_inverseFlattening = 298.257223563;
constant const real WGS84_eccentricitySquared = (2. * WGS84_inverseFlattening - 1.) / (WGS84_inverseFlattening * WGS84_inverseFlattening);
constant const real gravitationalConstant = 6.6738480e-11;	// m^3 / (kg s^2)

real WGS84_calc_N(real sinTheta) {
	real denom = sqrt(1. - WGS84_eccentricitySquared * sinTheta * sinTheta);
	return WGS84_a / denom;
}

real2 perp2(real2 a) {
	return (real2)(-a.y, a.x);
}

real4 xformZBackToZUp(real4 pt) {
	//convert from z-towards-user (3D) to z-up (2D)
	pt.yz = -perp2(pt.yz);		//rotate back so pt is up
	pt.xz = perp2(pt.xz);		//now rotate so prime meridian is along -z instead of +x
	return pt;
}

// how many copies of this do I need?
// This is the CL version to go with the GLSL version...
// I think I can gsub one to the other ...
real4 chart_WGS84(real4 latLonHeight) {
	real lat = latLonHeight.x;
	real lon = latLonHeight.y;
	real height = latLonHeight.z;

	real phi = rad(lon);		// spherical φ
	real theta = rad(lat);		// spherical inclination angle (not azumuthal θ)
	real cosTheta = cos(theta);
	real sinTheta = sin(theta);

	real N = WGS84_calc_N(sinTheta);

	real NPlusH = N + height;
	real4 y = (real4)(
		NPlusH * cosTheta * cos(phi),
		NPlusH * cosTheta * sin(phi),
		(N * (1. - WGS84_eccentricitySquared) + height) * sinTheta,
		0.
	);
	// at this point we're in meters
	// now rotate back
	y = xformZBackToZUp(y);
	return y;
}

//returns magnitude g+m-2d
real4 calcGravityAccel(
	real4 posOnEarth, 			//relative to earth, in meters
	real4 planetPosRelEarth 	//relative to earth, in meters, w = mass in kg
) {
	real4 x = posOnEarth - planetPosRelEarth;
	x.w = 0.;
	real const r = length(x);
	real const planetMass = planetPosRelEarth.w;
	return x * (-planetMass * gravitationalConstant / (r * r * r));
}

//returns magnitude g+m-2d
real4 calcTidalAccel(
	real4 posOnEarth,
	real4 normal,
	real4 planetPosRelEarth
) {
	real4 x = posOnEarth - planetPosRelEarth;
	x.w = 0.;
	real const r = length(x);
	real const r2 = r * r;
	real const r3 = r * r2;
	real const xDotN = dot(x, normal);
	real const planetMass = planetPosRelEarth.w;
	return (x * (3. * xDotN / r2) - normal) * (gravitationalConstant * planetMass / r3);
}

kernel void calcTideAndGrav(
	global real * out,		// output[i] = force component specified
	global real4 * const planetPosRelEarth,	// input positions[9] = (pos - earth.pos) x y z and mass = w
	int component
) {
	initKernelForSize(<?=clsize[1]?>, <?=clsize[2]?>, 1);
	// index, x = longitude = east/west, y = latitude = north/south

	// lat lon, x = latitude = north/south, longitude = left/right
	real4 latlon = (real4)(
		(real)((i.y + .5) / <?=clnumber(clsize[2])?>) * 180. - 90.,
		(real)((i.x + .5) / <?=clnumber(clsize[1])?>) * 360. - 180.,
		0.,
		0.
	);

	real4 posOnEarth = chart_WGS84(latlon);
	real4 normal = normalize(posOnEarth);

	real4 accel = (real4)(0., 0., 0., 0.);
	for (int j = 0; j < <?=#Planets.planetClasses?>; ++j) {
	//for (int j = <?=Planets.indexes.earth-1?>; j <= <?=Planets.indexes.earth-1?>; ++j) {
		if (planetPosRelEarth[j].w > 0.) {
			if (component & 3) {
				real4 tideAccel = calcTidalAccel(posOnEarth, normal, planetPosRelEarth[j]);
				if ((component & 3) == 3) {
					accel += tideAccel;
				} else {
					real4 tideNormal = normal * dot(tideAccel, normal);
					real4 tideTangent = tideAccel - tideNormal;
					if (component & 1) accel += tideNormal;
					if (component & 2) accel += tideTangent;
				}
			}
			if (component & 0xc) {
				real4 gravAccel = calcGravityAccel(posOnEarth, planetPosRelEarth[j]);
				if ((component & 0xc) == 0xc) {
					accel += gravAccel;
				} else {
					real4 gravNormal = normal * dot(gravAccel, normal);
					real4 gravTangent = gravAccel - gravNormal;
					if (component & 4) accel += gravNormal;
					if (component & 8) accel += gravTangent;
				}
			}
		}
	}

	out[index] = length(accel);
}

kernel void rescale(
	global float * outv,
	global real * const inv,
	real minv,
	real maxv
) {
	initKernelForSize(<?=clsize[1]?>, <?=clsize[2]?>, 1);
	outv[index] = (float)((inv[index] - minv) / (maxv - minv));
}

]],		{
			clsize = self.clsize,
			clnumber = clnumber,
			WGS84_e = math.sqrt(1. - charts.WGS84.b^2 / charts.WGS84.a^2),
			Planets = Planets,		-- whatever size the list the self.planetPosRelEarthBuffer is
		}),
	}

	self.calcTideAndGravProgram:compile()

	self.forceBuffer = self.env:buffer{name='forceBuffer', type='real'}

	self.rescaleForceCPUBuf = vector('float', self.clvolume)
assert.len(self.rescaleForceCPUBuf, self.clvolume)
	self.rescaleForceBuffer = self.env:buffer{name='forceBuffer', type='float'}

	self.reduceBuffer = self.env:buffer{name='reduceBuffer', type='real'}
	self.reduceSwapBuffer = self.env:buffer{name='reduceSwapBuffer', type='real'}
	self.reduceResultPtr = ffi.new'real[1]'
	self.reduceResultPtr[0] = 0

	self.planetPosRelEarthCPUBuf = vector('real4', #Planets.planetClasses)
	self.planetPosRelEarthBuffer = self.env:buffer{
		name = 'planetPosRelEarthBuffer',
		type = 'real4',
		size = {#Planets.planetClasses},
	}	-- all planets, including earth, because maybe we want it too.

	self.calcTideAndGravKernel = self.calcTideAndGravProgram:kernel'calcTideAndGrav'
	self.calcTideAndGravKernel.obj:setArg(0, self.forceBuffer)
	self.calcTideAndGravKernel.obj:setArg(1, self.planetPosRelEarthBuffer)

	-- TODO instead of this, use GL sharing?
	self.rescaleKernel = self.calcTideAndGravProgram:kernel'rescale'
	self.rescaleKernel.obj:setArg(0, self.rescaleForceBuffer)
	self.rescaleKernel.obj:setArg(1, self.forceBuffer)

	self.reduceMin = self.env:reduce{
		count = self.clvolume,
		op = |x,y| 'min('..x..', '..y..')',
		initValue = 'INFINITY',
		buffer = self.reduceBuffer.obj,
		swapBuffer = self.reduceSwapBuffer.obj,
		result = self.reduceResultPtr,
	}

	self.reduceMax = self.env:reduce{
		count = self.clvolume,
		op = |x,y| 'max('..x..', '..y..')',
		initValue = '-INFINITY',
		buffer = self.reduceBuffer.obj,
		swapBuffer = self.reduceSwapBuffer.obj,
		result = self.reduceResultPtr,
	}

	local internalFormat = gl.GL_R32F
	local info = require 'gl.tex'.formatInfoForInternalFormat[internalFormat]
	self.forceTex = GLTex2D{
		width = self.clsize[1],
		height = self.clsize[2],
		magFilter = gl.GL_LINEAR,
		minFilter = gl.GL_LINEAR_MIPMAP_LINEAR,
		wrap = texWrap,
		internalFormat = info.internalFormat,
		format = info.format,
		type = info.types[1],
		data = self.rescaleForceCPUBuf.v,
	}:unbind()
	self.globeObj.texs:insert(self.forceTex)
	self.gradientTex = GLGradientTex2D(
		256,
--[[ rainbow
		{
			{1,0,0,1},
			{1,1,0,1},
			{0,1,0,1},
			{0,1,1,1},
			{1,0,1,1},
		}
--]]
-- [[ sunset pic from https://blog.graphiq.com/finding-the-right-color-palettes-for-data-visualizations-fcd4e707a283#.inyxk2q43
-- also in efesoln-cl-lua
		table{
			vec3d(22,31,86),
			vec3d(34,54,152),
			vec3d(87,49,108),
			vec3d(156,48,72),
			vec3d(220,60,57),
			vec3d(254,96,50),
			vec3d(255,188,46),
			vec3d(255,255,55),
		}:mapi(|c| do
			local x,y,z = (c/255):unpack()
			--return table(x,y,z):append{1}
			return {x,y,z,1}
		end)
--]]
	):unbind()
	self.globeObj.texs:insert(self.gradientTex)
end -- COMPUTE_TIDES

	recalculateOldestEarthquakeIndex()
	self:recalcAllCircles()
	self:updateEarthquakeIndex()
end

-- refresh the list of what circles we want to display right now
-- this is either all circles in the last period (3 days? 1 day? etc)
-- or it is all that are touching the currently selected quake
App.refreshRelevantCircles = |:| do
	if vars.showOnlySelectedEarthquakeArcs then
		-- show all circles touching our currently selected
		circles = earthquakes[vars.earthquakeIndex]
			.touchingCircles:mapi(|t| allCircles[t.circle])
	else
		-- show all circles touching any active earthquakes in the last timeframe
		-- TODO also include future window ... but also TODO should we show future earthquakes too?
		-- TODO earthquake window slider relative to the previous quake?
		local circleIndexes = table()
		for i=earthquakeWindowStartIndex,earthquakeWindowEndIndex do
			for _,ci in ipairs(circlesMadeByQuakes[i]) do
				circleIndexes[ci] = true
			end
		end
		circles = circleIndexes:keys():sort():mapi(|ci| allCircles[ci])
	end
end

App.update = |:| do
	gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT)

	if vars.drawEarth then
		local sceneObj = self.globeObj
		for _,name in ipairs(weightFields) do
			sceneObj.uniforms[name] = vars[name]
		end
		sceneObj.uniforms.latlonroll0 = {vars.lat0, vars.lon0, vars.roll0}
		sceneObj.uniforms.chartIs3D = false	-- this is just whether to swap x y and z around , z = along view vs z = north pole
		sceneObj.uniforms.mvProjMat = self.view.mvProjMat.ptr
		sceneObj.uniforms.forceTexAlpha = vars.forceTexAlpha
		sceneObj:draw()
	end

	do
		local eq = earthquakes[vars.earthquakeIndex]

		gl.glLineWidth(vars.lineWidth)
		--gl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE)
		gl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE_MINUS_SRC_ALPHA)
		gl.glEnable(gl.GL_BLEND)
		gl.glDepthMask(0)

		local sceneObj = self.circlesObj
		for _,name in ipairs(weightFields) do
			sceneObj.uniforms[name] = vars[name]
		end
		sceneObj.uniforms.declinationFromAxis = .5 * math.pi
		sceneObj.uniforms.latlonroll0 = {vars.lat0, vars.lon0, vars.roll0}
		sceneObj.uniforms.angleFade = vars.angleFade
		sceneObj.uniforms.chartIs3D = false	-- this is just whether to swap x y and z around , z = along view vs z = north pole
		sceneObj.uniforms.mvProjMat = self.view.mvProjMat.ptr
		sceneObj.uniforms.alpha = vars.greatArcAlpha
		if vars.drawGreatArcs then
			for _,c in ipairs(circles) do
				local t1 = earthquakes[c.indexes[1]].ostime
				local t2 = earthquakes[c.indexes[2]].ostime
				local tavg = (t1 + t2) >> 1
				if tavg < eq.ostime then
					sceneObj.uniforms.color = {c.color.x, 0, 0}
				else
					sceneObj.uniforms.color = {0, c.color.y, 0}
				end
				sceneObj.uniforms.axis = {c.axis:unpack()}
				sceneObj.uniforms.axis2 = {c.axis2:unpack()}
				sceneObj.uniforms.axis3 = {c.axis3:unpack()}
				sceneObj.uniforms.influence = c.influence
				sceneObj.uniforms.centerPos = {c.centerPos.x, c.centerPos.y, c.centerPos.z, 1. / math.cos(c.centerAngle)}
				sceneObj:draw()
			end
		end
		gl.glDisable(gl.GL_BLEND)
		do
			gl.glLineWidth(3)
			sceneObj.uniforms.angleFade = 1
			local earthPos = planets[Planets.indexes.earth].pos
			for _,planetClass in ipairs(drawPlanetClasses) do
				if vars.drawPlanets[planetClass.name] then
					for _,declAngle in ipairs(drawPlanetAngles) do
						if vars.drawPlanetAngles[declAngle] then
							local planetPos = planets[Planets.indexes[planetClass.name]].pos
							local planetDir = (planetPos - earthPos):normalize()
							planetDir = rotateFromSolarToEarthFrame(planetDir)	-- rotate by earth tilt and time of day
							local axis2 = basisFor(planetDir)
							local axis3 = planetDir:cross(axis2)
							sceneObj.uniforms.declinationFromAxis = math.rad(declAngle)
							sceneObj.uniforms.color = planetClass.color
							sceneObj.uniforms.axis = {planetDir:unpack()}
							sceneObj.uniforms.axis2 = {axis2:unpack()}
							sceneObj.uniforms.axis3 = {axis3:unpack()}
							sceneObj.uniforms.influence = 1
							sceneObj.uniforms.centerPos = {0,0,0,1}
							sceneObj:draw()
						end
					end
				end
			end
		end
		gl.glDepthMask(1)
		gl.glLineWidth(1)
	end

	if vars.drawEarthquakes then
		gl.glDepthFunc(gl.GL_LEQUAL)
		local sceneObj = self.earthquakeLatLonPointObj
		for _,name in ipairs(weightFields) do
			sceneObj.uniforms[name] = vars[name]
		end
		sceneObj.uniforms.latlonroll0 = {vars.lat0, vars.lon0, vars.roll0}
		sceneObj.uniforms.chartIs3D = false	-- this is just whether to swap x y and z around , z = along view vs z = north pole
		sceneObj.uniforms.mvProjMat = self.view.mvProjMat.ptr
		sceneObj.uniforms.pointSize = vars.pointSize
		sceneObj.uniforms.hiliteIndex = vars.earthquakeIndex - 1

		-- 6 * becuse i'm drawing two tris per point into the vertex buffer (TODO billboard and instances maybe?)
		sceneObj.geometry.offset = 6 * (earthquakeWindowStartIndex - 1)
		sceneObj.geometry.count = 6 * (earthquakeWindowEndIndex - earthquakeWindowStartIndex + 1)

		sceneObj:draw()

		sceneObj.geometry.offset = nil
		sceneObj.geometry.count = nil
		gl.glDepthFunc(gl.GL_LESS)
	end

	--[=[ TODO show torque axii
	if vars.drawAxisTorques then
		local sceneObj = self.pairCrossPointsObj
		if #sceneObj.attrs.vertex.buffer.vec > 0 then
			for _,name in ipairs(weightFields) do
				sceneObj.uniforms[name] = vars[name]
			end
			sceneObj.uniforms.latlonroll0 = {vars.lon0, vars.lat0, vars.roll0}
			sceneObj.uniforms.chartIs3D = false	-- this is just whether to swap x y and z around , z = along view vs z = north pole
			sceneObj.uniforms.mvProjMat = self.view.mvProjMat.ptr

			gl.glPointSize(vars.axisTorquePointSize)
			sceneObj:draw()
			gl.glPointSize(1)
		end
	end
	--]=]

	App.super.update(self)


	-- while we're here...
	-- ... re-download the latest day's earthquakes
	local t = time()
	if t > checkTime + checkDuration then
		checkTime = t
		local newTodaysEarthquakes, changed = getDayCache(t, true)
		if changed then
			print(os.date(), 'TODO upate me plz')
		end
	end
end

App.updateEarthquakeIndex = |:| do
	vars.earthquakeIndex = math.clamp(math.round(vars.earthquakeIndex), 1, #earthquakes)
	local eq = earthquakes[vars.earthquakeIndex]
	selQuakeJulianDate = Julian.fromCalendar(eq.date)
	planets = Planets.fromEphemeris(selQuakeJulianDate, 406, '../solarsystem/eph/406')

	-- TODO redo circle' touchingindexes to scan both + and - in time by 1 day
	recalculateOldestEarthquakeIndex()
	self:refreshRelevantCircles()	-- TODO don't recalc all circles, just recalc indexes used

	self:refreshForceBuffer()
end

App.refreshForceBuffer = |:|do
--DEBUG:print'refreshing force buffer'
if COMPUTE_TIDES then
	local earthPos = planets[Planets.indexes.earth].pos
	for i,p in ipairs(planets) do
		local v = planets[i].pos - earthPos
		v = rotateFromSolarToEarthFrame(v)
		local pos = self.planetPosRelEarthCPUBuf.v + (i-1)
		pos.x = v.x
		pos.y = v.y
		pos.z = v.z
		pos.w = vars.calcPlanets[p.name] and p.mass or 0
--DEBUG:print('planet', i, 'name', p.name, 'mass', pos.w)
	end
	self.planetPosRelEarthBuffer:fromCPU(self.planetPosRelEarthCPUBuf.v)

	self.calcTideAndGravKernel.obj:setArg(2, int(0
		| (vars.calcVertTides and 1 or 0)
		| (vars.calcHorzTides and 2 or 0)
		| (vars.calcVertGrav and 4 or 0)
		| (vars.calcHorzGrav and 8 or 0)
	))
	self.calcTideAndGravKernel()

	self.forceMin = self.reduceMin(self.forceBuffer.obj)
	self.forceMax = self.reduceMax(self.forceBuffer.obj)

	self.rescaleKernel.obj:setArg(2, double(self.forceMin))
	self.rescaleKernel.obj:setArg(3, double(self.forceMax))
	self.rescaleKernel()

	self.rescaleForceBuffer:toCPU(self.rescaleForceCPUBuf.v)
	self.forceTex
		:bind()
		:subimage()
		:generateMipmap()
		:unbind()
end -- COMPUTE_TIDES
end

App.event = |:,e| do
	App.super.event(self, e)
	if e[0].type == sdl.SDL_EVENT_KEY_DOWN then
		if not ig.igGetIO()[0].WantCaptureKeyboard then
			if e[0].key.key == sdl.SDLK_LEFT then
				vars.earthquakeIndex -= 1
				self:updateEarthquakeIndex()
			elseif e[0].key.key == sdl.SDLK_RIGHT then
				vars.earthquakeIndex += 1
				self:updateEarthquakeIndex()
			end
		end
	end
end

local inputText=|l,t,k|
	--ig.luatableInputFloat(l, t, k)
	--ig.luatableInputFloatAsText(l, t, k)
	ig.luatableInputFloatAsText(l, t, k, ig.ImGuiInputTextFlags_EnterReturnsTrue)

App.updateGUI = |:| do
	local eq = earthquakes[vars.earthquakeIndex]
	ig.igSetNextWindowBgAlpha(.3)
	ig.igPushStyleColor_U32(ig.ImGuiCol_MenuBarBg, 0)
	if ig.igBeginMainMenuBar() then
		if ig.igBeginMenu'options:' then
			ig.luatableCheckbox('ortho', self.view, 'ortho')
			if ig.igButton'reset view' then
				self.view.ortho = true
				self.view.orthoSize = self.viewOrthoSize
				self.view.angle:set(0,0,0,1)
				self.view.orbit:set(0,0,0)
				self.view.pos:set(0, 0, self.viewDist)
			end
			ig.luatableCheckbox('draw earth', vars, 'drawEarth')
			ig.luatableCheckbox('draw earthquakes', vars, 'drawEarthquakes')
			inputText('pointSize', vars, 'pointSize')

			ig.luatableCheckbox('draw great arcs', vars, 'drawGreatArcs')
			ig.luatableSliderFloat('great arc alpha', vars, 'greatArcAlpha', 0, 1)
			ig.luatableSliderFloat('lineWidth', vars, 'lineWidth', 0, 20)
			inputText('angleFade', vars, 'angleFade')

			ig.igText'force calcs:'
			ig.igSameLine()
			if ig.luatableTooltipCheckbox('calcVertTides', vars, 'calcVertTides') then
				self:refreshForceBuffer()
			end
			ig.igSameLine()
			if ig.luatableTooltipCheckbox('calcHorzTides', vars, 'calcHorzTides') then
				self:refreshForceBuffer()
			end
			ig.igSameLine()
			if ig.luatableTooltipCheckbox('calcVertGrav', vars, 'calcVertGrav') then
				self:refreshForceBuffer()
			end
			ig.igSameLine()
			if ig.luatableTooltipCheckbox('calcHorzGrav', vars, 'calcHorzGrav') then
				self:refreshForceBuffer()
			end

			ig.igText('force min='..self.forceMin..' max='..self.forceMax)
			ig.luatableSliderFloat('forceTexAlpha', vars, 'forceTexAlpha', 0, 1)


			ig.igText'Calc Planets: '
			for _,planetClass in ipairs(calcPlanetClasses) do
				ig.igSameLine()
				if ig.luatableTooltipCheckbox('calc '..planetClass.name, vars.calcPlanets, planetClass.name) then
					self:refreshForceBuffer()
				end
			end

			ig.igText'Show Planets: '
			for _,planetClass in ipairs(drawPlanetClasses) do
				ig.igSameLine()
				ig.luatableTooltipCheckbox('draw '..planetClass.name, vars.drawPlanets, planetClass.name)
			end
			ig.igText'Show Planet Angles: '
			for _,angle in ipairs(drawPlanetAngles) do
				ig.igSameLine()
				ig.luatableTooltipCheckbox('at angle '..angle, vars.drawPlanetAngles, angle)
			end
			inputText('julianBaseAngle', vars, 'julianBaseAngle')

			if ig.luatableCheckbox('showOnlySelectedEarthquakeArcs', vars, 'showOnlySelectedEarthquakeArcs') then
				self:refreshRelevantCircles()
			end

			--[=[ TODO
			ig.luatableCheckbox('drawAxisTorques', vars, 'drawAxisTorques')
			ig.luatableSliderFloat('axisTorquePointSize', vars, 'axisTorquePointSize', 0, 10)
			--]=]

			local changed
			local oldEarthquakeIndex = vars.earthquakeIndex
			changed = ig.luatableSliderFloat('earthquakeIndex s', vars, 'earthquakeIndex', 1, #earthquakes)
			changed = ig.luatableInputInt('earthquakeIndex t', vars, 'earthquakeIndex', 1, #earthquakes) or changed
			if changed then
				vars.earthquakeIndex ??= oldEarthquakeIndex	-- if we got bad input then don't crash
				self:updateEarthquakeIndex()
			end

			ig.igText('earthquake time = '..eq.time)
			ig.igText('earthquake magn = '..eq.mag)	-- TODO just a side panel or pop up that shows all the earthquake stats
			ig.igText('earthquake depth = '..eq.depth)	-- TODO incorporate this into the display somehow ...
			ig.igText('earthquake julian day = '..selQuakeJulianDate)
			ig.igText('earthquake place = '..eq.place)
			ig.igText('window start time = '..earthquakes[earthquakeWindowStartIndex].time)
			ig.igText('window end time = '..earthquakes[earthquakeWindowEndIndex].time)
			ig.igText('window start index = '..earthquakeWindowStartIndex)
			ig.igText('window end index = '..earthquakeWindowEndIndex)
			ig.igText('earthquakes in window = '..(earthquakeWindowEndIndex - earthquakeWindowStartIndex + 1))
			ig.igText('flares in window = '..(flareWindowEndIndex - flareWindowStartIndex + 1))

			ig.luatableSliderFloat('lat0', vars, 'lat0', -180, 180)
			ig.luatableSliderFloat('lon0', vars, 'lon0', -180, 180)
			ig.luatableSliderFloat('roll0', vars, 'roll0', -180, 180)

			ig.igEndMenu()
		end
		if ig.igBeginMenu'circles:' then

			if inputText('greatArcAngleMin', calcCircles, 'greatArcAngleMin') then
				self:recalcAllCircles()
			end
			if inputText('greatArcAngleMax', calcCircles, 'greatArcAngleMax') then
				self:recalcAllCircles()
			end
			if inputText('quakeAlignWithPreviousGeodesicAngleThreshold', calcCircles, 'quakeAlignWithPreviousGeodesicAngleThreshold') then
				self:recalcAllCircles()
			end
			if inputText('filterDuplicateTouchingArcsAngleThreshold', calcCircles, 'filterDuplicateTouchingArcsAngleThreshold') then
				self:recalcAllCircles()
			end
			if inputText('filterDuplicatePointsAngleThreshold', calcCircles, 'filterDuplicatePointsAngleThreshold') then
				self:recalcAllCircles()
			end
			if inputText('timeWindowInDays', calcCircles, 'timeWindowInDays') then
				recalculateOldestEarthquakeIndex()
				self:recalcAllCircles()
			end

			ig.igEndMenu()
		end
		if ig.igBeginMenu'chart:' then

			ig.luatableCheckbox('normalize weights', vars, 'normalizeWeights')
			local changed
			for _,field in ipairs(weightFields) do
				if ig.luatableSliderFloat(field, vars, field, 0, 1) then
					changed = field
				end
			end
			if vars.normalizeWeights and changed then
				local restFrac = 1 - vars[changed]
				local totalRest = 0
				for _,field in ipairs(weightFields) do
					if field ~= changed then
						totalRest = totalRest + vars[field]
					end
				end
				for _,field in ipairs(weightFields) do
					if field ~= changed then
						if totalRest == 0 then
							vars[field] = 0
						else
							vars[field] = restFrac * vars[field] / totalRest
						end
					end
				end
			end

			ig.igEndMenu()
		end
		if ig.igBeginMenu('touching '..#eq.touchingCircles) then
			for i,t in ipairs(eq.touchingCircles) do
				ig.igPushID_Int(i)
				local c = allCircles[t.circle]
				local i1, i2 = table.unpack(c.indexes)
				local eq1 = earthquakes[i1]
				local eq2 = earthquakes[i2]
				ig.igText(i..':')
				ig.igSameLine()
				-- TODO tooltipButton text is always nothing so
				local click = ig.igButton('#'..i1)
				ig.hoverTooltip(eq1.place)
				if click then
					vars.earthquakeIndex = i1
					self:updateEarthquakeIndex()
				end
				ig.igSameLine()
				ig.igText'->'
				ig.igSameLine()
				local click = ig.igButton('#'..i2)
				ig.hoverTooltip(eq2.place)
				if click then
					vars.earthquakeIndex = i2
					self:updateEarthquakeIndex()
				end
				ig.igPopID()
			end

			ig.igEndMenu()
		end
		ig.igEndMainMenuBar()
	end
	ig.igPopStyleColor(1)
end

return App():run()
