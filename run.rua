#!/usr/bin/env rua
local template = require 'template'
local gl = require 'gl'
local GLSceneObject = require 'gl.sceneobject'
local GLArrayBuffer = require 'gl.arraybuffer'
local GLGeometry = require 'gl.geometry'
local GLTex2D = require 'gl.tex2d'
local ig = require 'imgui'

-- [=======[ TODO cache calcs somehow
local allCharts = require 'geographic-charts'
local chartNames = table{	-- which charts we want to allow ...
	'Equirectangular',
	'Azimuthal equidistant',
	'Mollweide',
	'WGS84',
}
local charts = table()
for i,name in ipairs(chartNames) do
	local chart = allCharts![name]
	charts[i] = chart
	charts[name] = chart
end
for _,name in ipairs(chartNames) do
	charts[name]?:build()
end
local chartCNames = charts:mapi([chart] chart:getCName())
local chartCode = require 'geographic-charts.code'(charts)
--]=======] 

-- [=======[ download data
local datafn = path'latest.csv'
local datastr
if not datafn:exists() then
	print'downlading...'
	local https = require 'ssl.https'
	datastr = assert(https.request'https://earthquake.usgs.gov/fdsnws/event/1/query.csv?starttime=2025-05-23%2000:00:00&endtime=2025-05-24%2023:59:59&minmagnitude=2.5&orderby=time')
	assert(datafn:write(datastr))
else
	datastr = assert(datafn:read())
end
local eqdata = assert(require 'csv'.string(datastr))
eqdata:setColumnNames(eqdata.rows:remove(1))
--]=======] 

local App = require 'imgui.appwithorbit'()
App.initGL = [:] do
	App.super.initGL(self)

	-- [=====[ BEGIN CLIP FROM GEOGRAPHIC-CHARTS
	local vertexes = table()
	local idivs = 100
	local jdivs = 100
	for i=0,idivs do
		local u = i/idivs
		--local phi = math.rad((u * 2 - 1) * 90)
		for j=0,jdivs do
			local v = j/jdivs
			--local lambda = math.rad((v * 2 - 1) * 180)
			vertexes:insert(v)	-- lon, lat = u, v in texcoord space
			vertexes:insert(u)
		end
	end
	self.vertexBuf = GLArrayBuffer{
		data = vertexes,
		dim = 2,
	}:unbind()

	local geometries = table()
	for ibase=0,idivs-1 do
		local indexes = table()
		for j=0,jdivs do
			for iofs=1,0,-1 do
				local i = ibase + iofs
				indexes:insert(j + (jdivs + 1) * i)
			end
		end
		geometries:insert(GLGeometry{
			mode = gl.GL_TRIANGLE_STRIP,
			indexes = {
				data = indexes,
			},
			vertexes = self.vertexBuf,
		})
	end

	self.globeObj = GLSceneObject{
		program = {
			version = 'latest',
			precision = 'best',
			vertexCode = template([[
<?=chartCode?>

layout(location=0) in vec2 vertex;
out vec2 texcoordv;

uniform mat4 mvProjMat;

<? for _,name in ipairs(chartCNames) do
?>uniform float weight_<?=name?>;
<? end
?>
uniform bool chartIs3D;

void main() {
	texcoordv = vertex;	//(lat, lon) in [0, 1]

	vec3 coords = vec3(
		(vertex.y - .5) * 180.,	// lat in deg, [-90, 90]
		(vertex.x - .5) * 360.,	// lon in deg, [-180, 180]
		0.);						// height in meters

	vec3 pos = 0.
<? for _,name in ipairs(chartCNames) do
?>		+ weight_<?=name?> * chart_<?=name?>(coords)
<? end
?>	;

	//from meters to normalized coordinates
	pos /= WGS84_a;

	if (chartIs3D) {
		pos = vec3(pos.z, pos.x, pos.y);
	}

	// lets see the grid over it
	pos *= .99;

	gl_Position = mvProjMat * vec4(pos, 1.);
}

]], 		{
				chartCode = chartCode,
				chartCNames = chartCNames,
			}),
			fragmentCode = template([[
in vec2 texcoordv;
out vec4 fragColor;

uniform sampler2D earthTex;
uniform float alpha;

void main() {
	fragColor = texture(earthTex, vec2(texcoordv.x, 1. - texcoordv.y));
	fragColor.a = alpha;
}
]],			{
				chartCode = chartCode,
			}),
			uniforms = {
				earthTex = 0,
				alpha = .5,
			},
		},
		vertexes = self.vertexBuf,
		geometries = geometries,
		texs = {
			GLTex2D{
				filename = 'earth-color.png',
				minFilter = gl.GL_LINEAR_MIPMAP_LINEAR,
				magFilter = gl.GL_LINEAR,
				generateMipmap = true,
			}:unbind(),
		},
		uniforms = {
			weight_Equirectangular = 0,
			weight_Azimuthal_equidistant = 0,
			weight_Mollweide = 0,
			weight_WGS84 = 1,
		},
	}
	--]=====] END CLIP FROM GEOGRAPHIC-CHARTS


	-- [=====[ BEGIN EARTHQUAKES
	self.eqObj = GLSceneObject{
		program = {
			version = 'latest',
			precision = 'best',
			vertexCode = template([[
<?=chartCode?>

layout(location=0) in vec2 vertex;
layout(location=1) in vec2 texcoord;
out vec2 texcoordv;

uniform mat4 mvProjMat;

<? for _,name in ipairs(chartCNames) do
?>uniform float weight_<?=name?>;
<? end
?>
uniform bool chartIs3D;

void main() {
	texcoordv = texcoord;

	vec3 coords = vec3(
		(vertex.y - .5) * 180.,	// lat in deg, [-90, 90]
		(vertex.x - .5) * 360.,	// lon in deg, [-180, 180]
		1e+3);					// height in meters

	vec3 pos = 0.
<? for _,name in ipairs(chartCNames) do
?>		+ weight_<?=name?> * chart_<?=name?>(coords)
<? end
?>	;
	pos /= WGS84_a;	//from meters to normalized coordinates
	if (chartIs3D) {
		pos = vec3(pos.z, pos.x, pos.y);
	}
	gl_Position = mvProjMat * vec4(pos, 1.);
}

]], 		{
				chartCode = chartCode,
				chartCNames = chartCNames,
			}),
			fragmentCode = [[
in vec2 texcoordv;
out vec4 fragColor;
void main() {
	if (dot(texcoordv,texcoordv) > 1.) discard;
	fragColor = vec4(1., .5, 0., 1.);
}
]],
		},
		geometry = {
			mode = gl.GL_TRIANGLES,
		},
		vertexes = {
			dim = 2,
			useVec = true,
		},
		attrs = {
			texcoord = {
				buffer = {
					dim = 2,
					useVec = true,
				},
			},
		},
	}
	-- TODO .useVec with .data ... atm it just overwrites .data
	
	local quadVtxs = {
		{0, 0},
		{1, 0},
		{0, 1},
		{0, 1},
		{1, 0},
		{1, 1}
	}
	local pointSize = .01
	local vertexGPU = self.eqObj.attrs.vertex.buffer
	local vertexCPU = vertexGPU:beginUpdate()
	local texcoordGPU = self.eqObj.attrs.texcoord.buffer
	local texcoordCPU = texcoordGPU:beginUpdate()
	for i,row in ipairs(eqdata.rows) do
		-- latitude: S = negative, N = positive
		-- longitude: W = negative, E = positive
		print(i, row.latitude, row.longitude)
		for _,v in ipairs(quadVtxs) do
			vertexCPU:emplace_back()[0]:set(
				(row.longitude + 180) / 360 + .5 * pointSize * (v[1] * 2 - 1),
				(row.latitude + 90) / 180 + pointSize * (v[2] * 2 - 1)
			)
			texcoordCPU:emplace_back()[0]:set(v[1] * 2 - 1, v[2] * 2 - 1)
		end
	end
	vertexGPU:endUpdate()
	texcoordGPU:endUpdate()
	--]=====] END EARTHQUAKES

	gl.glEnable(gl.GL_DEPTH_TEST)
end

local weightFields = chartCNames:mapi([name] 'weight_'..name)
local vars = table(
	weightFields:mapi([name] (name == 'weight_WGS84' and 1 or 0, name)),
	{
		normalizeWeights = true,
		drawEarth = true,
		drawEarthquakes = true,
	}
):setmetatable(nil)

App.update = [:] do
	gl.glClear(bit.bor(gl.GL_COLOR_BUFFER_BIT, gl.GL_DEPTH_BUFFER_BIT))

	if vars.drawEarth then
		-- [=====[ BEGIN CLIP FROM GEOGRAPHIC-CHARTS
		local sceneObj = self.globeObj
		for _,name in ipairs(weightFields) do
			sceneObj.uniforms[name] = vars[name]
		end
		sceneObj.uniforms.chartIs3D = false	-- this is just whether to swap x y and z around , z = along view vs z = north pole
		sceneObj.uniforms.mvProjMat = self.view.mvProjMat.ptr
		sceneObj:draw()
		--]=====] END CLIP FROM GEOGRAPHIC-CHARTS
	end

	if vars.drawEarthquakes then
		-- [=====[ BEGIN BEARTHQUAKES
		local sceneObj = self.eqObj
		for _,name in ipairs(weightFields) do
			sceneObj.uniforms[name] = vars[name]
		end
		sceneObj.uniforms.chartIs3D = false	-- this is just whether to swap x y and z around , z = along view vs z = north pole	
		sceneObj.uniforms.mvProjMat = self.view.mvProjMat.ptr
		sceneObj:draw()
		--]=====] END EARTHQUAKES
	end

	App.super.update(self)
end

App.updateGUI = [:] do
	ig.igSetNextWindowBgAlpha(.3)
	ig.igPushStyleColor_U32(ig.ImGuiCol_MenuBarBg, 0)
	if ig.igBeginMainMenuBar() then
		if ig.igBeginMenu'options:' then
			ig.luatableCheckbox('draw earth', vars, 'drawEarth')
			ig.luatableCheckbox('draw earthquakes', vars, 'drawEarthquakes')

			ig.luatableCheckbox('normalize weights', vars, 'normalizeWeights')
			local changed
			for _,field in ipairs(weightFields) do
				if ig.luatableSliderFloat(field, vars, field, 0, 1) then
					changed = field
				end
			end
			if vars.normalizeWeights and changed then
				local restFrac = 1 - vars[changed]
				local totalRest = 0
				for _,field in ipairs(weightFields) do
					if field ~= changed then
						totalRest = totalRest + vars[field]
					end
				end
				for _,field in ipairs(weightFields) do
					if field ~= changed then
						if totalRest == 0 then
							vars[field] = 0
						else
							vars[field] = restFrac * vars[field] / totalRest
						end
					end
				end
			end
			ig.igEndMenu()
		end
		ig.igEndMainMenuBar()
	end
	ig.igPopStyleColor(1)
end

return App():run()
