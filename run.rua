#!/usr/bin/env rua
local template = require 'template'
local sdl = require 'sdl'
local gl = require 'gl'
local GLSceneObject = require 'gl.sceneobject'
local GLArrayBuffer = require 'gl.arraybuffer'
local GLProgram = require 'gl.program'
local GLGeometry = require 'gl.geometry'
local GLTex2D = require 'gl.tex2d'
local ig = require 'imgui'
local vec2d = require 'vec-ffi.vec2d'
local vec3d = require 'vec-ffi.vec3d'

-- [=======[ TODO cache calcs somehow
local allCharts = require 'geographic-charts'
local chartNames = table{	-- which charts we want to allow ...
	'Equirectangular',
	'Azimuthal equidistant',
	'Mollweide',
	'WGS84',
}
local charts = table()
for i,name in ipairs(chartNames) do
	local chart = allCharts![name]
	charts[i] = chart
	charts[name] = chart
end
for _,name in ipairs(chartNames) do
	charts[name]?:build()
end

local chartCNames = charts:mapi(|chart| chart:getCName())
local chartCode = require 'geographic-charts.code'(charts)
--]=======]

local calcs = require 'calcs'
local earthquakes = calcs.earthquakes
local allCircles = calcs.circles
local considerationTimeWindowSize = calcs.considerationTimeWindowSize
local getDayCache = calcs.getDayCache
local checkTime = calcs.checkTime
local checkDuration = 60*5	-- check every 5 mins

-- should this be based on what quakes are within 60' and caused me to flag the geodesic?
-- or should this be on what quakes are subsequently within 1' or 5' or so of that geodesic after-the-fact?
-- doing the former first ...
local circlesMadeByQuakes = {}
for ci,c in ipairs(allCircles) do
	for _,i in ipairs(c.indexes) do
		circlesMadeByQuakes[i] ??= table()
		circlesMadeByQuakes[i]:insert(ci)
	end
end


local weightFields = chartCNames:mapi(|name| 'weight_'..name)
local vars = table(
	weightFields:mapi(|name| (name == 'weight_Equirectangular' and 1 or 0, name)),
	{
		showOnlySelectedEarthquakeArcs = true ,	-- true = show only selected earthquake circle, false = show all
		normalizeWeights = true,
		drawEarth = true,
		drawEarthquakes = true,
		drawGreatArcs = true,
		greatArcAlpha = .1,
		lineWidth = 1,
		--[=[ TODO
		drawAxisTorques = true,
		axisTorquePointSize = 3,
		--]=]
		lat0 = 0,	-- degrees
		lon0 = 180,	-- degrees
		earthquakeIndex = #earthquakes,
	}
):setmetatable(nil)

local oldestEarthquakeIndex
local recalculateOldestEarthquakeIndex = ||do
	oldestEarthquakeIndex = vars.earthquakeIndex
	for i=vars.earthquakeIndex,1,-1 do
		if earthquakes[vars.earthquakeIndex].ostime - earthquakes[i].ostime > considerationTimeWindowSize then break end
		oldestEarthquakeIndex = i
	end
end


local App = require 'imgui.appwithorbit'()
App.title = 'Earthquake Geodesics'
App.viewDist = 2
App.initGL = |:| do
	App.super.initGL(self)
	self.view.ortho = true
	self.view.orthoSize = 3
	-- [=====[ BEGIN CLIP FROM GEOGRAPHIC-CHARTS
	local vertexes = table()
	local idivs = 100
	local jdivs = 100
	for i=0,idivs do
		local u = i/idivs
		--local phi = math.rad((u * 2 - 1) * 90)
		for j=0,jdivs do
			local v = j/jdivs
			--local lambda = math.rad((v * 2 - 1) * 180)
			vertexes:insert(v)	-- lon, lat = u, v in texcoord space
			vertexes:insert(u)
		end
	end
	self.vertexBuf = GLArrayBuffer{
		data = vertexes,
		dim = 2,
	}:unbind()

	local geometries = table()
	for jbase=0,jdivs-1 do
		local indexes = table()
		for i=0,idivs do
			for jofs=1,0,-1 do
				local j = jbase + jofs
				indexes:insert(j + (jdivs + 1) * i)
			end
		end
		geometries:insert(GLGeometry{
			mode = gl.GL_TRIANGLE_STRIP,
			indexes = {
				data = indexes,
			},
			vertexes = self.vertexBuf,
		})
	end

	self.globeObj = GLSceneObject{
		program = {
			version = 'latest',
			precision = 'best',
			vertexCode = template([[
layout(location=0) in vec2 vertex;
out vec2 texcoordv;
out vec3 posv;

uniform mat4 mvProjMat;
uniform bool chartIs3D;
uniform vec2 latlon0;

<?=chartCode?>

<? for _,name in ipairs(chartCNames) do
?>uniform float weight_<?=name?>;
<? end
?>

void main() {
	texcoordv = vertex;	//(lon, lat) in [0, 1]

	vec3 coords = vec3(
		mod(vertex.y * 180. - latlon0.y, 180.) - 90.,	// lat in deg, [-90, 90]
		mod(vertex.x * 360. - latlon0.x, 360.) - 180.,	// lon in deg, [-180, 180]
		0.);						// height in meters

	vec3 pos = 0.
<? for _,name in ipairs(chartCNames) do
?>		+ weight_<?=name?> * chart_<?=name?>(coords)
<? end
?>	;

	//from meters to normalized coordinates
	pos /= WGS84_a;

	if (chartIs3D) {
		pos = vec3(pos.z, pos.x, pos.y);
	}
	posv = pos;

	// lets see the grid over it
	pos *= .99;

	gl_Position = mvProjMat * vec4(pos, 1.);
}

]], 		{
				chartCode = chartCode,
				chartCNames = chartCNames,
			}),

-- [=[
		geometryCode = [[
layout (triangles) in;
layout (triangle_strip, max_vertices = 3) out;

in vec2 texcoordv[];
out vec2 texcoordg;

in vec3 posv[];

void main() {
	vec3 dlen = vec3(
		length(posv[1] - posv[0]),
		length(posv[2] - posv[1]),
		length(posv[0] - posv[2]));
	if (dlen.x > .25 || dlen.y > .25 || dlen.z > .25)
	{
		return;
	}

	gl_Position = gl_in[0].gl_Position;
	texcoordg = texcoordv[0];
	EmitVertex();

	gl_Position = gl_in[1].gl_Position;
	texcoordg = texcoordv[1];
	EmitVertex();

	gl_Position = gl_in[2].gl_Position;
	texcoordg = texcoordv[2];
	EmitVertex();

	EndPrimitive();
}
]],
--]=]


			fragmentCode = template([[
in vec2 texcoordg;
out vec4 fragColor;

uniform sampler2D earthTex;
uniform float alpha;

void main() {
	fragColor = texture(earthTex, vec2(texcoordg.x, 1. - texcoordg.y));
	fragColor.a = alpha;
}
]],			{
				chartCode = chartCode,
			}),
			uniforms = {
				earthTex = 0,
				alpha = .5,
			},
		},
		vertexes = self.vertexBuf,
		geometries = geometries,
		texs = {
			GLTex2D{
				filename = 'earth-color.png',
				minFilter = gl.GL_LINEAR_MIPMAP_LINEAR,
				magFilter = gl.GL_LINEAR,
				generateMipmap = true,
			}:unbind(),
		},
		uniforms = {
			weight_Equirectangular = 1,
			weight_Azimuthal_equidistant = 0,
			weight_Mollweide = 0,
			weight_WGS84 = 0,
		},
	}
	--]=====] END CLIP FROM GEOGRAPHIC-CHARTS


	-- [=====[ BEGIN EARTHQUAKES
	self.earthquakeLatLonPointObj = GLSceneObject{
		program = {
			version = 'latest',
			precision = 'best',
			vertexCode = template([[
layout(location=0) in vec2 vertex;
layout(location=1) in vec2 texcoord;
out vec2 texcoordv;
flat out float hilite;

uniform mat4 mvProjMat;
uniform bool chartIs3D;
uniform vec2 latlon0;
uniform uint hiliteIndex;

<?=chartCode?>

<? for _,name in ipairs(chartCNames) do
?>uniform float weight_<?=name?>;
<? end
?>

void main() {
	texcoordv = texcoord;

	if (gl_VertexID >= hiliteIndex * 6 && gl_VertexID < (hiliteIndex + 1) * 6) {
		hilite = 1.;
	} else {
		hilite = 0.;
	}

	vec3 coords = vec3(
		mod(vertex.y * 180. - latlon0.y, 180.) - 90.,	// lat in deg, [-90, 90]
		mod(vertex.x * 360. - latlon0.x, 360.) - 180.,	// lon in deg, [-180, 180]
		1e+3);					// height in meters

	vec3 pos = 0.
<? for _,name in ipairs(chartCNames) do
?>		+ weight_<?=name?> * chart_<?=name?>(coords)
<? end
?>	;
	pos /= WGS84_a;	//from meters to normalized coordinates
	if (chartIs3D) {
		pos = vec3(pos.z, pos.x, pos.y);
	}
	gl_Position = mvProjMat * vec4(pos, 1.);
}

]], 		{
				chartCode = chartCode,
				chartCNames = chartCNames,
			}),
			fragmentCode = [[
in vec2 texcoordv;
flat in float hilite;
out vec4 fragColor;
void main() {
	if (dot(texcoordv,texcoordv) > 1.) discard;
	fragColor = vec4(1., .5 * (1. - hilite), 0., 1.);
}
]],
		},
		geometry = {
			mode = gl.GL_TRIANGLES,
		},
		vertexes = {
			dim = 2,
			useVec = true,
		},
		attrs = {
			texcoord = {
				buffer = {
					dim = 2,
					useVec = true,
				},
			},
		},
	}
	-- TODO .useVec with .data ... atm it just overwrites .data

	local quadVtxs = {
		{0, 0},
		{1, 0},
		{0, 1},
		{0, 1},
		{1, 0},
		{1, 1}
	}
	local pointSize = .01
	local vertexGPU = self.earthquakeLatLonPointObj.attrs.vertex.buffer
	local texcoordGPU = self.earthquakeLatLonPointObj.attrs.texcoord.buffer
	local vertexCPU = vertexGPU:beginUpdate()
	local texcoordCPU = texcoordGPU:beginUpdate()
	for i,eq in ipairs(earthquakes) do
		-- latitude: S = negative, N = positive
		-- longitude: W = negative, E = positive
--print(i, eq.latitude, eq.longitude)
		for _,v in ipairs(quadVtxs) do
			vertexCPU:emplace_back()[0]:set(
				(eq.longitude + 180) / 360 + .5 * pointSize * (v[1] * 2 - 1),
				(eq.latitude + 90) / 180 + pointSize * (v[2] * 2 - 1)
			)
			texcoordCPU:emplace_back()[0]:set(v[1] * 2 - 1, v[2] * 2 - 1)
		end
	end
	assert.eq(#vertexCPU, 6 * #earthquakes)
	vertexGPU:endUpdate()
	texcoordGPU:endUpdate()
	--]=====] END EARTHQUAKES

	-- [=====[ BEGIN COPY FROM EARTH TRANSPORT NETWORK
	self.circlesShader= GLProgram{
		version = 'latest',
		precision = 'best',
		vertexCode = template([[
layout(location=0) in vec2 vertex;
layout(location=1) in vec4 color;
out vec3 posv;
out vec4 colorv;
uniform mat4 mvProjMat;
uniform bool chartIs3D;
uniform vec2 latlon0;

//////// BEGIN CODE MATCHING CHART CODE ABOVE
<?=chartCode?>

<? for _,name in ipairs(chartCNames) do
?>uniform float weight_<?=name?>;
<? end
?>

//////// END CODE MATCHING CHART CODE ABOVE

void main() {
	colorv = color;

	//////// BEGIN CODE MATCHING CHART CODE ABOVE
	vec3 coords = vec3(
		mod(vertex.y * 180. - latlon0.y, 180.) - 90.,	// lat in deg, [-90, 90]
		mod(vertex.x * 360. - latlon0.x, 360.) - 180.,	// lon in deg, [-180, 180]
		2e+3);						// height in meters

	vec3 pos = 0.
<? for _,name in ipairs(chartCNames) do
?>		+ weight_<?=name?> * chart_<?=name?>(coords)
<? end
?>	;

	//from meters to normalized coordinates
	pos /= WGS84_a;

	if (chartIs3D) {
		pos = vec3(pos.z, pos.x, pos.y);
	}
	posv = pos;
	gl_Position = mvProjMat * vec4(pos, 1.);
	//////// END CODE MATCHING CHART CODE ABOVE
}
]],		{
			chartCode = chartCode,
			chartCNames = chartCNames,
		}),

-- [=[ but really just don't use this, just cull the vertexes in the array buffer
-- then again, this does let me split up line loops.
		-- lets see if we can hide lines that loop from lon=-180 to lon=+180 and go across the equirectangular/mollweide/most 2D projections
		-- TODO I could use this for the circle tesselation to begin with.  just pass the angle + axis.
		-- TODO TODO once I do that, I could also just do the cartesian-to-wgs84 in the fragment, then apply the charts in the fragment.
		geometryCode = [[
layout (lines) in;
layout (line_strip, max_vertices = 2) out;

in vec4 colorv[];
in vec3 posv[];
out vec4 colorg;

void main() {
	float dlen = length(posv[1] - posv[0]);
	if (dlen > .25) {
		return;
	}

	gl_Position = gl_in[0].gl_Position;
	colorg = colorv[0];
	EmitVertex();

	gl_Position = gl_in[1].gl_Position;
	colorg = colorv[1];
	EmitVertex();

	EndPrimitive();
}
]],
--]=]
		fragmentCode = [[
in vec4 colorg;		// using geometry shader
//in vec4 colorv;	// not using geometry shader
out vec4 fragColor;
uniform float alpha;
void main() {
	fragColor = colorg;
	//fragColor = colorv;
	fragColor.a *= alpha;
}
]],
	}:useNone()
	--]=====] END COPY FROM EARTH TRANSPORT NETWORK



	gl.glEnable(gl.GL_DEPTH_TEST)
	gl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE) --gl.GL_ONE_MINUS_SRC_ALPHA)


	local rotateX = |v, theta| do
		local c, s = math.cos(theta), math.sin(theta)
		return vec3d(
			v.x,
			v.y * c - v.z * s,
			v.y * s + v.z * c)
	end
	local rotateY = |v, theta| do
		local c, s = math.cos(theta), math.sin(theta)
		return vec3d(
			v.x * c + v.z * s,
			v.y,
			v.x * s - v.z * c)
	end
	local rotateZ = |v, theta| do
		local c, s = math.cos(theta), math.sin(theta)
		return vec3d(
			v.x * c - v.y * s,
			v.x * s + v.y * c,
			v.z)
	end
	local latLonToXYZ = |eq| do
		local v = vec3d(0, 0, 1)   -- z+ is default
		v = rotateX(v, -math.rad(eq.latitude))
		v = rotateY(v, math.pi - math.rad(eq.longitude))
		return v
	end

	--[=[ build here
	-- show axii of circles
	self.pairCrossPointsObj = GLSceneObject{
		program = {
			version = 'latest',
			precision = 'best',
			vertexCode = template([[
layout(location=0) in vec2 vertex;
uniform mat4 mvProjMat;
uniform bool chartIs3D;
uniform vec2 latlon0;

//////// BEGIN CODE MATCHING CHART CODE ABOVE
<?=chartCode?>

<? for _,name in ipairs(chartCNames) do
?>uniform float weight_<?=name?>;
<? end
?>

//////// END CODE MATCHING CHART CODE ABOVE

void main() {
	//////// BEGIN CODE MATCHING CHART CODE ABOVE
	vec3 coords = vec3(
		mod(vertex.y * 180. - latlon0.y, 180.) - 90.,	// lat in deg, [-90, 90]
		mod(vertex.x * 360. - latlon0.x, 360.) - 180.,	// lon in deg, [-180, 180]
		2e+3);						// height in meters

	vec3 pos = 0.
<? for _,name in ipairs(chartCNames) do
?>		+ weight_<?=name?> * chart_<?=name?>(coords)
<? end
?>	;

	//from meters to normalized coordinates
	pos /= WGS84_a;

	if (chartIs3D) {
		pos = vec3(pos.z, pos.x, pos.y);
	}
	gl_Position = mvProjMat * vec4(pos, 1.);
	//////// END CODE MATCHING CHART CODE ABOVE

}
]],			{
				chartCode = chartCode,
				chartCNames = chartCNames,
			}),
			fragmentCode = [[
out vec4 fragColor;
void main() {
	fragColor = vec4(1., 1., 1., 1.);
}
]],
},
		geometry = {
			mode = gl.GL_POINTS,
		},
		vertexes = {
			dim = 3,
			useVec = true,
		},
	}

	local pairCrossPoints = self.pairCrossPointsObj.attrs.vertex.buffer.vec
	circles = table()
	for i1=1,#earthquakes-1 do
		local e1 = earthquakes[i1]
		for i2=i1+1,#earthquakes do
			local e2 = earthquakes[i2]
			local v1 = latLonToXYZ(e1)
			local v2 = latLonToXYZ(e2)
			local torque = v1:cross(v2)	-- TODO times pair of earthquake magnitudes or something?
			local axisLen = torque:length()
			local axis = torque * (1 / (math.max(axisLen, 1e-15)))
			local influence = axisLen * 10^e1.mag * 10^e2.mag
			-- hmm proper torque would be based on radius from earth ... so consider depth?

			-- hmmmmm
			-- if ponits are 180' or if they are next to each other then we want no infuence ...
			-- ... .maybe I souldn't nrmlize with the cross produt ...
			-- and then I should look at the point-cloud of the axis' ...
			for s=-1,1,2 do
				local x,y,z = (s * torque):unpack()
				local phi, lambda = cartesianToLatLonWGS84(z,x,y)	-- hmm ...
				pairCrossPoints:insert(((math.deg(lambda) + 180) / 360) % 1)
				pairCrossPoints:insert(((math.deg(phi) + 90) / 180) % 1)
			end

			local angle = math.acos(v1:dot(v2))
			--if math.rad(15) < angle and angle < math.rad(60) then		-- threshold angle for point pairs for inserting a great-arc
			if math.rad(10) < angle and angle < math.rad(90) then	-- if I weight by cross then that'll make the 0' and 180' angles diminish ... nah, there's still a lot of noise unless I turn down the alpha ... then it's hard to highlight any geodesics ...
				circles:insert{
					axis = axis,
					angle = math.pi * .5,
					color = vec3d(1, .3, .07) * influence,
					centerPos = (v1 + v2):normalize(),	-- midpoint between two earthquake lines
					centerAngle = .5 * angle,	-- half the angle between them
				}
			end
		end
	end
	self.pairCrossPointsObj:endUpdate()
	--]=]
	--[=[ or TODO all circles and just hide/show the ones associated with the current quake ...
	circles = allCircles
	--]=]

	recalculateOldestEarthquakeIndex()
	self:refreshCircles()
end

-- [=======[ BEGIN COPY FROM EARTH TRANSPORT NETWORK
local numCircleDivs = 100
local numGridLines = 1
App.refreshCircles = |:| do
	-- [=[ show all circles touching our currently selected
	if vars.showOnlySelectedEarthquakeArcs then
		circles = earthquakes[vars.earthquakeIndex]
			.touchingCircles:mapi(|t| allCircles[t.circle])
	--]=]
	-- [=[ show all circles touching any active earthquakes in the last timeframe
	else
		local circleIndexes = table()
		for i=oldestEarthquakeIndex,vars.earthquakeIndex do
			for _,ci in ipairs(circlesMadeByQuakes[i]) do
				circleIndexes[ci] = true
			end
		end
		circles = circleIndexes:keys():sort():mapi(|ci| allCircles[ci])
	end
	--]=]

	local vertexes = table()
	local colors = table()
	local geometries = table()
	for _,circle in ipairs(circles) do
		local indexStart = #vertexes / 2
		colors:append(circle.colors)
		vertexes:append(circle.vertexes)
		local indexEnd = #vertexes / 2

		geometries:insert{
			mode = gl.GL_LINE_LOOP,
			offset = indexStart,
			count = indexEnd - indexStart,
		}
		--[=[
		local circleAngle = circle.angle
		local a1 = circle.axis
		local a2 = basisFor(a1):normalize()
		local a3 = a1:cross(a2)
		-- re-ortho-normalize a3
		for j=1,numGridLines do
			local angleDeclinedFromCircleAxis = j/numGridLines*circleAngle
			local decl = math.cos(angleDeclinedFromCircleAxis)
			local phi_r = math.sin(angleDeclinedFromCircleAxis)

			local indexStart = #vertexes / 2
			for i=1,numCircleDivs do
				local th = (i-.5)/numCircleDivs*2*math.pi
				local v = a1 * decl + a2 * phi_r * math.cos(th) + a3 * phi_r * math.sin(th)
				local x, y, z = v:unpack()
				--local phi, lambda = cartesianToLatLonWGS84(x,y,z)
				local phi, lambda = cartesianToLatLonWGS84(z,x,y)	-- hmm ...
				vertexes:insert(((math.deg(lambda) + 180) / 360) % 1)
				vertexes:insert(((math.deg(phi) + 90) / 180) % 1)
				local cosAngle = v:dot(circle.centerPos)
				--local angle = math.acos(cosAngle)
				--local alpha = angle < circle.centerAngle and 1 or 0
				--local alpha = math.clamp(1 - angle / circle.centerAngle, 0, 1)^10
				local alpha = math.clamp(cosAngle / math.cos(circle.centerAngle), 0, 1)
				colors:insert(circle.color.x)
				colors:insert(circle.color.y)
				colors:insert(circle.color.z)
				colors:insert(alpha)
			end
			local indexEnd = #vertexes / 2

			geometries:insert{
				mode = gl.GL_LINE_LOOP,
				offset = indexStart,
				count = indexEnd - indexStart,
			}
		end
		--]=]
	end
--DEBUG:print('making circlesObj', #vertexes, #colors)
	self.circlesObj = GLSceneObject{
		program = self.circlesShader,
		vertexes = {
			data = vertexes,
			dim = 2,
		},
		attrs = {
			color = {
				buffer = {
					data = colors,
					dim = 4,
				},
			},
		},
		geometries = geometries,
	}
end
--]=======] END COPY FROM EARTH TRANSPORT NETWORK



App.update = |:| do
	gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT)

	if vars.drawEarth then
		-- [=====[ BEGIN CLIP FROM GEOGRAPHIC-CHARTS
		local sceneObj = self.globeObj
		for _,name in ipairs(weightFields) do
			sceneObj.uniforms[name] = vars[name]
		end
		sceneObj.uniforms.latlon0 = {vars.lon0, vars.lat0}
		sceneObj.uniforms.chartIs3D = false	-- this is just whether to swap x y and z around , z = along view vs z = north pole
		sceneObj.uniforms.mvProjMat = self.view.mvProjMat.ptr
		sceneObj:draw()
		--]=====] END CLIP FROM GEOGRAPHIC-CHARTS
	end

	if vars.drawEarthquakes then
		-- [=====[ BEGIN BEARTHQUAKES
		local sceneObj = self.earthquakeLatLonPointObj
		for _,name in ipairs(weightFields) do
			sceneObj.uniforms[name] = vars[name]
		end
		sceneObj.uniforms.latlon0 = {vars.lon0, vars.lat0}
		sceneObj.uniforms.chartIs3D = false	-- this is just whether to swap x y and z around , z = along view vs z = north pole
		sceneObj.uniforms.mvProjMat = self.view.mvProjMat.ptr
		sceneObj.uniforms.hiliteIndex = vars.earthquakeIndex-1

		-- 6 * becuse i'm drawing two tris per point into the vertex buffer (TODO billboard and instances maybe?)
		sceneObj.geometry.offset = 6 * (oldestEarthquakeIndex - 1)
		sceneObj.geometry.count = 6 * (vars.earthquakeIndex - oldestEarthquakeIndex + 1)

		sceneObj:draw()

		sceneObj.geometry.offset = nil
		sceneObj.geometry.count = nil
		--]=====] END EARTHQUAKES
	end

	if vars.drawGreatArcs then
		-- [=======[ BEGIN COPY FROM EARTH TRANSPORT NETWORK
		local sceneObj = self.circlesObj
		for _,name in ipairs(weightFields) do
			sceneObj.uniforms[name] = vars[name]
		end
		sceneObj.uniforms.latlon0 = {vars.lon0, vars.lat0}
		sceneObj.uniforms.chartIs3D = false	-- this is just whether to swap x y and z around , z = along view vs z = north pole
		sceneObj.uniforms.mvProjMat = self.view.mvProjMat.ptr
		sceneObj.uniforms.alpha = vars.greatArcAlpha
gl.glLineWidth(vars.lineWidth)
gl.glEnable(gl.GL_BLEND)
gl.glDepthMask(0)
		sceneObj:draw()
gl.glDepthMask(1)
gl.glDisable(gl.GL_BLEND)
gl.glLineWidth(1)
		--]=====] END COPY FROM EARTH TRANSPORT NETWORK
	end

	--[=[ TODO
	if vars.drawAxisTorques then
		local sceneObj = self.pairCrossPointsObj
		if #sceneObj.attrs.vertex.buffer.vec > 0 then
			for _,name in ipairs(weightFields) do
				sceneObj.uniforms[name] = vars[name]
			end
			sceneObj.uniforms.latlon0 = {vars.lon0, vars.lat0}
			sceneObj.uniforms.chartIs3D = false	-- this is just whether to swap x y and z around , z = along view vs z = north pole
			sceneObj.uniforms.mvProjMat = self.view.mvProjMat.ptr

			gl.glPointSize(vars.axisTorquePointSize)
			sceneObj:draw()
			gl.glPointSize(1)
		end
	end
	--]=]

	App.super.update(self)


	-- while we're here...
	-- ... re-download the latest day's earthquakes
	local t = os.time()
	if t > checkTime + checkDuration then
		checkTime = t
		local newTodaysEarthquakes, changed = getDayCache(t, true)
		if changed then
			print(os.date(), 'TODO upate me plz')
		end
	end
end

App.updateEarthquakeIndex = |:| do
	vars.earthquakeIndex = math.clamp(math.round(vars.earthquakeIndex), 1, #earthquakes)

	recalculateOldestEarthquakeIndex()
	self:refreshCircles()	-- TODO don't recalc all circles, just recalc indexes used
end

App.event = |:,e| do
	App.super.event(self, e)
	if e[0].type == sdl.SDL_EVENT_KEY_DOWN then
		if not ig.igGetIO()[0].WantCaptureKeyboard then
			if e[0].key.key == sdl.SDLK_LEFT then
				vars.earthquakeIndex -= 1
				self:updateEarthquakeIndex()
			elseif e[0].key.key == sdl.SDLK_RIGHT then
				vars.earthquakeIndex += 1
				self:updateEarthquakeIndex()
			end
		end
	end
end

App.updateGUI = |:| do
	ig.igSetNextWindowBgAlpha(.3)
	ig.igPushStyleColor_U32(ig.ImGuiCol_MenuBarBg, 0)
	if ig.igBeginMainMenuBar() then
		if ig.igBeginMenu'options:' then
			ig.luatableCheckbox('ortho', self.view, 'ortho')
			if ig.igButton'reset view' then
				self.view.ortho = true
				self.view.orthoSize = self.viewOrthoSize
				self.view.angle:set(0,0,0,1)
				self.view.orbit:set(0,0,0)
				self.view.pos:set(0, 0, self.viewDist)
			end
			ig.luatableCheckbox('draw earth', vars, 'drawEarth')
			ig.luatableCheckbox('draw earthquakes', vars, 'drawEarthquakes')

			ig.luatableCheckbox('draw great arcs', vars, 'drawGreatArcs')
			ig.luatableSliderFloat('great arc alpha', vars, 'greatArcAlpha', 0, 1)
			ig.luatableSliderFloat('lineWidth', vars, 'lineWidth', 0, 20)
			if ig.luatableCheckbox('showOnlySelectedEarthquakeArcs', vars, 'showOnlySelectedEarthquakeArcs') then
				self:refreshCircles()
			end

			--[=[ TODO
			ig.luatableCheckbox('drawAxisTorques', vars, 'drawAxisTorques')
			ig.luatableSliderFloat('axisTorquePointSize', vars, 'axisTorquePointSize', 0, 10)
			--]=]

			local changed
			changed = ig.luatableSliderFloat('earthquakeIndex s', vars, 'earthquakeIndex', 1, #earthquakes)
			changed = ig.luatableInputInt('earthquakeIndex t', vars, 'earthquakeIndex', 1, #earthquakes) or changed
			if changed then
				self:updateEarthquakeIndex()
			end
			ig.igText('earthquake time = '..earthquakes[vars.earthquakeIndex].time)
			ig.igText('earthquake place = '..earthquakes[vars.earthquakeIndex].place)
			ig.igText('oldestEarthquakeIndex = '..oldestEarthquakeIndex)
			ig.igText('oldest earthquake time = '..earthquakes[oldestEarthquakeIndex].time)

			ig.luatableSliderFloat('lat0', vars, 'lat0', -90, 90)
			ig.luatableSliderFloat('lon0', vars, 'lon0', -180, 180)
			ig.luatableCheckbox('normalize weights', vars, 'normalizeWeights')
			local changed
			for _,field in ipairs(weightFields) do
				if ig.luatableSliderFloat(field, vars, field, 0, 1) then
					changed = field
				end
			end
			if vars.normalizeWeights and changed then
				local restFrac = 1 - vars[changed]
				local totalRest = 0
				for _,field in ipairs(weightFields) do
					if field ~= changed then
						totalRest = totalRest + vars[field]
					end
				end
				for _,field in ipairs(weightFields) do
					if field ~= changed then
						if totalRest == 0 then
							vars[field] = 0
						else
							vars[field] = restFrac * vars[field] / totalRest
						end
					end
				end
			end
			ig.igEndMenu()
		end
		ig.igEndMainMenuBar()
	end
	ig.igPopStyleColor(1)
end

return App():run()
