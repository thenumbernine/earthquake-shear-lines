#!/usr/bin/env rua
local template = require 'template'
local sdl = require 'sdl'
local gl = require 'gl'
local GLSceneObject = require 'gl.sceneobject'
local GLArrayBuffer = require 'gl.arraybuffer'
local GLProgram = require 'gl.program'
local GLGeometry = require 'gl.geometry'
local GLTex2D = require 'gl.tex2d'
local ig = require 'imgui'
local vec2d = require 'vec-ffi.vec2d'
local vec3d = require 'vec-ffi.vec3d'

local dayInSec = 60 * 60 * 24

local chartCode = require 'charts'.chartCode
local chartCNames = require 'charts'.chartCNames

local calcs = require 'calcs'
local getDayCache = calcs.getDayCache
local checkTime = calcs.checkTime
local earthquakes = calcs.earthquakes
local checkDuration = 60*5	-- re-check every 5 mins

local calcCircles = require 'circles'


local weightFields = chartCNames:mapi(|name| 'weight_'..name)
local vars = table(
	weightFields:mapi(|name| (name == 'weight_Equirectangular' and 1 or 0, name)),
	{
		showOnlySelectedEarthquakeArcs = true ,	-- true = show only selected earthquake circle, false = show all
		normalizeWeights = true,
		drawEarth = true,
		drawEarthquakes = true,
		pointSize = .005,		-- but make it proportional to size in view maybe? like USGS does?
		drawGreatArcs = true,
		greatArcAlpha = .1,
		lineWidth = 1,
		angleFade = 1,
		--[=[ TODO
		drawAxisTorques = true,
		axisTorquePointSize = 3,
		--]=]
		lat0 = 0,	-- degrees
		lon0 = 0, -- 180,	-- degrees
		earthquakeIndex = #earthquakes,
	}
):setmetatable(nil)

local oldestEarthquakeIndex
local recalculateOldestEarthquakeIndex = ||do
	oldestEarthquakeIndex = vars.earthquakeIndex
	for i=vars.earthquakeIndex,1,-1 do
		if earthquakes[vars.earthquakeIndex].ostime - earthquakes[i].ostime > calcCircles.timeWindowInDays * dayInSec then break end
		oldestEarthquakeIndex = i
	end
end


local App = require 'imgui.appwithorbit'()
App.title = 'Earthquake Geodesics'
App.viewDist = 2

local allCircles, circlesMadeByQuakes
App.recalcAllCircles=|:|do
	allCircles = calcCircles.calcCircles(earthquakes)

	-- should this be based on what quakes are within 60' and caused me to flag the geodesic?
	-- or should this be on what quakes are subsequently within 1' or 5' or so of that geodesic after-the-fact?
	-- doing the former first ...
	circlesMadeByQuakes = {}
	for ci,c in ipairs(allCircles) do
		for _,i in ipairs(c.indexes) do
			circlesMadeByQuakes[i] ??= table()
			circlesMadeByQuakes[i]:insert(ci)
		end
	end

	self:refreshRelevantCircles()	-- TODO don't recalc all circles, just recalc indexes used
end

App.initGL = |:| do
	App.super.initGL(self)
	self.view.ortho = true
	self.view.orthoSize = 3
	-- [=====[ BEGIN CLIP FROM GEOGRAPHIC-CHARTS
	local vertexes = table()
	local idivs = 100
	local jdivs = 100
	for i=0,idivs do
		local u = i/idivs
		--local phi = math.rad((u * 2 - 1) * 90)
		for j=0,jdivs do
			local v = j/jdivs
			--local lambda = math.rad((v * 2 - 1) * 180)
			vertexes:insert(u)	-- lat, lon = u, v
			vertexes:insert(v) -- transposed from texcoord space in texcoord space
		end
	end
	self.vertexBuf = GLArrayBuffer{
		data = vertexes,
		dim = 2,
	}:unbind()

	local geometries = table()
	for jbase=0,jdivs-1 do
		local indexes = table()
		for i=0,idivs do
			for jofs=1,0,-1 do
				local j = jbase + jofs
				indexes:insert(j + (jdivs + 1) * i)
			end
		end
		geometries:insert(GLGeometry{
			mode = gl.GL_TRIANGLE_STRIP,
			indexes = {
				data = indexes,
			},
			vertexes = self.vertexBuf,
		})
	end

	self.globeObj = GLSceneObject{
		program = {
			version = 'latest',
			precision = 'best',
			vertexCode = template([[
layout(location=0) in vec2 vertex;
out vec2 texcoordv;
out vec3 posv;

uniform mat4 mvProjMat;
uniform bool chartIs3D;
uniform vec2 latlon0;

<?=chartCode?>

<? for _,name in ipairs(chartCNames) do
?>uniform float weight_<?=name?>;
<? end
?>

void main() {
	texcoordv = vertex.yx;	//(lat, lon) in [0, 1]

	vec3 coords = vec3(
		mod(vertex.x * 180. - latlon0.x, 180.) - 90.,	// lat in deg, [-90, 90]
		mod(vertex.y * 360. - latlon0.y, 360.) - 180.,	// lon in deg, [-180, 180]
		0.);						// height in meters

	vec3 pos = 0.
<? for _,name in ipairs(chartCNames) do
?>		+ weight_<?=name?> * chart_<?=name?>(coords)
<? end
?>	;

	//from meters to normalized coordinates
	pos /= WGS84_a;

	if (chartIs3D) {
		pos = vec3(pos.z, pos.x, pos.y);
	}
	posv = pos;

	// lets see the grid over it
	pos *= .99;

	gl_Position = mvProjMat * vec4(pos, 1.);
}

]], 		{
				chartCode = chartCode,
				chartCNames = chartCNames,
			}),

-- [=[
		geometryCode = [[
layout (triangles) in;
layout (triangle_strip, max_vertices = 3) out;

in vec2 texcoordv[];
out vec2 texcoordg;

in vec3 posv[];

void main() {
	vec3 dlen = vec3(
		length(posv[1] - posv[0]),
		length(posv[2] - posv[1]),
		length(posv[0] - posv[2]));
	if (dlen.x > .25 || dlen.y > .25 || dlen.z > .25)
	{
		return;
	}

	gl_Position = gl_in[0].gl_Position;
	texcoordg = texcoordv[0];
	EmitVertex();

	gl_Position = gl_in[1].gl_Position;
	texcoordg = texcoordv[1];
	EmitVertex();

	gl_Position = gl_in[2].gl_Position;
	texcoordg = texcoordv[2];
	EmitVertex();

	EndPrimitive();
}
]],
--]=]


			fragmentCode = template([[
in vec2 texcoordg;
out vec4 fragColor;

uniform sampler2D earthTex;
uniform float alpha;

void main() {
	fragColor = texture(earthTex, vec2(texcoordg.x, 1. - texcoordg.y));
	fragColor.a = alpha;
}
]],			{
				chartCode = chartCode,
			}),
			uniforms = {
				earthTex = 0,
				alpha = .5,
			},
		},
		vertexes = self.vertexBuf,
		geometries = geometries,
		texs = {
			GLTex2D{
				filename = 'earth-color.png',
				minFilter = gl.GL_LINEAR_MIPMAP_LINEAR,
				magFilter = gl.GL_LINEAR,
				generateMipmap = true,
			}:unbind(),
		},
		uniforms = {
			weight_Equirectangular = 1,
			weight_Azimuthal_equidistant = 0,
			weight_Mollweide = 0,
			weight_WGS84 = 0,
		},
	}
	--]=====] END CLIP FROM GEOGRAPHIC-CHARTS


	-- [=====[ BEGIN EARTHQUAKES
	self.earthquakeLatLonPointObj = GLSceneObject{
		program = {
			version = 'latest',
			precision = 'best',
			vertexCode = template([[
layout(location=0) in vec3 vertex;
layout(location=1) in vec2 texcoord;
out vec2 texcoordv;
flat out float hilite;

uniform mat4 mvProjMat;
uniform bool chartIs3D;
uniform vec2 latlon0;
uniform float pointSize;
uniform uint hiliteIndex;

<?=chartCode?>

<? for _,name in ipairs(chartCNames) do
?>uniform float weight_<?=name?>;
<? end
?>

void main() {
	texcoordv = texcoord;

	if (gl_VertexID >= hiliteIndex * 6 && gl_VertexID < (hiliteIndex + 1) * 6) {
		hilite = 1.;
	} else {
		hilite = 0.;
	}

	vec3 coords = vec3(
		mod(vertex.x + 90. - latlon0.x, 180.) - 90.,	// lat in deg, [-90, 90]
		mod(vertex.y + 180. - latlon0.y, 360.) - 180.,	// lon in deg, [-180, 180]
		1e+3);					// height in meters

	vec3 pos = 0.
<? for _,name in ipairs(chartCNames) do
?>		+ weight_<?=name?> * chart_<?=name?>(coords)
<? end
?>	;
	pos /= WGS84_a;	//from meters to normalized coordinates
	
	if (chartIs3D) {
		pos = vec3(pos.z, pos.x, pos.y);
	}

	mat3 e = mat3(vec3(0.), vec3(0.), vec3(0.))
<? for _,name in ipairs(chartCNames) do
?>		+ weight_<?=name?> * chart_<?=name?>_basis(vec3(vertex.xy, 0.))
<? end
?>	;
	float magn = vertex.z;
	pos += (texcoord.x * e[0] + texcoord.y * e[1]) * pointSize * magn;

	gl_Position = mvProjMat * vec4(pos, 1.);
}

]], 		{
				chartCode = chartCode,
				chartCNames = chartCNames,
			}),
			fragmentCode = [[
in vec2 texcoordv;
flat in float hilite;
out vec4 fragColor;
void main() {
	float lenSq = dot(texcoordv, texcoordv);
	if (lenSq > 1.) discard;
	fragColor = vec4(1., .5 * (1. - hilite), 0., 1.);
	if (lenSq > .9*.9) {
		fragColor = vec4(0., 0., 0., 1.);
	}
}
]],
		},
		geometry = {
			mode = gl.GL_TRIANGLES,
		},
		vertexes = {
			dim = 3,
			useVec = true,
		},
		attrs = {
			texcoord = {
				buffer = {
					dim = 2,
					useVec = true,
				},
			},
		},
	}
	-- TODO .useVec with .data ... atm it just overwrites .data

	local quadVtxs = {
		{0, 0},
		{1, 0},
		{0, 1},
		{0, 1},
		{1, 0},
		{1, 1}
	}
	local vertexGPU = self.earthquakeLatLonPointObj.attrs.vertex.buffer
	local texcoordGPU = self.earthquakeLatLonPointObj.attrs.texcoord.buffer
	local vertexCPU = vertexGPU:beginUpdate()
	local texcoordCPU = texcoordGPU:beginUpdate()
	for i,eq in ipairs(earthquakes) do
		-- latitude: S = negative, N = positive
		-- longitude: W = negative, E = positive
--print(i, eq.latitude, eq.longitude)
		for _,v in ipairs(quadVtxs) do
			vertexCPU:emplace_back()[0]:set(eq.latitude, eq.longitude, eq.mag)
			texcoordCPU:emplace_back()[0]:set(v[1] * 2 - 1, v[2] * 2 - 1)
		end
	end
	assert.eq(#vertexCPU, 6 * #earthquakes)
	vertexGPU:endUpdate()
	texcoordGPU:endUpdate()
	--]=====] END EARTHQUAKES

	local numCircleDivs = 100
	self.circlesObj = GLSceneObject{
		-- TODO geometry shader the resolution? or can they even spit out that many vertexes?
		vertexes = {
			dim = 1,
			data = range(numCircleDivs):mapi(|i| (i-.5)/numCircleDivs),
		},
		geometry = {
			mode = gl.GL_LINE_LOOP,
		},
		program = {
			version = 'latest',
			precision = 'best',
			vertexCode = template([[
layout(location=0) in float vertex;
out vec3 posv;
out vec4 colorv;

uniform vec3 color;	// base color
uniform vec3 axis2, axis3;	// axis dual = basis of circle
uniform float influence;	// additive influence, 
uniform vec4 centerPos;	// .w = cos(centerAngle) * angleFade


uniform mat4 mvProjMat;
uniform bool chartIs3D;
uniform vec2 latlon0;	// used for texturing, TODO FIXME proper 3d transform

//////// BEGIN CODE MATCHING CHART CODE ABOVE
<?=chartCode?>

<? for _,name in ipairs(chartCNames) do
?>uniform float weight_<?=name?>;
<? end
?>
//////// END CODE MATCHING CHART CODE ABOVE

//////// BEGIN GLSL CARTESIANTOLATLONWGS84 THAT'S ALSO IN MY EARTH MAGNETIC FIELD MODEL CODE
// ported from WMM2020 GeomagnetismLibrary.c
// expects xyz in cartesian units earth-semimajor-axis
// output is in (radians, radians, km)
// TODO just use charts.WGS84:chartInv(x,y,z) ?  or use this there?
vec3 cartesianToLatLonWGS84(vec3 pos) {
	// lowercase WGS84_a is in km, uppercase WGS84_a is in m ... i know i need to fix this ...
	pos *= WGS84_a;	// convert from semimajor-axis units to km
	float modified_b = pos.z < 0. ? -WGS84_b : WGS84_b;
	float r = length(pos.xy);

	float e = (modified_b * pos.z - (WGS84_a * WGS84_a - modified_b * modified_b)) / (WGS84_a * r);
	float f = (modified_b * pos.z + (WGS84_a * WGS84_a - modified_b * modified_b)) / (WGS84_a * r);
	float p = (4. / 3.) * (e * f + 1.);
	float q = 2. * (e * e - f * f);
	float d = p * p * p + q * q;

	float v;
	if  (d >= 0.) {
		v = pow(sqrt(d) - q, 1./3.) - pow(sqrt(d) + q, 1./3.);
	} else {
		v = 2. * sqrt(-p) * cos(acos(q / (p * sqrt(-p))) / 3.);
	}

	if (v * v < abs(p)) {
		v = -(v * v * v + 2. * q) / (3. * p);
	}

	float g = (sqrt(e * e + v) + e) / 2.;
	float t = sqrt(g * g + (f - v * g) / (2. * g - e)) - g;

	float phi = atan((WGS84_a * (1. - t * t)) / (2. * modified_b * t));	// latitude

	float height = (r - WGS84_a * t) * cos(phi) + (pos.z - modified_b) * sin(phi);
	float lambda = atan(pos.y, pos.x);	// longitude
	lambda += M_PI;
	lambda = mod(lambda, 2. * M_PI);
	lambda -= M_PI;
	// longitude = lambda = range of [-pi, pi]
	return vec3(phi, lambda, height * 1e+3);		// km back to m
}
//////// END GLSL CARTESIANTOLATLONWGS84 THAT'S ALSO IN MY EARTH MAGNETIC FIELD MODEL CODE

void main() {
	float theta = vertex * 2. * M_PI;
	vec3 v = axis2 * cos(theta) + axis3 * sin(theta);
	float cosAngle = dot(v, centerPos.xyz);
	float alpha = clamp(cosAngle * centerPos.w, 0., 1.);
	colorv = vec4(color * influence, alpha);

	vec2 latlon = cartesianToLatLonWGS84(v).xy;
	// ... to degrees 
	latlon.x *= 180. / M_PI;	//[-90, 90]
	latlon.y *= 180. / M_PI;	//[-180, 180]
	
	//////// BEGIN CODE MATCHING CHART CODE ABOVE
	vec3 coords = vec3(
		mod(latlon.x + 90. - latlon0.x, 180.) - 90.,	// lat in deg, [-90, 90]
		mod(latlon.y + 180. - latlon0.y, 360.) - 180.,	// lon in deg, [-180, 180]
		2e+3);						// height in meters

	vec3 pos = 0.
<? for _,name in ipairs(chartCNames) do
?>		+ weight_<?=name?> * chart_<?=name?>(coords)
<? end
?>	;

	//from meters to normalized coordinates
	pos /= WGS84_a;

	if (chartIs3D) {
		pos = vec3(pos.z, pos.x, pos.y);
	}
	posv = pos;
	gl_Position = mvProjMat * vec4(pos, 1.);
	//////// END CODE MATCHING CHART CODE ABOVE
}
]],			{
				chartCode = chartCode,
				chartCNames = chartCNames,
			}),

-- [=[ but really just don't use this, just cull the vertexes in the array buffer
-- then again, this does let me split up line loops.
			-- lets see if we can hide lines that loop from lon=-180 to lon=+180 and go across the equirectangular/mollweide/most 2D projections
			-- TODO I could use this for the circle tesselation to begin with.  just pass the angle + axis.
			-- TODO TODO once I do that, I could also just do the cartesian-to-wgs84 in the fragment, then apply the charts in the fragment.
			geometryCode = [[
layout (lines) in;
layout (line_strip, max_vertices = 2) out;

in vec4 colorv[];
in vec3 posv[];
out vec4 colorg;

void main() {
	float dlen = length(posv[1] - posv[0]);
	if (dlen > .25) {
		return;
	}

	gl_Position = gl_in[0].gl_Position;
	colorg = colorv[0];
	EmitVertex();

	gl_Position = gl_in[1].gl_Position;
	colorg = colorv[1];
	EmitVertex();

	EndPrimitive();
}
]],
--]=]
			fragmentCode = [[
in vec4 colorg;		// using geometry shader
//in vec4 colorv;	// not using geometry shader
out vec4 fragColor;
uniform float alpha;
void main() {
	fragColor = colorg;
	//fragColor = colorv;
	fragColor.a *= alpha;
}
]],
		},
	}



	gl.glEnable(gl.GL_DEPTH_TEST)
	gl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE) --gl.GL_ONE_MINUS_SRC_ALPHA)


	--[=[ build here
	-- show axii of circles
	self.pairCrossPointsObj = GLSceneObject{
		program = {
			version = 'latest',
			precision = 'best',
			vertexCode = template([[
layout(location=0) in vec2 vertex;
uniform mat4 mvProjMat;
uniform bool chartIs3D;
uniform vec2 latlon0;

//////// BEGIN CODE MATCHING CHART CODE ABOVE
<?=chartCode?>

<? for _,name in ipairs(chartCNames) do
?>uniform float weight_<?=name?>;
<? end
?>

//////// END CODE MATCHING CHART CODE ABOVE

void main() {
	//////// BEGIN CODE MATCHING CHART CODE ABOVE
	vec3 coords = vec3(
		mod(vertex.y * 180. - latlon0.y, 180.) - 90.,	// lat in deg, [-90, 90]
		mod(vertex.x * 360. - latlon0.x, 360.) - 180.,	// lon in deg, [-180, 180]
		2e+3);						// height in meters

	vec3 pos = 0.
<? for _,name in ipairs(chartCNames) do
?>		+ weight_<?=name?> * chart_<?=name?>(coords)
<? end
?>	;

	//from meters to normalized coordinates
	pos /= WGS84_a;

	if (chartIs3D) {
		pos = vec3(pos.z, pos.x, pos.y);
	}
	gl_Position = mvProjMat * vec4(pos, 1.);
	//////// END CODE MATCHING CHART CODE ABOVE

}
]],			{
				chartCode = chartCode,
				chartCNames = chartCNames,
			}),
			fragmentCode = [[
out vec4 fragColor;
void main() {
	fragColor = vec4(1., 1., 1., 1.);
}
]],
},
		geometry = {
			mode = gl.GL_POINTS,
		},
		vertexes = {
			dim = 3,
			useVec = true,
		},
	}

	local pairCrossPoints = self.pairCrossPointsObj.attrs.vertex.buffer.vec
	circles = table()
	for i1=1,#earthquakes-1 do
		local e1 = earthquakes[i1]
		for i2=i1+1,#earthquakes do
			local e2 = earthquakes[i2]
			local v1 = latLonToXYZ(e1)
			local v2 = latLonToXYZ(e2)
			local torque = v1:cross(v2)	-- TODO times pair of earthquake magnitudes or something?
			local axisLen = torque:length()
			local axis = torque * (1 / (math.max(axisLen, 1e-15)))
			local influence = axisLen * 10^e1.mag * 10^e2.mag
			-- hmm proper torque would be based on radius from earth ... so consider depth?

			-- hmmmmm
			-- if ponits are 180' or if they are next to each other then we want no infuence ...
			-- ... .maybe I souldn't nrmlize with the cross produt ...
			-- and then I should look at the point-cloud of the axis' ...
			for s=-1,1,2 do
				local x,y,z = (s * torque):unpack()
				local phi, lambda = cartesianToLatLonWGS84(z,x,y)	-- hmm ...
				pairCrossPoints:insert(((math.deg(lambda) + 180) / 360) % 1)
				pairCrossPoints:insert(((math.deg(phi) + 90) / 180) % 1)
			end

			local angle = math.acos(v1:dot(v2))
			--if math.rad(15) < angle and angle < math.rad(60) then		-- threshold angle for point pairs for inserting a great-arc
			if math.rad(10) < angle and angle < math.rad(90) then	-- if I weight by cross then that'll make the 0' and 180' angles diminish ... nah, there's still a lot of noise unless I turn down the alpha ... then it's hard to highlight any geodesics ...
				circles:insert{
					axis = axis,
					angle = math.pi * .5,
					color = vec3d(1, .3, .07) * influence,
					centerPos = (v1 + v2):normalize(),	-- midpoint between two earthquake lines
					centerAngle = .5 * angle,	-- half the angle between them
				}
			end
		end
	end
	self.pairCrossPointsObj:endUpdate()
	--]=]
	--[=[ or TODO all circles and just hide/show the ones associated with the current quake ...
	circles = allCircles
	--]=]

	recalculateOldestEarthquakeIndex()
	self:recalcAllCircles()
end

-- refresh the list of what circles we want to display right now
-- this is either all circles in the last period (3 days? 1 day? etc)
-- or it is all that are touching the currently selected quake
App.refreshRelevantCircles = |:| do
	if vars.showOnlySelectedEarthquakeArcs then
		-- show all circles touching our currently selected
		circles = earthquakes[vars.earthquakeIndex]
			.touchingCircles:mapi(|t| allCircles[t.circle])
	else
		-- show all circles touching any active earthquakes in the last timeframe
		local circleIndexes = table()
		for i=oldestEarthquakeIndex,vars.earthquakeIndex do
			for _,ci in ipairs(circlesMadeByQuakes[i]) do
				circleIndexes[ci] = true
			end
		end
		circles = circleIndexes:keys():sort():mapi(|ci| allCircles[ci])
	end
end


App.update = |:| do
	gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT)

	if vars.drawEarth then
		-- [=====[ BEGIN CLIP FROM GEOGRAPHIC-CHARTS
		local sceneObj = self.globeObj
		for _,name in ipairs(weightFields) do
			sceneObj.uniforms[name] = vars[name]
		end
		sceneObj.uniforms.latlon0 = {vars.lat0, vars.lon0}
		sceneObj.uniforms.chartIs3D = false	-- this is just whether to swap x y and z around , z = along view vs z = north pole
		sceneObj.uniforms.mvProjMat = self.view.mvProjMat.ptr
		sceneObj:draw()
		--]=====] END CLIP FROM GEOGRAPHIC-CHARTS
	end

	if vars.drawGreatArcs then
		local sceneObj = self.circlesObj
gl.glLineWidth(vars.lineWidth)
gl.glEnable(gl.GL_BLEND)
gl.glDepthMask(0)
		for _,c in ipairs(circles) do
			for _,name in ipairs(weightFields) do
				sceneObj.uniforms[name] = vars[name]
			end
			sceneObj.uniforms.latlon0 = {vars.lat0, vars.lon0}
			sceneObj.uniforms.color = {c.color:unpack()}
			sceneObj.uniforms.axis2 = {c.axis2:unpack()}
			sceneObj.uniforms.axis3 = {c.axis3:unpack()}
			sceneObj.uniforms.influence = c.influence
			sceneObj.uniforms.centerPos = {c.centerPos.x, c.centerPos.y, c.centerPos.z, vars.angleFade / math.cos(c.centerAngle)}
			sceneObj.uniforms.chartIs3D = false	-- this is just whether to swap x y and z around , z = along view vs z = north pole
			sceneObj.uniforms.mvProjMat = self.view.mvProjMat.ptr
			sceneObj.uniforms.alpha = vars.greatArcAlpha
			sceneObj:draw()
		end
gl.glDepthMask(1)
gl.glDisable(gl.GL_BLEND)
gl.glLineWidth(1)
	end

	if vars.drawEarthquakes then
		gl.glDepthFunc(gl.GL_LEQUAL)
		local sceneObj = self.earthquakeLatLonPointObj
		for _,name in ipairs(weightFields) do
			sceneObj.uniforms[name] = vars[name]
		end
		sceneObj.uniforms.latlon0 = {vars.lat0, vars.lon0}
		sceneObj.uniforms.chartIs3D = false	-- this is just whether to swap x y and z around , z = along view vs z = north pole
		sceneObj.uniforms.mvProjMat = self.view.mvProjMat.ptr
		sceneObj.uniforms.pointSize = vars.pointSize

		-- 6 * becuse i'm drawing two tris per point into the vertex buffer (TODO billboard and instances maybe?)
		sceneObj.geometry.offset = 6 * (oldestEarthquakeIndex - 1)
		sceneObj.geometry.count = 6 * (vars.earthquakeIndex - oldestEarthquakeIndex + 1)

		sceneObj:draw()

		sceneObj.geometry.offset = nil
		sceneObj.geometry.count = nil
		gl.glDepthFunc(gl.GL_LESS)
	end

	--[=[ TODO
	if vars.drawAxisTorques then
		local sceneObj = self.pairCrossPointsObj
		if #sceneObj.attrs.vertex.buffer.vec > 0 then
			for _,name in ipairs(weightFields) do
				sceneObj.uniforms[name] = vars[name]
			end
			sceneObj.uniforms.latlon0 = {vars.lon0, vars.lat0}
			sceneObj.uniforms.chartIs3D = false	-- this is just whether to swap x y and z around , z = along view vs z = north pole
			sceneObj.uniforms.mvProjMat = self.view.mvProjMat.ptr

			gl.glPointSize(vars.axisTorquePointSize)
			sceneObj:draw()
			gl.glPointSize(1)
		end
	end
	--]=]

	App.super.update(self)


	-- while we're here...
	-- ... re-download the latest day's earthquakes
	local t = os.time()
	if t > checkTime + checkDuration then
		checkTime = t
		local newTodaysEarthquakes, changed = getDayCache(t, true)
		if changed then
			print(os.date(), 'TODO upate me plz')
		end
	end
end

App.updateEarthquakeIndex = |:| do
	vars.earthquakeIndex = math.clamp(math.round(vars.earthquakeIndex), 1, #earthquakes)

	recalculateOldestEarthquakeIndex()
	self:refreshRelevantCircles()	-- TODO don't recalc all circles, just recalc indexes used
end

App.event = |:,e| do
	App.super.event(self, e)
	if e[0].type == sdl.SDL_EVENT_KEY_DOWN then
		if not ig.igGetIO()[0].WantCaptureKeyboard then
			if e[0].key.key == sdl.SDLK_LEFT then
				vars.earthquakeIndex -= 1
				self:updateEarthquakeIndex()
			elseif e[0].key.key == sdl.SDLK_RIGHT then
				vars.earthquakeIndex += 1
				self:updateEarthquakeIndex()
			end
		end
	end
end

App.updateGUI = |:| do
	ig.igSetNextWindowBgAlpha(.3)
	ig.igPushStyleColor_U32(ig.ImGuiCol_MenuBarBg, 0)
	if ig.igBeginMainMenuBar() then
		if ig.igBeginMenu'options:' then
			ig.luatableCheckbox('ortho', self.view, 'ortho')
			if ig.igButton'reset view' then
				self.view.ortho = true
				self.view.orthoSize = self.viewOrthoSize
				self.view.angle:set(0,0,0,1)
				self.view.orbit:set(0,0,0)
				self.view.pos:set(0, 0, self.viewDist)
			end
			ig.luatableCheckbox('draw earth', vars, 'drawEarth')
			ig.luatableCheckbox('draw earthquakes', vars, 'drawEarthquakes')
			ig.luatableInputFloat('pointSize', vars, 'pointSize')

			ig.luatableCheckbox('draw great arcs', vars, 'drawGreatArcs')
			ig.luatableSliderFloat('great arc alpha', vars, 'greatArcAlpha', 0, 1)
			ig.luatableSliderFloat('lineWidth', vars, 'lineWidth', 0, 20)
			ig.luatableInputFloat('angleFade', vars, 'angleFade')
			if ig.luatableCheckbox('showOnlySelectedEarthquakeArcs', vars, 'showOnlySelectedEarthquakeArcs') then
				self:refreshRelevantCircles()
			end

			--[=[ TODO
			ig.luatableCheckbox('drawAxisTorques', vars, 'drawAxisTorques')
			ig.luatableSliderFloat('axisTorquePointSize', vars, 'axisTorquePointSize', 0, 10)
			--]=]

			local changed
			changed = ig.luatableSliderFloat('earthquakeIndex s', vars, 'earthquakeIndex', 1, #earthquakes)
			changed = ig.luatableInputInt('earthquakeIndex t', vars, 'earthquakeIndex', 1, #earthquakes) or changed
			if changed then
				self:updateEarthquakeIndex()
			end
			ig.igText('earthquake time = '..earthquakes[vars.earthquakeIndex].time)
			ig.igText('earthquake place = '..earthquakes[vars.earthquakeIndex].place)
			ig.igText('oldestEarthquakeIndex = '..oldestEarthquakeIndex)
			ig.igText('oldest earthquake time = '..earthquakes[oldestEarthquakeIndex].time)

			ig.luatableSliderFloat('lat0', vars, 'lat0', -90, 90)
			ig.luatableSliderFloat('lon0', vars, 'lon0', -180, 180)
			ig.luatableCheckbox('normalize weights', vars, 'normalizeWeights')
			local changed
			for _,field in ipairs(weightFields) do
				if ig.luatableSliderFloat(field, vars, field, 0, 1) then
					changed = field
				end
			end
			if vars.normalizeWeights and changed then
				local restFrac = 1 - vars[changed]
				local totalRest = 0
				for _,field in ipairs(weightFields) do
					if field ~= changed then
						totalRest = totalRest + vars[field]
					end
				end
				for _,field in ipairs(weightFields) do
					if field ~= changed then
						if totalRest == 0 then
							vars[field] = 0
						else
							vars[field] = restFrac * vars[field] / totalRest
						end
					end
				end
			end

			ig.igEndMenu()
		end
		if ig.igBeginMenu'circles:' then
			if ig.luatableInputFloat('greatArcAngleMin', calcCircles, 'greatArcAngleMin') then
				self:recalcAllCircles()
			end
			if ig.luatableInputFloat('greatArcAngleMax', calcCircles, 'greatArcAngleMax') then
				self:recalcAllCircles()
			end
			if ig.luatableInputFloat('quakeAlignWithPreviousGeodesicAngleThreshold', calcCircles, 'quakeAlignWithPreviousGeodesicAngleThreshold') then
				self:recalcAllCircles()
			end
			if ig.luatableInputFloat('filterDuplicateTouchingArcsAngleThreshold', calcCircles, 'filterDuplicateTouchingArcsAngleThreshold') then
				self:recalcAllCircles()
			end
			if ig.luatableInputFloat('filterDuplicatePointsAngleThreshold', calcCircles, 'filterDuplicatePointsAngleThreshold') then
				self:recalcAllCircles()
			end
			if ig.luatableInputFloat('timeWindowInDays', calcCircles, 'timeWindowInDays') then
				recalculateOldestEarthquakeIndex()
				self:recalcAllCircles()
			end

			ig.igEndMenu()
		end
		ig.igEndMainMenuBar()
	end
	ig.igPopStyleColor(1)
end

return App():run()
