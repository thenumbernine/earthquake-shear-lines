#!/usr/bin/env rua
local template = require 'template'
local sdl = require 'sdl'
local gl = require 'gl'
local Image = require 'image'
local GLSceneObject = require 'gl.sceneobject'
local GLArrayBuffer = require 'gl.arraybuffer'
local GLProgram = require 'gl.program'
local GLGeometry = require 'gl.geometry'
local GLTex2D = require 'gl.tex2d'
local GLGradientTex2D = require 'gl.gradienttex2d'
local GLFBO = require 'gl.fbo'
local glreport = require 'gl.report'
local ig = require 'imgui'
local vec2f = require 'vec-ffi.vec2f'
local vec2d = require 'vec-ffi.vec2d'
local vec3d = require 'vec-ffi.vec3d'
local quatd = require 'vec-ffi.quatd'
local vector = require 'ffi.cpp.vector-lua'

local CLEnv = require 'cl.obj.env'
local clnumber = require 'cl.obj.number'

local Planets = require 'solarsystem.planets'
local Julian = require 'solarsystem.julian'

local basisFor = require 'basis'.basisFor

local charts = require 'charts'.charts
local chartCode = require 'charts'.chartCode
local chartCNames = require 'charts'.chartCNames
local cartesianToLatLonWGS84 = require 'charts'.cartesianToLatLonWGS84

local getDayCache = require 'earthquakes'.getDayCache
local checkTime = require 'earthquakes'.checkTime
local earthquakes = require 'earthquakes'.earthquakes
local checkDuration = 60*5	-- re-check every 5 mins

local flares = require 'flares'

local time = require 'time'.time
local timegm = require 'time'.timegm
local gmtime = require 'time'.gmtime
local dayInSec = require 'time'.dayInSec

local calcCircles = require 'circles'


--[[ me doing some calcs:
1) get all circles across all earthquakes
2) find all within a 3rd earthquake within an angle tolerance of 0.1 or whatever... honestly try 1 or 3 or 5 now.
3) look at distribution of angles that quakes strike at.
--]]


local intptr = ffi.new'int[1]'
local int = |x| do intptr[0] = x return intptr end

local doubleptr = ffi.new'double[1]'
local double = |x| do doubleptr[0] = x return doubleptr end

for _,name in ipairs(chartCNames) do
	chartCode ..= '\nuniform float weight_'..name..';'
end

chartCode ..= [[

//////// BEGIN GLSL THAT'S ALSO IN MY EARTH MAGNETIC FIELD MODEL CODE
// ported from WMM2020 GeomagnetismLibrary.c
// expects xyz in cartesian units earth-semimajor-axis
// output is in (radians, radians, km)
// TODO just use charts.WGS84:chartInv(x,y,z) ?  or use this there?
vec3 cartesianToLatLonWGS84(vec3 pos) {
	// lowercase WGS84_a is in km, uppercase WGS84_a is in m ... i know i need to fix this ...
	pos *= WGS84_a;	// convert from semimajor-axis units to m
	float modified_b = pos.z < 0. ? -WGS84_b : WGS84_b;
	float r = length(pos.xy);

	float e = (modified_b * pos.z - (WGS84_a * WGS84_a - modified_b * modified_b)) / (WGS84_a * r);
	float f = (modified_b * pos.z + (WGS84_a * WGS84_a - modified_b * modified_b)) / (WGS84_a * r);
	float p = (4. / 3.) * (e * f + 1.);
	float q = 2. * (e * e - f * f);
	float d = p * p * p + q * q;

	float v;
	if  (d >= 0.) {
		v = pow(sqrt(d) - q, 1./3.) - pow(sqrt(d) + q, 1./3.);
	} else {
		v = 2. * sqrt(-p) * cos(acos(q / (p * sqrt(-p))) / 3.);
	}

	if (v * v < abs(p)) {
		v = -(v * v * v + 2. * q) / (3. * p);
	}

	float g = (sqrt(e * e + v) + e) / 2.;
	float t = sqrt(g * g + (f - v * g) / (2. * g - e)) - g;

	float phi = atan((WGS84_a * (1. - t * t)) / (2. * modified_b * t));	// latitude

	float height = (r - WGS84_a * t) * cos(phi) + (pos.z - modified_b) * sin(phi);
	float lambda = atan(pos.y, pos.x);	// longitude
	lambda += M_PI;
	lambda = mod(lambda, 2. * M_PI);
	lambda -= M_PI;
	// longitude = lambda = range of [-pi, pi]
	return vec3(phi, lambda, height);
}
//////// END GLSL THAT'S ALSO IN MY EARTH MAGNETIC FIELD MODEL CODE

vec2 vec2exp(float rad) {
	return vec2(cos(rad), sin(rad));
}

vec3 rotateX(vec3 v, float rad) {
	vec2 cs = vec2exp(rad);
	return vec3(
		v.x,
		v.y * cs.x - v.z * cs.y,
		v.y * cs.y + v.z * cs.x);
}

vec3 rotateY(vec3 v, float rad) {
	vec2 cs = vec2exp(rad);
	return vec3(
		v.x * cs.x + v.z * cs.y,
		v.y,
		-v.x * cs.y + v.z * cs.x);
}

vec3 rotateZ(vec3 v, float rad) {
	vec2 cs = vec2exp(rad);
	return vec3(
		v.x * cs.x - v.y * cs.y,
		v.x * cs.y + v.y * cs.x,
		v.z);
}

// hmm, floating point accuracy issue ...
vec2 applyLatLonRoll0(vec2 latlon) {
#if 0 // wgs84
	vec3 pos = chart_WGS84(vec3(latlon, 0.));
	return cartesianToLatLonWGS84(pos / WGS84_a).xy * (180. /  M_PI);
#else // sphere
	vec3 pos = chart_sphere(vec3(latlon, 0.));
	pos.xyz = pos.zxy;

	vec2 latcs = vec2exp(latlonroll0.x * M_PI / 180.);
	vec2 loncs = vec2exp(latlonroll0.y * M_PI / 180.);
	vec2 rollcs = vec2exp(latlonroll0.z * M_PI / 180.);
	pos = rotateZ(pos, -latlonroll0.y * M_PI / 180.);	// heading / yaw
	pos = rotateY(pos, latlonroll0.x * M_PI / 180.);	// pitch / inclination
	pos = rotateX(pos, latlonroll0.z * M_PI / 180.);	// bank / roll

	// chartInv_sphere expects north pole to be z+, prime meridian to be x+
	pos.zxy = pos.xyz;
	return chartInv_sphere(pos).xy;
#endif
}

// hmm, floating point accuracy issue ...
vec2 applyLatLonRoll0Inv(vec2 latlon) {
#if 0 // wgs84
	vec3 pos = chart_WGS84(vec3(latlon, 0.));
	return cartesianToLatLonWGS84(pos / WGS84_a).xy * (180. /  M_PI);
#else // sphere
	vec3 pos = chart_sphere(vec3(latlon, 0.));
	pos.xyz = pos.zxy;

	vec2 latcs = vec2exp(latlonroll0.x * M_PI / 180.);
	vec2 loncs = vec2exp(latlonroll0.y * M_PI / 180.);
	vec2 rollcs = vec2exp(latlonroll0.z * M_PI / 180.);

	pos = rotateX(pos, -latlonroll0.z * M_PI / 180.);	// bank / roll
	pos = rotateY(pos, -latlonroll0.x * M_PI / 180.);	// pitch / inclination
	pos = rotateZ(pos, latlonroll0.y * M_PI / 180.);	// heading / yaw

	// chartInv_sphere expects north pole to be z+, prime meridian to be x+
	pos.zxy = pos.xyz;
	return chartInv_sphere(pos).xy;
#endif
}


]]

local drawPlanetClasses = table.filter(Planets.planetClasses, |c| c.name ~= 'earth' and c.name ~= 'EM_Bary')
-- should I do some geometry-index stuff too or nah?
local drawPlanetAngles = table{
	1, 5, 15, 30, 45, 60, 90, 120, 135, 150, 175, 179
}

-- this is only used for the ui, while the CL planetPos list has all of them, so that I can indivivdually index into it or something idk
local calcPlanetClasses = table.filter(Planets.planetClasses, |c| c.name ~= 'EM_Bary')

local displayComponentNames = table{
	'x',
	'y',
	'z',
	'r',
	'θ',
	'φ',
	'∠xy',
	'∠yz',
	'∠zx',
	'|xy|',
	'|yz|',
	'|zx|',
	'∠rθ',
	'∠θφ',
	'∠φr',
	'|rθ|',
	'|θφ|',
	'|φr|',
	'|xyz|',
}
displayComponentCNames = displayComponentNames:mapi(|name|
	'displayComponent_'..name
		:gsub('θ', 'theta')
		:gsub('φ', 'phi')
		:gsub('∠', 'angle_')
		:gsub('|(.*)|', 'length_%1')
)

local calcFlagsCode = [[
enum {
	calcFlags_calcTidesVert = 1,
	calcFlags_calcTidesHorz = 2,
	calcFlags_calcTides = calcFlags_calcTidesVert | calcFlags_calcTidesHorz,
	calcFlags_calcGravVert = 4,
	calcFlags_calcGravHorz = 8,
	calcFlags_calcGrav = calcFlags_calcGravVert | calcFlags_calcGravHorz,
	calcFlags_calcCrossPos2D = 16,
	calcFlags_calcCrossPos3D = 32,
	calcFlags_calcCrossVel = 64,
	calcFlags_calcRadialIntegral = 128,	// integrates previous result in spherical coordinates
	calcFlags_calcSurfaceGradMagn = 256,	// takes previous result, does df/dθ and df/dφ in spherical, calcs magnitude using spherical metric of diag(r^2, r^2 sin(θ)^2)
};
enum {
	]]..displayComponentCNames:mapi(|v,i| v..' = '..i):concat',\n\t'..',\n'..[[
};
]]
ffi.cdef(calcFlagsCode)

local weightFields = chartCNames:mapi(|name| 'weight_'..name)
local vars = table(
	weightFields:mapi(|name| (name == 'weight_Equirectangular' and 1 or 0, name)),
	{
		showOnlySelectedEarthquakeArcs = true ,	-- true = show only selected earthquake circle, false = show all
		normalizeWeights = true,
		drawEarth = true,
		drawEarthquakes = true,
		earthquakePointSize = .005,		-- but make it proportional to size in view maybe? like USGS does?
		drawGreatArcs = true,
		greatArcAlpha = .1,
		lineWidth = 1,
		angleFade = 1,
		drawFlares = true,
		flarePointSize = .005,
		forceTexAlpha = .5,

		showDrapTex = false,		-- keep it off by default for now ... it works but it adds too many moving pieces
		drapTexAlpha = .5,

		calcTidesVert = false,
		calcTidesHorz = false,
		calcGravVert = true,
		calcGravHorz = false,
		calcCrossPos2D = false,	-- cross force with moment arm
		calcCrossPos3D = false,	-- cross force with position (incl z along axis)
		calcCrossVel = false,
		calcRadialIntegral = false,	-- integrate along earth radius parameter from core to surface
		calcSurfaceGradMagn = false,

		displayComponent = #displayComponentNames,

		drawAnyPlanets = true,
		drawPlanets = drawPlanetClasses:mapi(|c|(
			true, 		-- draw all
			--c.name == 'sun' or c.name == 'moon',	-- only draw sun and moon
			c.name
		)),	-- drawPlanets[name] = true
		calcPlanets = table.mapi(Planets.planetClasses, |c|(
			c.name == 'sun' or c.name == 'moon' or c.name == 'earth',
			c.name
		)),	-- calcPlanets[name] = true
		drawPlanetAngles = drawPlanetAngles:mapi(|x|(
			x == 1 or x == 5 or x == 179,
			x
		)),
		drawAxisCloud = false,	-- only really useful if you are looking at/ analyzing data in 3D spherical/WGS84 chart view
		axisCloudPointSize = .02,
		axisCloudHeightScale = -1,
		lat0 = 0,		-- degrees
		lon0 = -155,	-- degrees
		roll0 = 0,		-- degrees
		targetlat0 = 0,
		targetlon0 = -155,
		targetroll0 = 0,
		latlonroll0convergeRate = 0.1,	-- what coefficient to converge every frame
		recenterOnQuake = false,
		earthquakeIndex = #earthquakes,

		trackEarthquakeIndex = -1,
	}
):setmetatable(nil)


local App = require 'imgui.appwithorbit'()
App.title = 'Earthquake Geodesics'
App.viewDist = 2

local earthquakeWindowStartIndex
local earthquakeWindowEndIndex
local flareWindowStartIndex = 0
local flareWindowEndIndex = 0
App.calcQuakeWindowIndexes = |:|do
	-- TODO with bisect
	local windowStartTime = earthquakes[vars.earthquakeIndex].ostime - calcCircles.prevTimeWindowInDays * dayInSec
	local windowEndTime = earthquakes[vars.earthquakeIndex].ostime + calcCircles.nextTimeWindowInDays * dayInSec

	earthquakeWindowStartIndex = vars!.earthquakeIndex
	for i=vars.earthquakeIndex,1,-1 do
		if earthquakes[i].ostime < windowStartTime then break end
		earthquakeWindowStartIndex = i
	end
	earthquakeWindowEndIndex = vars!.earthquakeIndex
	for i=vars.earthquakeIndex,#earthquakes do
		if earthquakes[i].ostime > windowEndTime then break end
		earthquakeWindowEndIndex = i
	end

	if #flares > 0 then
		flareWindowStartIndex = #flares
		for i=#flares,1,-1 do
			if flares[i].ostime < windowStartTime then break end
			flareWindowStartIndex = i
		end
		flareWindowEndIndex = flareWindowStartIndex
		for i=flareWindowStartIndex,#flares do
			if flares![i]!.ostime > windowEndTime then break end
			flareWindowEndIndex = i
		end
	end

	local eq = earthquakes![vars.earthquakeIndex]
	if not eq.touchingCircles then
		-- this function will compute eq.touchingCircles
		--and return the window's "allCircles", which I will store here
		-- now reclaculate all circles within our window
		calcCircles.calcCircles(earthquakes, vars.earthquakeIndex, earthquakeWindowStartIndex, earthquakeWindowEndIndex)

		-- should this be based on what quakes are within 60' and caused me to flag the geodesic?
		-- or should this be on what quakes are subsequently within 1' or 5' or so of that geodesic after-the-fact?
		-- doing the former first ...
		eq.circlesMadeByQuakes = {}
		for ci,c in ipairs(eq.allCircles) do
			for _,i in ipairs(c.indexes) do
				eq.circlesMadeByQuakes[i] ??= table()
				eq.circlesMadeByQuakes[i]:insert(ci)
			end
		end
	end
	self:refreshVisibleCircles()	-- TODO don't recalc all circles, just recalc indexes used
end

-- if we change a quake search parameter then delete all the cached arcs
App.invalidateCachedQuakeArcs = |:|do
	for _,eq in ipairs(earthquakes) do
		eq.allCircles = nil
		eq.touchingCircles = nil
		eq.circlesMadeByQuakes = nil
	end

-- [[ trying to calculate odds
	self.totalLikelihood = nil
	self.oddsTrue = nil
	self.oddsFalse = nil
	for _,eq in ipairs(earthquakes) do
		eq.probabilityOfFindingAnyGeodesic = nil
	end
--]]
end


local texWrap = {
	s = gl.GL_REPEAT,
	--t = gl.GL_CLAMP_TO_EDGE,
	t = gl.GL_CLAMP_TO_BORDER,
}

App.viewOrthoSize = 1.1
App.initGL = |:| do
	App.super.initGL(self)

	self.view.ortho = true
	self.view.orthoSize = self.viewOrthoSize
	-- [=====[ BEGIN CLIP FROM GEOGRAPHIC-CHARTS
	local vertexes = table()
	local idivs = 100
	local jdivs = 200
	for i=0,idivs do
		local u = i/idivs
		--local phi = math.rad((u * 2 - 1) * 90)
		for j=0,jdivs do
			local v = j/jdivs
			--local lambda = math.rad((v * 2 - 1) * 180)
			vertexes:insert(u * 180 - 90)	-- lat, lon = u, v
			vertexes:insert(v * 360 - 180) -- transposed from texcoord space in texcoord space
		end
	end
	self.vertexBuf = GLArrayBuffer{
		data = vertexes,
		dim = 2,
	}:unbind()

	local geometries = table()
	for jbase=0,jdivs-1 do
		local indexes = table()
		for i=0,idivs do
			for jofs=1,0,-1 do
				local j = jbase + jofs
				indexes:insert(j + (jdivs + 1) * i)
			end
		end
		geometries:insert(GLGeometry{
			mode = gl.GL_TRIANGLE_STRIP,
			indexes = {
				data = indexes,
			},
			vertexes = self.vertexBuf,
		})
	end

	self.globeObj = GLSceneObject{
		program = {
			version = 'latest',
			precision = 'best',
			vertexCode = template([[
layout(location=0) in vec2 vertex;
out vec2 texcoordv;
out vec3 posv;

uniform mat4 mvProjMat;
uniform bool chartIs3D;
uniform vec3 latlonroll0;

<?=chartCode?>

void main() {
	vec2 latlonofs = applyLatLonRoll0Inv(vertex);

	//(lat, lon) in [0, 1]
	texcoordv = vec2(
		latlonofs.y / 360. + .5,
		latlonofs.x / 180. + .5
	);

	vec3 coords = vec3(
		mod(vertex.x + 90., 180.) - 90.,	// lat in deg, [-90, 90]
		mod(vertex.y + 180., 360.) - 180.,	// lon in deg, [-180, 180]
		0.);						// height in meters

	vec3 pos = 0.
<? for _,name in ipairs(chartCNames) do
?>		+ weight_<?=name?> * chart_<?=name?>(coords)
<? end
?>	;

	//from meters to normalized coordinates
	pos /= WGS84_a;

	if (chartIs3D) {
		pos = vec3(pos.z, pos.x, pos.y);
	}
	posv = pos;

	// lets see the grid over it
	pos *= .9999;

	gl_Position = mvProjMat * vec4(pos, 1.);
}

]], 		{
				chartCode = chartCode,
				chartCNames = chartCNames,
			}),

-- [=[
		geometryCode = [[
layout (triangles) in;
layout (triangle_strip, max_vertices = 3) out;

in vec2 texcoordv[];
out vec2 texcoordg;

in vec3 posv[];

void main() {
	vec3 dlen = vec3(
		length(posv[1] - posv[0]),
		length(posv[2] - posv[1]),
		length(posv[0] - posv[2]));
	if (dlen.x > .25 || dlen.y > .25 || dlen.z > .25)
	{
		return;
	}

	gl_Position = gl_in[0].gl_Position;
	texcoordg = texcoordv[0];
	EmitVertex();

	gl_Position = gl_in[1].gl_Position;
	texcoordg = texcoordv[1];
	if (texcoordv[1].x - texcoordv[0].x > .5) {
		texcoordg.x -= 1.;
	}
	if (texcoordv[1].x - texcoordv[0].x < -.5) {
		texcoordg.x += 1.;
	}
	EmitVertex();

	gl_Position = gl_in[2].gl_Position;
	texcoordg = texcoordv[2];
	if (texcoordv[2].x - texcoordv[0].x > .5) {
		texcoordg.x -= 1.;
	}
	if (texcoordv[2].x - texcoordv[0].x < -.5) {
		texcoordg.x += 1.;
	}
	EmitVertex();

	EndPrimitive();
}
]],
--]=]


			fragmentCode = template[[
in vec2 texcoordg;
out vec4 fragColor;

uniform sampler2D earthTex;

uniform sampler2D gradientTex;
uniform sampler2D forceTex;
uniform float forceTexAlpha;

uniform sampler2D drapTex;
uniform float drapTexAlpha;

uniform float alpha;	// final alpha

void main() {
	vec2 uv = vec2(texcoordg.x, 1. - texcoordg.y);
	fragColor = texture(earthTex, uv);

	float force = texture(forceTex, uv).r;
	vec4 forceColor = texture(gradientTex, vec2(force, .5));
	fragColor = mix(fragColor, forceColor, forceTexAlpha);

	// might have to rescale the uv here ...
	vec4 drapColor = texture(drapTex, uv);
	fragColor = mix(fragColor, drapColor, drapTexAlpha);

	fragColor.a = alpha;
}
]],
			uniforms = {
				earthTex = 0,
				forceTex = 1,
				gradientTex = 2,
				drapTex = 3,
				alpha = .5,
				forceTexAlpha = .5,
				drapTexAlpha = .5,
			},
		},
		vertexes = self.vertexBuf,
		geometries = geometries,
		texs = {
			GLTex2D{
				filename = 'earth-color.png',
				magFilter = gl.GL_LINEAR,
				--minFilter = gl.GL_NEAREST,
				minFilter = gl.GL_LINEAR_MIPMAP_LINEAR,
				generateMipmap = true,
				wrap = texWrap,
			}:unbind(),
		},
		uniforms = {
			weight_Equirectangular = 1,
			weight_Azimuthal_equidistant = 0,
			weight_Mollweide = 0,
			weight_WGS84 = 0,
		},
	}
	--]=====] END CLIP FROM GEOGRAPHIC-CHARTS

	-- program for drawing the lat/lon at each pixel, for the mouse to use
	self.latLonGlobeObj = GLSceneObject{
		program = {
			version = 'latest',
			precision = 'best',
			vertexCode = template([[
layout(location=0) in vec2 vertex;
out vec2 texcoordv;
out vec3 posv;

uniform mat4 mvProjMat;
uniform bool chartIs3D;
uniform vec3 latlonroll0;

<?=chartCode?>

void main() {
	vec2 latlonofs = applyLatLonRoll0Inv(vertex);

	//(lat, lon) in [0, 1]
	texcoordv = vec2(
		latlonofs.y / 360. + .5,
		latlonofs.x / 180. + .5
	);

	vec3 coords = vec3(
		mod(vertex.x + 90., 180.) - 90.,	// lat in deg, [-90, 90]
		mod(vertex.y + 180., 360.) - 180.,	// lon in deg, [-180, 180]
		0.);						// height in meters

	vec3 pos = 0.
<? for _,name in ipairs(chartCNames) do
?>		+ weight_<?=name?> * chart_<?=name?>(coords)
<? end
?>	;

	//from meters to normalized coordinates
	pos /= WGS84_a;

	if (chartIs3D) {
		pos = vec3(pos.z, pos.x, pos.y);
	}
	posv = pos;

	// lets see the grid over it
	pos *= .9999;

	gl_Position = mvProjMat * vec4(pos, 1.);
}

]], 		{
				chartCode = chartCode,
				chartCNames = chartCNames,
			}),

-- [=[
		geometryCode = [[
layout (triangles) in;
layout (triangle_strip, max_vertices = 3) out;

in vec2 texcoordv[];
out vec2 texcoordg;

in vec3 posv[];

void main() {
	vec3 dlen = vec3(
		length(posv[1] - posv[0]),
		length(posv[2] - posv[1]),
		length(posv[0] - posv[2]));
	if (dlen.x > .25 || dlen.y > .25 || dlen.z > .25)
	{
		return;
	}

	gl_Position = gl_in[0].gl_Position;
	texcoordg = texcoordv[0];
	EmitVertex();

	gl_Position = gl_in[1].gl_Position;
	texcoordg = texcoordv[1];
	if (texcoordv[1].x - texcoordv[0].x > .5) {
		texcoordg.x -= 1.;
	}
	if (texcoordv[1].x - texcoordv[0].x < -.5) {
		texcoordg.x += 1.;
	}
	EmitVertex();

	gl_Position = gl_in[2].gl_Position;
	texcoordg = texcoordv[2];
	if (texcoordv[2].x - texcoordv[0].x > .5) {
		texcoordg.x -= 1.;
	}
	if (texcoordv[2].x - texcoordv[0].x < -.5) {
		texcoordg.x += 1.;
	}
	EmitVertex();

	EndPrimitive();
}
]],
--]=]
			fragmentCode = template[[
in vec2 texcoordg;
out vec4 fragColor;

uniform float alpha;	// final alpha

void main() {
	fragColor = vec4(
		(texcoordg.x - .5) * 360.,// - .5
		(texcoordg.y - .5) * 180.,// - .5
		0.,
		1.
	);
}
]],
		},
		vertexes = self.vertexBuf,
		geometries = geometries,
		uniforms = {
			weight_Equirectangular = 1,
			weight_Azimuthal_equidistant = 0,
			weight_Mollweide = 0,
			weight_WGS84 = 0,
		},
	}
	--[[
	self.mouseLatLon = vec2f()
	--]]

	-- [=====[ BEGIN EARTHQUAKES
	self.latLonPointShader = GLProgram{
			version = 'latest',
			precision = 'best',
			vertexCode = template([[
layout(location=0) in vec2 vertex;	// texcoord in [-1,1]

// divisor attributes:
in vec3 latlonrad;	// lat, lon, mag
in uvec2 time;	// lo/hi timestamp 32bit int

out vec2 texcoordv;
flat out float deltaJDay;

uniform mat4 mvProjMat;
uniform bool chartIs3D;
uniform vec3 latlonroll0;
uniform float pointSize;
uniform uvec2 hiliteTime;

<?=chartCode?>

// compare two uint64_t's
int cmp(uvec2 a, uvec2 b) {
	if (a.y < b.y) return -1;
	if (a.y > b.y) return 1;
	if (a.x < b.x) return -1;
	if (a.x > b.x) return 1;
	return 0;
}

void main() {
	texcoordv = vertex;

	float alt = 1e+3;
	int c = cmp(time, hiliteTime);
	if (c < 0) {
		deltaJDay = -1.;
	} else if (c > 0) {
		deltaJDay = 1.;
	} else {
		deltaJDay = 0.;
		alt *= 2.;
	}

	vec2 latlonofs = applyLatLonRoll0(latlonrad.xy);

	vec3 coords = vec3(
		mod(latlonofs.x + 90., 180.) - 90.,	// lat in deg, [-90, 90]
		mod(latlonofs.y + 180., 360.) - 180.,	// lon in deg, [-180, 180]
		alt);				// height in meters

	vec3 pos = 0.
<? for _,name in ipairs(chartCNames) do
?>		+ weight_<?=name?> * chart_<?=name?>(coords)
<? end
?>	;
	pos /= WGS84_a;	//from meters to normalized coordinates

	if (chartIs3D) {
		pos = vec3(pos.z, pos.x, pos.y);
	}


	mat3 e = mat3(vec3(0.), vec3(0.), vec3(0.))
<? for _,name in ipairs(chartCNames) do
?>		+ weight_<?=name?> * chart_<?=name?>_basis(vec3(coords.xy, 0.))
<? end
?>	;
	float magn = latlonrad.z;
	pos += (vertex.x * e[0] + vertex.y * e[1]) * pointSize * magn;

	gl_Position = mvProjMat * vec4(pos, 1.);
}

]], 		{
				chartCode = chartCode,
				chartCNames = chartCNames,
			}),
			fragmentCode = [[
in vec2 texcoordv;
flat in float deltaJDay;

out vec4 fragColor;

uniform float alpha;

void main() {
	float lenSq = dot(texcoordv, texcoordv);
	if (lenSq > 1.) discard;
	if (deltaJDay == 0.) {
		fragColor = vec4(1., 1., 0., alpha);
	} else if (deltaJDay < 0.) {
		fragColor = vec4(1., 0., 0., alpha);
	} else { 	// if (deltaJDay > 0.) {
		fragColor = vec4(0., 1., 0., alpha);
	}
	if (lenSq > .9*.9) {
		fragColor = vec4(0., 0., 0., alpha);
	}
}
]],
		}:useNone()

	local billboardPointVtxBuf = GLArrayBuffer{
		dim = 2,
		usage = gl.GL_STATIC_DRAW,
		data = {-1, -1, 1, -1, -1, 1, 1, 1},
	}:unbind()

require 'vec-ffi.vec2i'	-- time
	self.earthquakeLatLonPointObj = GLSceneObject{
		program = self.latLonPointShader,
		vertexes = billboardPointVtxBuf,
		geometry = {
			mode = gl.GL_TRIANGLE_STRIP,
		},
		attrs = {
			latlonrad = {
				divisor = 1,
				buffer = {
					dim = 3,
					useVec = true,
				},
			},
			time = {
				divisor = 1,
				buffer = {
					dim = 2,
					useVec = true,
					ctype = 'vec2i_t',
				},
			},
		},
	}
	do
		local latlonradGPU = self.earthquakeLatLonPointObj.attrs.latlonrad.buffer
		local timeGPU = self.earthquakeLatLonPointObj.attrs.time.buffer
		local latlonradCPU = latlonradGPU:beginUpdate()
		local timeCPU = timeGPU:beginUpdate()
		for i,eq in ipairs(earthquakes) do
			-- latitude: S = negative, N = positive
			-- longitude: W = negative, E = positive
			latlonradCPU:emplace_back():set(
				eq.latitude,
				eq.longitude,
				eq.mag
			)
			timeCPU:emplace_back():set(
				tonumber(eq.ostime & 0xffffffffLL),
				tonumber((eq.ostime >> 32) & 0xffffffffLL)
			)
		end
		assert.eq(#latlonradCPU, #earthquakes)
		latlonradGPU:endUpdate()
		timeGPU:endUpdate()
		self.earthquakeLatLonPointObj.instanceCount = #latlonradCPU
	end

	-- TODO for this and earthquakeLatLonPointObj, use instances
	self.flaresLatLonPointObj = GLSceneObject{
		program = self.latLonPointShader,
		vertexes = billboardPointVtxBuf,
		geometry = {
			mode = gl.GL_TRIANGLE_STRIP,
		},
		attrs = {
			latlonrad = {
				divisor = 1,
				buffer = {
					dim = 3,
					useVec = true,
				},
			},
			time = {
				divisor = 1,
				buffer = {
					dim = 2,
					useVec = true,
					ctype = 'vec2i_t',
				},
			},
		},
	}
	do
		local latlonradGPU = self.flaresLatLonPointObj.attrs.latlonrad.buffer
		local timeGPU = self.earthquakeLatLonPointObj.attrs.time.buffer
		local latlonradCPU = latlonradGPU:beginUpdate()
		local timeCPU = timeGPU:beginUpdate()
		for i,f in ipairs(flares) do
			-- latitude: S = negative, N = positive
			-- longitude: W = negative, E = positive
			latlonradCPU:emplace_back():set(
				f.latitude,
				f.longitude,
				f.magn + 9	-- log10 watts, so A-class flare = -8
			)
			timeCPU:emplace_back():set(
				tonumber(f.ostime & 0xffffffffLL),
				tonumber((f.ostime >> 32) & 0xffffffffLL)
			)
		end
		assert.eq(#latlonradCPU, #flares)
		latlonradGPU:endUpdate()
		timeGPU:endUpdate()
		self.flaresLatLonPointObj.instanceCount = #latlonradCPU
	end

	local numCircleDivs = 200
	self.circlesObj = GLSceneObject{
		program = {
			version = 'latest',
			precision = 'best',
			vertexCode = template([[
layout(location=0) in float vertex;

in vec3 axis, axis2, axis3;	// axis dual = basis of circle
in vec3 color;	// base color
in float influence;	// additive influence,
in vec4 centerPos;	// .w = cos(centerAngle)

out vec3 posv;
out vec4 colorv;

uniform float declinationFromAxis;	// ... in radians
uniform float angleFade;	// how much to fade out from the centerPos / centerAngle

uniform mat4 mvProjMat;
uniform bool chartIs3D;
uniform vec3 latlonroll0;	// used for texturing, TODO FIXME proper 3d transform

<?=chartCode?>

void main() {
	float theta = vertex * 2. * M_PI;

	float decl = cos(declinationFromAxis);
	float phi_r = sin(declinationFromAxis);

	vec3 v = axis * decl + phi_r * (axis2 * cos(theta) + axis3 * sin(theta));
	float cosAngle = dot(v, centerPos.xyz);
	float alpha = clamp(cosAngle * centerPos.w + angleFade, 0., 1.);
	colorv = vec4(color * influence, alpha);

	vec2 latlon = cartesianToLatLonWGS84(v).xy;
	// ... to degrees
	latlon.x *= 180. / M_PI;	//[-90, 90]
	latlon.y *= 180. / M_PI;	//[-180, 180]

	vec2 latlonofs = applyLatLonRoll0(latlon);

	//////// BEGIN CODE MATCHING CHART CODE ABOVE
	vec3 coords = vec3(
		mod(latlonofs.x + 90., 180.) - 90.,	// lat in deg, [-90, 90]
		mod(latlonofs.y + 180., 360.) - 180.,	// lon in deg, [-180, 180]
		2e+3);						// height in meters

	vec3 pos = 0.
<? for _,name in ipairs(chartCNames) do
?>		+ weight_<?=name?> * chart_<?=name?>(coords)
<? end
?>	;

	//from meters to normalized coordinates
	pos /= WGS84_a;

	if (chartIs3D) {
		pos = vec3(pos.z, pos.x, pos.y);
	}
	posv = pos;
	gl_Position = mvProjMat * vec4(pos, 1.);
	//////// END CODE MATCHING CHART CODE ABOVE
}
]],			{
				chartCode = chartCode,
				chartCNames = chartCNames,
			}),

-- [=[ but really just don't use this, just cull the vertexes in the array buffer
-- then again, this does let me split up line loops.
			-- lets see if we can hide lines that loop from lon=-180 to lon=+180 and go across the equirectangular/mollweide/most 2D projections
			-- TODO I could use this for the circle tesselation to begin with.  just pass the angle + axis.
			-- TODO TODO once I do that, I could also just do the cartesian-to-wgs84 in the fragment, then apply the charts in the fragment.
			geometryCode = [[
layout (lines) in;
layout (line_strip, max_vertices = 2) out;

in vec4 colorv[];
in vec3 posv[];
out vec4 colorg;

void main() {
	float dlen = length(posv[1] - posv[0]);
	if (dlen > .25) {
		return;
	}

	gl_Position = gl_in[0].gl_Position;
	colorg = colorv[0];
	EmitVertex();

	gl_Position = gl_in[1].gl_Position;
	colorg = colorv[1];
	EmitVertex();

	EndPrimitive();
}
]],
--]=]
			fragmentCode = [[
in vec4 colorg;		// using geometry shader
//in vec4 colorv;	// not using geometry shader
out vec4 fragColor;
uniform float alpha;
void main() {
	fragColor = colorg;
	//fragColor = colorv;
	fragColor.a *= alpha;
}
]],
		},
		-- TODO geometry shader the resolution? or can they even spit out that many vertexes?
		vertexes = {
			dim = 1,
			usage = gl.GL_STATIC_DRAW,
			data = (|n| range(n):mapi(|i| (i-.5)/n))(numCircleDivs),
		},
		geometry = {
			mode = gl.GL_LINE_LOOP,
		},
		attrs = {
			axis = {
				divisor = 1,
				buffer = {
					dim = 3,
					useVec = true,
				},
			},
			axis2 = {
				divisor = 1,
				buffer = {
					dim = 3,
					useVec = true,
				},
			},
			axis3 = {
				divisor = 1,
				buffer = {
					dim = 3,
					useVec = true,
				},
			},
			color = {
				divisor = 1,
				buffer = {
					dim = 3,
					useVec = true,
				},
			},
			influence = {
				divisor = 1,
				buffer = {
					dim = 1,
					useVec = true,
				},
			},
			centerPos = {
				divisor = 1,
				buffer = {
					dim = 4,
					useVec = true,
				},
			},
		},
	}



	gl.glEnable(gl.GL_DEPTH_TEST)


	-- [=[ build here
	-- show axii of circles
	self.pairCrossPointsObj = GLSceneObject{
		-- TODO why not use the earthquake lat lon point obj program?
		program = {
			version = 'latest',
			precision = 'best',
			vertexCode = template([[
layout(location=0) in vec2 vertex;	// billboard texcoord in [-1,1]^2
in vec3 latlonheight;				// lat in deg, lon in deg, height in m

out vec2 texcoordv;

uniform mat4 mvMat;
uniform mat4 mvProjMat;
uniform bool chartIs3D;
uniform vec3 latlonroll0;
uniform float pointSize;
uniform float heightScale;

<?=chartCode?>

void main() {
	texcoordv = vertex;
	vec2 latlonofs = applyLatLonRoll0(latlonheight.xy);

	//////// BEGIN CODE MATCHING CHART CODE ABOVE
	vec3 coords = vec3(
		mod(latlonofs.x + 90., 180.) - 90.,	// lat in deg, [-90, 90]
		mod(latlonofs.y + 180., 360.) - 180.,	// lon in deg, [-180, 180]
		latlonheight.z * heightScale);							// height in meters

	vec3 pos = 0.
<? for _,name in ipairs(chartCNames) do
?>		+ weight_<?=name?> * chart_<?=name?>(coords)
<? end
?>	;
	pos /= WGS84_a;	//from meters to normalized coordinates

	if (chartIs3D) {
		pos = vec3(pos.z, pos.x, pos.y);
	}

#if 0	// use chart basis
	mat3 e = mat3(vec3(0.), vec3(0.), vec3(0.))
<? for _,name in ipairs(chartCNames) do
?>		+ weight_<?=name?> * chart_<?=name?>_basis(vec3(coords.xy, 0.))
<? end
?>	;
#else	// use modelview basis
	mat3 e = transpose(mat3(mvMat));
#endif
	pos += (vertex.x * e[0] + vertex.y * e[1]) * pointSize;

	gl_Position = mvProjMat * vec4(pos, 1.);
}
]],			{
				chartCode = chartCode,
				chartCNames = chartCNames,
			}),
			fragmentCode = [[
in vec2 texcoordv;

out vec4 fragColor;

void main() {
	float lenSq = dot(texcoordv, texcoordv);
	if (lenSq > 1.) discard;
	if (lenSq > .9*.9) {
		fragColor = vec4(0., 0., 0., 1.);
	} else {
		fragColor = vec4(1., 1., 1., 1.);
	}
}
]],
},
		geometry = {
			mode = gl.GL_TRIANGLE_STRIP,
		},
		vertexes = billboardPointVtxBuf,
		attrs = {
			latlonheight = {
				divisor = 1,
				buffer = {
					dim = 3,
					useVec = true,
				},
			},
		},
	}
	--]=]



	-- while we're here, let's compute the tidal and gravitational forces of our planets ...
	-- TODO take it from my solarsystem project where I'm already doing this
	-- but compute shader? does GL support double buffers? I don't think so . . .
	-- maybe I have to use OpenCL now

	self.clsize = {200,100}		-- or maybe "forceTexDim" or something
	self.clvolume = self.clsize[1] * self.clsize[2]
	self.env = CLEnv{
		verbose = true,
		useGLSharing = false,
		precision = 'double',
		-- TODO how about a getter-for-cmdline-obj ?
		--getPlatform = CLEnv.getterForIdent(cmdline.platform, 'platform'),
		--getDevices = CLEnv.getterForIdent(cmdline.device, 'device'),
		--deviceType = CLEnv.getDeviceTypeFromCmdLine(...),
		size = self.clsize,
	}

	self.calcTideAndGravProgram = self.env:program{
		code = template(
calcFlagsCode
..[[
real rad(real d) {
	return d * M_PI / 180.;
}

constant const real WGS84_a = 6378137.;		// m
constant const real WGS84_b = 6356752.3142;	// m @ polar radius
constant const real WGS84_esq = 1. - WGS84_b * WGS84_b / (WGS84_a * WGS84_a);
constant const real WGS84_e = <?=clnumber(WGS84_e)?>;//sqrt(WGS84_esq); ... but no constexpr in CL .c ... have to upgrade to clcpp but then you need to rope in spirv compiler ... too much drama ...
constant const real WGS84_flattening = 1. - WGS84_b / WGS84_a;
constant const real WGS84_inverseFlattening = 298.257223563;
constant const real WGS84_eccentricitySquared = (2. * WGS84_inverseFlattening - 1.) / (WGS84_inverseFlattening * WGS84_inverseFlattening);
constant const real gravitationalConstant = 6.6738480e-11;	// m^3 / (kg s^2)

real WGS84_calc_N(real sinTheta) {
	real denom = sqrt(1. - WGS84_eccentricitySquared * sinTheta * sinTheta);
	return WGS84_a / denom;
}

// how many copies of this do I need?
// This is the CL version to go with the GLSL version...
// I think I can gsub one to the other ...
real4 chart_WGS84(real4 latLonHeight) {
	real lat = latLonHeight.x;
	real lon = latLonHeight.y;
	real height = latLonHeight.z;

	real phi = rad(lon);		// spherical φ
	real theta = rad(lat);		// spherical inclination angle (not azumuthal θ)
	real cosTheta = cos(theta);
	real sinTheta = sin(theta);

	real N = WGS84_calc_N(sinTheta);

	real NPlusH = N + height;
	real4 y = (real4)(
		NPlusH * cosTheta * cos(phi),
		NPlusH * cosTheta * sin(phi),
		(N * (1. - WGS84_eccentricitySquared) + height) * sinTheta,
		0.
	);
	return y;
}

void chart_WGS84_basis(
	real4 latLonHeight,
	real4 *e_phi,
	real4 *e_theta,
	real4 *e_negR
) {
	real phi = rad(latLonHeight.x);
	real lambda = rad(latLonHeight.y);
	real height = latLonHeight.z;

	real cosLambda = cos(lambda);
	real sinLambda = sin(lambda);

	real cosPhi = cos(phi);
	real sinPhi = sin(phi);
	real dphi_cosPhi = -sinPhi;
	real dphi_sinPhi = cosPhi;

	real rCart = WGS84_a / sqrt(1. - WGS84_esq * sinPhi * sinPhi);
	real tmp = sqrt(1. - WGS84_esq * sinPhi * sinPhi);
	real dphi_rCart = WGS84_a / (tmp * tmp * tmp) * WGS84_esq * sinPhi * dphi_sinPhi;

	real rCart_over_a = 1. / sqrt(1. - WGS84_esq * sinPhi * sinPhi);

	real xp = (rCart + height) * cosPhi;
	real dphi_xp = dphi_rCart * cosPhi + (rCart + height) * dphi_cosPhi;
	real dheight_xp = cosPhi;

	real xp_over_a = (rCart_over_a + height / WGS84_a) * cosPhi;

	real zp = (rCart * (1. - WGS84_esq) + height) * sinPhi;
	real dphi_zp = (dphi_rCart * (1. - WGS84_esq)) * sinPhi + (rCart * (1. - WGS84_esq) + height) * dphi_sinPhi;
	real dheight_zp = sinPhi;

	real zp_over_a = (rCart_over_a * (1. - WGS84_esq) + height / WGS84_a) * sinPhi;

	real r2D = sqrt(xp * xp + zp * zp);
	real dphi_r2D = (xp * dphi_xp + zp * dphi_zp) / r2D;
	real dheight_r2D = (xp * dheight_xp + zp * dheight_zp) / r2D;

	real r2D_over_a = sqrt(xp_over_a * xp_over_a + zp_over_a * zp_over_a);
	real dphi_r2D_over_a = (xp_over_a * dphi_xp + zp_over_a * dphi_zp) / r2D;

	real sinPhiSph = zp / r2D;
	real dphi_sinPhiSph = (dphi_zp * r2D - zp * dphi_r2D) / (r2D * r2D);
	real dheight_sinPhiSph = (dheight_zp * r2D - zp * dheight_r2D) / (r2D * r2D);

	real cosPhiSph = sqrt(1. - sinPhiSph * sinPhiSph);
	//d/du sqrt(1 - x^2) = -x/sqrt(1 - x^2) dx/du;
	real dphi_cosPhiSph = -sinPhi / cosPhiSph * dphi_sinPhiSph;
	real dheight_cosPhiSph = -sinPhi / cosPhiSph * dheight_sinPhiSph;

	//real x = r2D * cosPhiSph / WGS84_a * cosLambda;
	//real y = r2D * cosPhiSph / WGS84_a * sinLambda;
	//real z = r2D * sinPhiSph / WGS84_a;

	real4 dphi = (real4)(
		(dphi_r2D_over_a * cosPhiSph + r2D_over_a * dphi_cosPhiSph) * cosLambda,
		(dphi_r2D_over_a * cosPhiSph + r2D_over_a * dphi_cosPhiSph) * sinLambda,
		(dphi_r2D_over_a * sinPhiSph + r2D_over_a * dphi_sinPhiSph),
		0.);

	real4 dlambda = (real4)(
		-sinLambda,
		cosLambda,
		0.,
		0.);

	real4 dheight = (real4)(
		(dheight_r2D * cosPhiSph + r2D * dheight_cosPhiSph) * cosLambda,
		(dheight_r2D * cosPhiSph + r2D * dheight_cosPhiSph) * sinLambda,
		(dheight_r2D * sinPhiSph + r2D * dheight_sinPhiSph),
		0.);

	// are these normalized? dlambda looks like it
	*e_phi = dphi;		// d/d latlon.x
	*e_theta = dlambda;	// d/d latlon.y
	*e_negR = -dheight;	// d/d latlon.z s.t. it forms a rhs basis
}


//returns magnitude g+m-2d
real4 calcGravityAccel(
	real4 posOnEarth, 			//relative to earth, in meters
	real4 planetPosRelEarth 	//relative to earth, in meters, w = mass in kg
) {
	real4 x = posOnEarth - planetPosRelEarth;
	x.w = 0.;
	real const r = length(x);
	real const planetMass = planetPosRelEarth.w;
	return x * (-planetMass * gravitationalConstant / (r * r * r));
}

//returns magnitude g+m-2d
real4 calcTidalAccel(
	real4 posOnEarth,
	real4 normal,
	real4 planetPosRelEarth
) {
	real4 x = posOnEarth - planetPosRelEarth;
	x.w = 0.;
	real const r = length(x);
	real const r2 = r * r;
	real const r3 = r * r2;
	real const xDotN = dot(x, normal);
	real const planetMass = planetPosRelEarth.w;
	return (x * (3. * xDotN / r2) - normal) * (gravitationalConstant * planetMass / r3);
}

real4 calcAccelAtPoint(
	real4 posOnEarth,
	real4 normal,
	global real4 * const planetPosRelEarth,
	int calcFlags
) {
	real4 accel = (real4)(0., 0., 0., 0.);

	for (int j = 0; j < <?=#Planets.planetClasses?>; ++j) {
	//for (int j = <?=Planets.indexes.earth-1?>; j <= <?=Planets.indexes.earth-1?>; ++j) {
		if (planetPosRelEarth[j].w > 0.) {
			if (calcFlags & calcFlags_calcTides) {
				real4 tideAccel = calcTidalAccel(posOnEarth, normal, planetPosRelEarth[j]);
				if ((calcFlags & calcFlags_calcTides) == calcFlags_calcTides) {
					accel += tideAccel;
				} else {
					real4 tideNormal = normal * dot(tideAccel, normal);
					real4 tideTangent = tideAccel - tideNormal;
					if (calcFlags & calcFlags_calcTidesVert) accel += tideNormal;
					if (calcFlags & calcFlags_calcTidesHorz) accel += tideTangent;
				}
			}
			if (calcFlags & calcFlags_calcGrav) {
				real4 gravAccel = calcGravityAccel(posOnEarth, planetPosRelEarth[j]);
				if ((calcFlags & calcFlags_calcGrav) == calcFlags_calcGrav) {
					accel += gravAccel;
				} else {
					real4 gravNormal = normal * dot(gravAccel, normal);
					real4 gravTangent = gravAccel - gravNormal;
					if (calcFlags & calcFlags_calcGravVert) accel += gravNormal;
					if (calcFlags & calcFlags_calcGravHorz) accel += gravTangent;
				}
			}
		}
	}

	if (calcFlags & calcFlags_calcCrossPos2D) {
		// why is this getting zeroes at the x and y axis ...
		accel = cross((real4)(posOnEarth.xy, 0., 0.), accel);	// torque = position cross accel
		// TODO what about velocity as well? going with vs against earth rotation?
	}
	if (calcFlags & calcFlags_calcCrossPos3D) {
		accel = cross(posOnEarth, accel);	// torque = position cross accel
		// TODO what about velocity as well? going with vs against earth rotation?
	}
	if (calcFlags & calcFlags_calcCrossVel) {
		real radsPerSec = 2. * M_PI / (1. - 1. / 365.25) / (60. * 60. * 24.);
		real4 velOnEarth = (real4)(
			radsPerSec * -posOnEarth.y,
			radsPerSec * posOnEarth.x,
			0.,
			0.
		);
		accel = cross(velOnEarth, accel);
	}

	return accel;
}

kernel void calcTideAndGrav(
	global real * const out,		// output[i] = force component specified
	global real4 const * const planetPosRelEarth,	// input positions[9] = (pos - earth.pos) x y z and mass = w
	int const calcFlags,
	int const display
) {
	initKernelForSize(<?=clsize[1]?>, <?=clsize[2]?>, 1);
	// index, x = longitude = east/west, y = latitude = north/south

	// lat lon, x = latitude = north/south, longitude = left/right
	real4 latlon = (real4)(
		(real)((i.y + .5) / <?=clnumber(clsize[2])?>) * 180. - 90.,
		(real)((i.x + .5) / <?=clnumber(clsize[1])?>) * 360. - 180.,
		0.,
		0.
	);

	real4 posOnEarth = chart_WGS84(latlon);

	real4 e_phi, e_theta, e_negR;
	chart_WGS84_basis(latlon, &e_phi, &e_theta, &e_negR);
	real4 e_r = -normalize(e_negR);
	e_theta = normalize(e_theta);
	e_phi = normalize(e_phi);

	// should I be using e_r or normalize(posOnEarth) ? or are they the same?
	//real4 normal = normalize(posOnEarth);
	real4 normal = e_r;

	//spherical coordinates, so theta goes from north pole to south pole, and phi goes around the earth
	real const rsurf = length(posOnEarth);
	real const sinTheta = length(posOnEarth.xy) / rsurf;
	real const dphi = <?=clnumber((2 * math.pi) / clsize[1])?>;
	real const dtheta = <?=clnumber(math.pi / clsize[2])?>;
	real const invdphi = <?=clnumber(clsize[1] / (2 * math.pi))?>;
	real const invdtheta = <?=clnumber(clsize[2] / math.pi)?>;

	real4 accel;
	if (calcFlags & calcFlags_calcRadialIntegral) {
		accel = (real4)(0., 0., 0., 0.);
		//if calcFlags_calcRadialIntegral then integrate ...
<?
local raddiv = 100
?>
		real const oneOverRadDiv = <?=clnumber(1 / raddiv)?>;
		real const dr = rsurf * oneOverRadDiv;
		real const sinTheta_dr_dtheta_dphi = sinTheta * dr * dtheta * dphi;
		for (int i = 0; i < <?=raddiv?>; ++i) {
			real const f = ((real)i + .5) * oneOverRadDiv;
			real const r = f * rsurf;
			real4 accelAtPt = calcAccelAtPoint(posOnEarth * f, normal, planetPosRelEarth, calcFlags);
			// TODO trapezoid integral across each face or something
			accel += accelAtPt * r * sinTheta_dr_dtheta_dphi;
		}
	} else {
		accel = calcAccelAtPoint(posOnEarth, normal, planetPosRelEarth, calcFlags);
	}

	// I'm breaking with chart input component convention and I'm putting r first here
	// so this is textbook math spherical basis convention of (r,theta,phi), not my geographic-chart convention of lat/lon/-height
	real4 accel_r_theta_phi = (real4)(
		dot(accel, e_r),
		dot(accel, e_theta),
		dot(accel, e_phi),
		0.
	);

	// TODO display components, not always length
	// x y z r theta phi xy xz yz rth rph thph
	switch (display) {
// 1D:
	case displayComponent_x:
		out[index] = accel.x;
		break;
	case displayComponent_y:
		out[index] = accel.y;
		break;
	case displayComponent_z:
		out[index] = accel.z;
		break;
	case displayComponent_r:
		out[index] = accel_r_theta_phi.x;
		break;
	case displayComponent_theta:
		out[index] = accel_r_theta_phi.y;
		break;
	case displayComponent_phi:
		out[index] = accel_r_theta_phi.z;
		break;

// 2D:
	case displayComponent_angle_xy:
		out[index] = atan2(accel.y, accel.x);
		break;
	case displayComponent_angle_yz:
		out[index] = atan2(accel.z, accel.y);
		break;
	case displayComponent_angle_zx:
		out[index] = atan2(accel.x, accel.z);
		break;
	case displayComponent_length_xy:
		out[index] = length(accel.xy);
		break;
	case displayComponent_length_yz:
		out[index] = length(accel.yz);
		break;
	case displayComponent_length_zx:
		out[index] = length(accel.zx);
		break;

	case displayComponent_angle_rtheta:
		out[index] = atan2(accel_r_theta_phi.y, accel_r_theta_phi.x);
		break;
	case displayComponent_angle_thetaphi:
		out[index] = atan2(accel_r_theta_phi.z, accel_r_theta_phi.y);
		break;
	case displayComponent_angle_phir:
		out[index] = atan2(accel_r_theta_phi.x, accel_r_theta_phi.z);
		break;
	case displayComponent_length_rtheta:
		out[index] = length(accel_r_theta_phi.xy);
		break;
	case displayComponent_length_thetaphi:
		out[index] = length(accel_r_theta_phi.yz);
		break;
	case displayComponent_length_phir:
		out[index] = length(accel_r_theta_phi.zx);
		break;

// 3D:
	case displayComponent_length_xyz:
		out[index] = length(accel);
		break;
	default:
		out[index] = -(float)0xdeadbeef;
		break;
	}
}

//if (calcFlags & calcFlags_calcSurfaceGradMagn) {
kernel void gradient(
	global real * const out,
	global real const * const in
) {
	initKernelForSize(<?=clsize[1]?>, <?=clsize[2]?>, 1);

	real4 latlon = (real4)(
		(real)((i.y + .5) / <?=clnumber(clsize[2])?>) * 180. - 90.,
		(real)((i.x + .5) / <?=clnumber(clsize[1])?>) * 360. - 180.,
		0.,
		0.
	);

	real4 posOnEarth = chart_WGS84(latlon);

	//spherical coordinates, so theta goes from north pole to south pole, and phi goes around the earth
	real const rsurf = length(posOnEarth);
	real const sinTheta = length(posOnEarth.xy) / rsurf;
	real const dphi = <?=clnumber((2 * math.pi) / clsize[1])?>;
	real const dtheta = <?=clnumber(math.pi / clsize[2])?>;
	real const invdphi = <?=clnumber(clsize[1] / (2 * math.pi))?>;
	real const invdtheta = <?=clnumber(clsize[2] / math.pi)?>;

	// spherical phi, not wgs84 phi ... smh
	int4 ixL = i;
	ixL.x = (ixL.x + <?=clsize[1]?> - 1) % <?=clsize[1]?>;
	int const index_xL = indexForInt4ForSize(ixL, <?=clsize[1]?>, <?=clsize[2]?>, 1);
	
	int4 ixR = i;
	ixR.x = (ixR.x + 1) % <?=clsize[1]?>;
	int const index_xR = indexForInt4ForSize(ixR, <?=clsize[1]?>, <?=clsize[2]?>, 1);
	
	int4 iyL = i;
	iyL.y--;
	if (iyL.y < 0) {
		iyL.y = 0;
		iyL.x = <?=clsize[1]?> - 1 - iyL.x;
	}
	int const index_yL = indexForInt4ForSize(iyL, <?=clsize[1]?>, <?=clsize[2]?>, 1);
	
	int4 iyR = i;
	iyR.y++;
	if (iyR.y >= <?=clsize[2]?>) {
		iyR.y = <?=clsize[2]-1?>;
		iyR.x = <?=clsize[1]?> - 1 - iyR.x;
	}		
	int const index_yR = indexForInt4ForSize(iyR, <?=clsize[1]?>, <?=clsize[2]?>, 1);

	real const f_xL = in[index_xL];
	real const f_xR = in[index_xR];
	real const f_yL = in[index_yL];
	real const f_yR = in[index_yR];
	
	real const df_dtheta = -(f_yR - f_yL) * invdtheta;
	real const df_dphi = (f_xR - f_xL) * invdphi;
	real const rSq = rsurf * rsurf;
	real const g_theta_theta = rSq;
	real const g_phi_phi = rSq * sinTheta * sinTheta;
	out[index] = sqrt(
		df_dphi * df_dphi * g_theta_theta
		+ df_dtheta * df_dtheta * g_phi_phi
	);
}

kernel void rescale(
	global float * const outv,
	global real const * const inv,
	real const minv,
	real const maxv
) {
	initKernelForSize(<?=clsize[1]?>, <?=clsize[2]?>, 1);
	outv[index] = (float)((inv[index] - minv) / (maxv - minv));
}

]],		{
			clsize = self.clsize,
			clnumber = clnumber,
			WGS84_e = math.sqrt(1. - charts.WGS84.b^2 / charts.WGS84.a^2),
			Planets = Planets,		-- whatever size the list the self.planetPosRelEarthBuffer is
		}),
	}

	self.calcTideAndGravProgram:compile()

	self.forceBuffer = self.env:buffer{name='forceBuffer', type='real'}
	self.dforceBuffer = self.env:buffer{name='dforceBuffer', type='real'}	-- for when you use gradients

	self.rescaleForceCPUBuf = vector('float', self.clvolume)
assert.len(self.rescaleForceCPUBuf, self.clvolume)
	self.rescaleForceBuffer = self.env:buffer{name='forceBuffer', type='float'}

	self.reduceBuffer = self.env:buffer{name='reduceBuffer', type='real'}
	self.reduceSwapBuffer = self.env:buffer{name='reduceSwapBuffer', type='real'}
	self.reduceResultPtr = ffi.new'real[1]'
	self.reduceResultPtr[0] = 0

	self.planetPosRelEarthCPUBuf = vector('real4', #Planets.planetClasses)
	self.planetPosRelEarthBuffer = self.env:buffer{
		name = 'planetPosRelEarthBuffer',
		type = 'real4',
		size = {#Planets.planetClasses},
	}	-- all planets, including earth, because maybe we want it too.

	self.calcTideAndGravKernel = self.calcTideAndGravProgram:kernel'calcTideAndGrav'
	self.calcTideAndGravKernel.obj:setArg(0, self.forceBuffer)
	self.calcTideAndGravKernel.obj:setArg(1, self.planetPosRelEarthBuffer)

	self.gradientKernel = self.calcTideAndGravProgram:kernel'gradient'
	self.gradientKernel.obj:setArg(0, self.dforceBuffer)
	self.gradientKernel.obj:setArg(1, self.forceBuffer)

	-- TODO instead of this, use GL sharing?
	self.rescaleKernel = self.calcTideAndGravProgram:kernel'rescale'
	self.rescaleKernel.obj:setArg(0, self.rescaleForceBuffer)
	self.rescaleKernel.obj:setArg(1, self.forceBuffer)

	self.reduceMin = self.env:reduce{
		count = self.clvolume,
		op = |x,y| 'min('..x..', '..y..')',
		initValue = 'INFINITY',
		buffer = self.reduceBuffer.obj,
		swapBuffer = self.reduceSwapBuffer.obj,
		result = self.reduceResultPtr,
	}

	self.reduceMax = self.env:reduce{
		count = self.clvolume,
		op = |x,y| 'max('..x..', '..y..')',
		initValue = '-INFINITY',
		buffer = self.reduceBuffer.obj,
		swapBuffer = self.reduceSwapBuffer.obj,
		result = self.reduceResultPtr,
	}

	local internalFormat = gl.GL_R32F
	local info = require 'gl.tex'.formatInfoForInternalFormat[internalFormat]
	self.forceTex = GLTex2D{
		width = self.clsize[1],
		height = self.clsize[2],
		magFilter = gl.GL_LINEAR,
		minFilter = gl.GL_LINEAR_MIPMAP_LINEAR,
		wrap = texWrap,
		internalFormat = info.internalFormat,
		format = info.format,
		type = info.types[1],
		data = self.rescaleForceCPUBuf.v,
	}:unbind()
	self.globeObj.texs[2] = self.forceTex
	self.gradientTex = GLGradientTex2D(
		256,
--[[ rainbow
		{
			{1,0,0,1},
			{1,1,0,1},
			{0,1,0,1},
			{0,1,1,1},
			{1,0,1,1},
		}
--]]
-- [[ sunset pic from https://blog.graphiq.com/finding-the-right-color-palettes-for-data-visualizations-fcd4e707a283#.inyxk2q43
-- also in efesoln-cl-lua
		table{
			vec3d(22,31,86),
			vec3d(34,54,152),
			vec3d(87,49,108),
			vec3d(156,48,72),
			vec3d(220,60,57),
			vec3d(254,96,50),
			vec3d(255,188,46),
			vec3d(255,255,55),
		}:mapi(|c| do
			local x,y,z = (c/255):unpack()
			--return table(x,y,z):append{1}
			return {x,y,z,1}
		end)
--]]
	):unbind()
	self.globeObj.texs[3] = self.gradientTex

	--[=[ redo this every time the screen size changes
	-- store color here
	local info = GLTex2D.formatInfoForInternalFormat[gl.GL_RGBA]
	self.colorFBOTex = GLTex2D{
		width = self.width,
		height = self.height,
		magFilter = gl.GL_LINEAR,
		minFilter = gl.GL_NEAREST,
		internalFormat = info.internalFormat,
		format = info.format,
		type = info.types[1],
	}:unbind()

	-- write out IDs when you render to this texture
	-- use it for click for detecting
	local info = GLTex2D.formatInfoForInternalFormat[gl.GL_R32UI]
	self.clickIDFBOTex = GLTex2D{
		width = self.width,
		height = self.height,
		magFilter = gl.GL_NEAREST,
		minFilter = gl.GL_NEAREST,
		internalFormat = info.internalFormat,
		format = info.format,
		type = info.types[1],
	}:unbind()

	self.fbo = GLFBO{
		width = self.width,
		height = self.height,
		useDepth = true,
	}
	-- can you just have 1 fbo overall, or do you need a different fbo per underlying type etc?
		:setColorAttachmentTex2D(self.colorFBOTex, 0)
		--:setColorAttachmentTex2D(self.clickIDFBOTex, 0)
		:unbind()
	--]=]

	--[[
	local info = GLTex2D.formatInfoForInternalFormat[gl.GL_RG32F]
	self.globeLatLonFBOTex = GLTex2D{
		width = self.width,
		height = self.height,
		magFilter = gl.GL_LINEAR,
		minFilter = gl.GL_NEAREST,
		internalFormat = info.internalFormat,
		format = info.format,
		type = info.types[1],
	}:unbind()
	fbo:bind()
		:setColorAttachmentTex2D(self.globeLatLonFBOTex, 0)
		:unbind()
	--]]

	self.trackEarthquakeIndexes = table()

	self:updateEarthquakeIndex()
end

-- refresh the list of what circles we want to display right now
-- this is either all circles in the last period (3 days? 1 day? etc)
-- or it is all that are touching the currently selected quake
App.refreshVisibleCircles = |:| do
	local eq = earthquakes[vars.earthquakeIndex]
	if vars.showOnlySelectedEarthquakeArcs then
		-- show all circles touching our currently selected
		circles = eq.touchingCircles:mapi(|t| t.circle)
	else
		-- show all circles touching any active earthquakes in the last timeframe
		-- TODO also include future window ... but also TODO should we show future earthquakes too?
		-- TODO earthquake window slider relative to the previous quake?
		local circleIndexes = table()
		for i=earthquakeWindowStartIndex,earthquakeWindowEndIndex do
			local cis = eq.circlesMadeByQuakes[i]
			if cis then
				for _,ci in ipairs(cis) do
					circleIndexes[ci] = true
				end
			end
		end
		circles = circleIndexes:keys():sort():mapi(|ci| eq.allCircles[ci])
	end

	-- invalidate track objs' min angle to selected earthquake, cuz they are based on 'circles'
	for _,track in ipairs(self.trackEarthquakeIndexes) do
		track.minAngle = nil
	end

	-- [[ update the circles
	do
		local axisGPU = self.circlesObj.attrs.axis.buffer
		local axisCPU = axisGPU:beginUpdate()
		local axis2GPU = self.circlesObj.attrs.axis2.buffer
		local axis2CPU = axis2GPU:beginUpdate()
		local axis3GPU = self.circlesObj.attrs.axis3.buffer
		local axis3CPU = axis3GPU:beginUpdate()
		local colorGPU = self.circlesObj.attrs.color.buffer
		local colorCPU = colorGPU:beginUpdate()
		local influenceGPU = self.circlesObj.attrs.influence.buffer
		local influenceCPU = influenceGPU:beginUpdate()
		local centerPosGPU = self.circlesObj.attrs.centerPos.buffer
		local centerPosCPU = centerPosGPU:beginUpdate()

		for _,c in ipairs(circles) do
			axisCPU:emplace_back():set(c.axis:unpack())
			axis2CPU:emplace_back():set(c.axis2:unpack())
			axis3CPU:emplace_back():set(c.axis3:unpack())
			local t1 = earthquakes[c.indexes[1]].ostime
			local t2 = earthquakes[c.indexes[2]].ostime
			local tavg = (t1 + t2) >> 1
			if tavg < eq.ostime then
				colorCPU:emplace_back():set(c.color.x, 0, 0)
			else
				colorCPU:emplace_back():set(0, c.color.y, 0)
			end
			influenceCPU:emplace_back()[0] = c.influence
			centerPosCPU:emplace_back():set(
				c.centerPos.x,
				c.centerPos.y,
				c.centerPos.z,
				1. / math.cos(c.centerAngle)
			)
		end

		self.circlesObjInstanceCount = #axisCPU

		-- last, make room for each planet, for each angle, for if we draw it
		local earthPos = eq.planets[Planets.indexes.earth].pos
		for _,planetClass in ipairs(drawPlanetClasses) do
			for _,declAngle in ipairs(drawPlanetAngles) do
				local planetPos = eq.planets[Planets.indexes[planetClass.name]].pos
				local planetDir = (planetPos - earthPos):normalize()
				local axis2 = basisFor(planetDir)
				local axis3 = planetDir:cross(axis2)
				axisCPU:emplace_back():set(planetDir:unpack())
				axis2CPU:emplace_back():set(axis2:unpack())
				axis3CPU:emplace_back():set(axis3:unpack())
				colorCPU:emplace_back():set(table.unpack(planetClass.color))
				influenceCPU:emplace_back()[0] = 1
				centerPosCPU:emplace_back():set(0,0,0,1)
			end
		end

		axisGPU:endUpdate()
		axis2GPU:endUpdate()
		axis3GPU:endUpdate()
		colorGPU:endUpdate()
		influenceGPU:endUpdate()
		centerPosGPU:endUpdate()
	end
	--]]

	-- TODO FIXME where are these points going?
	-- [=[ now that we've refreshed the circles, refresh our torque axis points too
	do
		local sceneObj = self.pairCrossPointsObj
		local latlonheightGPU = sceneObj.attrs.latlonheight.buffer
		local latlonheightCPU = latlonheightGPU:beginUpdate()
--print('building points from ',#circles, 'circles')
		for _,c in ipairs(circles) do
			local torque = c.axis * c.axisLen
			-- hmm proper torque would be based on radius from earth ... so consider depth?
			-- hmmmmm
			-- if points are 180' or if they are next to each other then we want no infuence ...
			-- ... .maybe I souldn't nrmlize with the cross produt ...
			-- and then I should look at the point-cloud of the axis' ...
			for s=-1,1,2 do
				local x,y,z = (s * torque):unpack()
				--z,x,y = x,y,z	-- hmm ...
				-- and cartesianToLatLonWGS84 scales it up by WGS84.a ... hmm why
				local phi, lambda, height = cartesianToLatLonWGS84(x,y,z)
--print(x,y,z,phi,lambda)
				latlonheightCPU:emplace_back():set(
					(math.deg(phi) + 90) % 180 - 90,
					(math.deg(lambda) + 180) % 360 - 180,
					height	--  in meters
				)
			end
		end
		latlonheightGPU:endUpdate()
		sceneObj.geometry.instanceCount = #latlonheightCPU
	end
	--]=]
end

--[[
this represents Rz(heading) * Ry(pitch) * Rx(bank) * v
seems to be equivalent to my "applyLatLonRoll0Inv" which might not be an inverse after all
--]]
local eulerToQuat = |lat, lon, roll|do
	lat = math.rad(lat)
	lon = math.rad(lon)
	roll = math.rad(roll)
	local pitch = -lat
	local yaw = lon
	roll = -roll

    local cr = math.cos(roll * .5)
    local sr = math.sin(roll * .5)
    local cp = math.cos(pitch * .5)
    local sp = math.sin(pitch * .5)
    local cy = math.cos(yaw * .5)
    local sy = math.sin(yaw * .5)

    local q = quatd()
    q.w = cr * cp * cy + sr * sp * sy
    q.x = sr * cp * cy - cr * sp * sy
    q.y = cr * sp * cy + sr * cp * sy
    q.z = cr * cp * sy - sr * sp * cy

    return q
end
local quatToEuler = |q|do
    -- roll (x-axis rotation)
    local sinr_cosp = 2 * (q.w * q.x + q.y * q.z)
    local cosr_cosp = 1 - 2 * (q.x * q.x + q.y * q.y)
    local roll = math.atan2(sinr_cosp, cosr_cosp)

    -- pitch (y-axis rotation)
    local sinp = math.sqrt(1 + 2 * (q.w * q.y - q.x * q.z))
    local cosp = math.sqrt(1 - 2 * (q.w * q.y - q.x * q.z))
    local pitch = 2 * math.atan2(sinp, cosp) - math.pi * .5

    -- yaw (z-axis rotation)
    local siny_cosp = 2 * (q.w * q.z + q.x * q.y)
    local cosy_cosp = 1 - 2 * (q.y * q.y + q.z * q.z)
    local yaw = math.atan2(siny_cosp, cosy_cosp)

	local lat = -pitch
	local lon = yaw
	roll = -roll
	lat = math.deg(lat)
	lon = math.deg(lon)
	roll = math.deg(roll)
	return lat, lon, roll
end

local drapPath = path'goes_drap'
drapPath:mkdir()
local nextDrapCheckTime = timer.getTime() - 1
App.update = |:| do
	gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT)

	local eq = earthquakes[vars.earthquakeIndex]

-- [[
	self.totalLikelihood = self.totalLikelihood or 1
	self.oddsTrue = self.oddsTrue or 0
	self.oddsFalse = self.oddsFalse or 0
	-- TODO this is the odds of 2 (or more) matching.  we should calc the odds of the number of matches that we actually got.
	local probsForEqSetSize = require 'birthday-problem'[calcCircles.quakeAlignWithPreviousGeodesicAngleThreshold]
	if probsForEqSetSize then
		if not eq.probabilityOfFindingAnyGeodesic then
			local numQuakesInWindow = earthquakeWindowEndIndex - earthquakeWindowStartIndex + 1
			eq.probabilityOfFindingAnyGeodesic = probsForEqSetSize[numQuakesInWindow] or 1
			print(
				eq.probabilityOfFindingAnyGeodesic
				..' = odds of finding a geodesic within '..calcCircles.quakeAlignWithPreviousGeodesicAngleThreshold
				..'° (i.e. '
				..(360/calcCircles.quakeAlignWithPreviousGeodesicAngleThreshold)
				..' partitions) from '..numQuakesInWindow
				..' possible quakes, and we found '
				..#eq.touchingCircles
			)
			if #eq.touchingCircles > 0 then
				self.totalLikelihood *= eq.probabilityOfFindingAnyGeodesic
				self.oddsTrue += 1
			else
				self.totalLikelihood *= 1 - eq.probabilityOfFindingAnyGeodesic
				self.oddsFalse += 1
			end
			--print('...running total likelihood = '..self.totalLikelihood)	-- TODO i think this odds is the order-dependent odds of events happening, but I should be looking at order-independence or something, idk, i hate probability and statistics
			print('...so far we have found geodesics '..self.oddsTrue..' of '..(self.oddsTrue + self.oddsFalse)..' times = '..(self.oddsTrue / (self.oddsTrue + self.oddsFalse)))
		end
	end
--]]

	if vars.recenterOnQuake then
--[[ LERP - and all the coordinate problems that go with it
		vars.lat0 = math.mix(vars.lat0, vars.targetlat0, vars.latlonroll0convergeRate)
		vars.lon0 = math.mix(vars.lon0, vars.targetlon0, vars.latlonroll0convergeRate)
		vars.roll0 = math.mix(vars.roll0, vars.targetroll0, vars.latlonroll0convergeRate)
--]]
-- [[ SLERP ... involves some converting to and from euler angles and quaternions ...
		local q1 = eulerToQuat(vars.lat0, vars.lon0, vars.roll0)
		local q2 = eulerToQuat(vars.targetlat0, vars.targetlon0, vars.targetroll0)
		if math.abs(q1:dot(q2)) > .99999 then
			vars.lat0 = vars.targetlat0
			vars.lon0 = vars.targetlon0
			vars.roll0 = vars.targetroll0
		else
			local q = quatd():slerp(q1, q2, vars.latlonroll0convergeRate)
			vars.lat0, vars.lon0, vars.roll0 = quatToEuler(q)
		end
--]]
	end

	-- while we're here, try to remotely download & cache the DRAP image
	-- https://services.swpc.noaa.gov/images/animations/d-rap/global/d-rap/SWX_DRAP20_C_SWPC_20250607030500_GLOBAL.png
	-- check every frame or will that slow us down?
	if vars.showDrapTex
	and timer.getTime() > nextDrapCheckTime
	then
		nextDrapCheckTime = timer.getTime() + 1
--DEBUG:print('checking eq.drapTex', type(eq.drapTex), eq.drapTex)
		if type(eq.drapTex) == 'table' then
--DEBUG:print('...has texture')
		else
			local cacheName = ('%04d-%02d-%02d_%02d:%02d:%02d'):format(
				eq.date.year, eq.date.month, eq.date.day, eq.date.hour, eq.date.min, eq.date.sec)
			local p = drapPath/(cacheName..'.png')

			if p:exists() then
print(cacheName..' exists...')
print("our current state:", eq.drapTex)
				if eq.drapTex == 'loading' then
print('loading, checking pid for finished...')
					local done = not os.exec('kill -0 '..eq.drapTexWGetPID..' > /dev/null 2>&1')	-- ... or wget request and pid kill -0 test errors aka the pid is done
print('kill -0 failed, i.e. done?', done)
					if done then
						eq.drapTex = 'done'	-- finished loading
					end
				end

				if eq.drapTex == nil		-- if we never loaded i.e. chcking cache ...
				or eq.drapTex == 'done'		-- or if we just finished loading ...
				then
print('pid is done, checking file size...')
					-- then the process must have ended ...
					if p:attr().size == 0 then
print('file size is zero - error?')
						-- then something went wrong (also we could test for process exit code but then you'd have to write that somewhere upon exit ...)
						eq.drapTex = 'failed'
					else
print('file size is valid, done?')
					end
				end

				if eq.drapTex == nil		-- file exists and no loading was done
				or eq.drapTex == 'done' 	-- loading is finished
				then
				-- TODO not here, but wait until the wget pid finishes ....
--DEBUG:print("...exists, loading")
					eq.drapTex = GLTex2D{
						image = Image(p.path)
							:copy{x=12, y=9, width=689-12, height=338-9}
							:rgba(),
						magFilter = gl.GL_LINEAR,
						minFilter = gl.GL_NEAREST,
						wrap = texWrap,
					}:unbind()
				end
			else
print(cacheName.." doesn't exist...")
			end

			if eq.drapTex == nil then	-- didn't load but havne't tried to load ... then try to load
print("...hasn't been dl'd, dl'ing...")
				eq.drapTex = 'loading'	-- don't load twice
				local fn = ('%04d%02d%02d%02d%02d00'):format(
					eq.date.year, eq.date.month, eq.date.day, eq.date.hour, eq.date.min)
				os.exec('wget https://services.swpc.noaa.gov/images/animations/d-rap/global/d-rap/SWX_DRAP20_C_SWPC_'..fn..'_GLOBAL.png -O '..p..' & echo $! > pid')
				eq.drapTexWGetPID = path'pid':read():trim()
				path'pid':remove()
			-- else it should be 'loading' or 'failed'
			end
		end
	end

	if vars.drawEarth then
		local sceneObj = self.globeObj
		if type(eq.drapTex) == 'table' then
			sceneObj.texs[4] = eq.drapTex
		else
			sceneObj.texs[4] = nil
		end
		for _,name in ipairs(weightFields) do
			sceneObj.uniforms[name] = vars[name]
		end
		sceneObj.uniforms.latlonroll0 = {vars.lat0, vars.lon0, vars.roll0}
		sceneObj.uniforms.chartIs3D = false	-- this is just whether to swap x y and z around , z = along view vs z = north pole
		sceneObj.uniforms.mvProjMat = self.view.mvProjMat.ptr
		sceneObj.uniforms.forceTexAlpha = vars.forceTexAlpha
		sceneObj.uniforms.drapTexAlpha = vars.showDrapTex and vars.drapTexAlpha or 0
		sceneObj:draw()
	end

	do
		gl.glLineWidth(vars.lineWidth)
		--gl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE)
		gl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE_MINUS_SRC_ALPHA)
		gl.glEnable(gl.GL_BLEND)
		gl.glDepthMask(0)

		local sceneObj = self.circlesObj
		for _,name in ipairs(weightFields) do
			sceneObj.uniforms[name] = vars[name]
		end
		sceneObj.uniforms.declinationFromAxis = .5 * math.pi
		sceneObj.uniforms.latlonroll0 = {vars.lat0, vars.lon0, vars.roll0}
		sceneObj.uniforms.angleFade = vars.angleFade
		sceneObj.uniforms.chartIs3D = false	-- this is just whether to swap x y and z around , z = along view vs z = north pole
		sceneObj.uniforms.mvProjMat = self.view.mvProjMat.ptr
		sceneObj.uniforms.alpha = vars.greatArcAlpha
		if vars.drawGreatArcs then
			sceneObj.geometry.instanceCount = self.circlesObjInstanceCount
			sceneObj:draw()
		end
		gl.glDisable(gl.GL_BLEND)
		if vars.drawAnyPlanets then
			sceneObj.geometry.instanceCount = 1
			gl.glLineWidth(3)
			sceneObj.uniforms.angleFade = 1
			local earthPos = eq.planets[Planets.indexes.earth].pos
			for planetClassIndex,planetClass in ipairs(drawPlanetClasses) do
				if vars.drawPlanets[planetClass.name] then
					for declAngleIndex,declAngle in ipairs(drawPlanetAngles) do
						if vars.drawPlanetAngles[declAngle] then
							sceneObj.uniforms.declinationFromAxis = math.rad(declAngle)
							sceneObj.geometry.instanceOffset = self.circlesObjInstanceCount
								+ (declAngleIndex - 1)
								+ (planetClassIndex - 1) * #drawPlanetAngles
							sceneObj:draw()
						end
					end
				end
			end
			sceneObj.geometry.instanceCount = nil
			sceneObj.geometry.instanceOffset = nil
		end
		gl.glDepthMask(1)
		gl.glLineWidth(1)
	end

	if vars.drawEarthquakes then
		gl.glDepthFunc(gl.GL_LEQUAL)
		local sceneObj = self.earthquakeLatLonPointObj
		for _,name in ipairs(weightFields) do
			sceneObj.uniforms[name] = vars[name]
		end
		sceneObj.uniforms.latlonroll0 = {vars.lat0, vars.lon0, vars.roll0}
		sceneObj.uniforms.chartIs3D = false	-- this is just whether to swap x y and z around , z = along view vs z = north pole
		sceneObj.uniforms.mvProjMat = self.view.mvProjMat.ptr
		sceneObj.uniforms.pointSize = vars.earthquakePointSize
		sceneObj.uniforms.alpha = 1

		sceneObj.uniforms.hiliteTime = {
			tonumber(eq.ostime & 0xffffffffLL),
			tonumber((eq.ostime >> 32) & 0xffffffffLL)
		}

		sceneObj.geometry.instanceOffset = earthquakeWindowStartIndex - 1
		sceneObj.geometry.instanceCount = earthquakeWindowEndIndex - earthquakeWindowStartIndex + 1
		sceneObj:draw()
		sceneObj.geometry.instanceOffset = nil
		sceneObj.geometry.instanceCount = nil
		gl.glDepthFunc(gl.GL_LESS)
	end

	if vars.drawFlares then
		gl.glDepthFunc(gl.GL_LEQUAL)
		gl.glEnable(gl.GL_BLEND)
		gl.glDepthMask(0)
		local sceneObj = self.flaresLatLonPointObj
		for _,name in ipairs(weightFields) do
			sceneObj.uniforms[name] = vars[name]
		end
		sceneObj.uniforms.latlonroll0 = {vars.lat0, vars.lon0, vars.roll0}
		sceneObj.uniforms.chartIs3D = false	-- this is just whether to swap x y and z around , z = along view vs z = north pole
		sceneObj.uniforms.mvProjMat = self.view.mvProjMat.ptr
		sceneObj.uniforms.pointSize = vars.flarePointSize
		sceneObj.uniforms.alpha = .2

		sceneObj.uniforms.hiliteTime = {
			tonumber(eq.ostime & 0xffffffffLL),
			tonumber((eq.ostime >> 32) & 0xffffffffLL)
		}

		-- TODO also color the flares different or something

		sceneObj.geometry.instanceOffset = flareWindowStartIndex - 1
		sceneObj.geometry.instanceCount = flareWindowEndIndex - flareWindowStartIndex + 1
		sceneObj:draw()
		sceneObj.geometry.instanceOfffset = nil
		sceneObj.geometry.instanceCount = nil
		gl.glDepthMask(1)
		gl.glDisable(gl.GL_BLEND)
		gl.glDepthFunc(gl.GL_LESS)
	end

	-- [=[ TODO show torque axii of circle geodesics
	if vars.drawAxisCloud then
		local sceneObj = self.pairCrossPointsObj
		if sceneObj.geometry.instanceCount > 0 then
			for _,name in ipairs(weightFields) do
				sceneObj.uniforms[name] = vars[name]
			end
			sceneObj.uniforms.latlonroll0 = {vars.lon0, vars.lat0, vars.roll0}
			sceneObj.uniforms.chartIs3D = false	-- this is just whether to swap x y and z around , z = along view vs z = north pole
			sceneObj.uniforms.mvMat = self.view.mvMat.ptr
			sceneObj.uniforms.mvProjMat = self.view.mvProjMat.ptr
			sceneObj.uniforms.pointSize = vars.axisCloudPointSize
			sceneObj.uniforms.heightScale = vars.axisCloudHeightScale

			sceneObj:draw()
		end
	end
	--]=]


	App.super.update(self)

	-- while we're here...
	-- ... re-download the latest day's earthquakes
	local t = time()
	if t > checkTime + checkDuration then
		checkTime = t
		local newTodaysEarthquakes, changed = getDayCache(t, true)
		if changed then
			print(os.date(), 'TODO upate me plz')
		end
	end

	glreport'here'
end

App.updateEarthquakeIndex = |:| do
	vars.earthquakeIndex = math.clamp(math.round(vars.earthquakeIndex), 1, #earthquakes)

	-- invalidate track objs' min angle to selected earthquake
	for _,track in ipairs(self.trackEarthquakeIndexes) do
		track.minAngle = nil
	end

	-- TODO redo circle' touchingindexes to scan both + and - in time by 1 day
	self:calcQuakeWindowIndexes()
	self:refreshForceBuffer()

	if vars.recenterOnQuake then
		self:recenterOnQuake()
	end
end

App.recenterOnQuake = |:|do
	local eq = earthquakes![vars.earthquakeIndex]
	-- ok this will put our quake at center for Equirectangular ... and maybe spherical and wgs84 ...
	-- but for Azimuthal I'll need to offset lat0 by 90' ...
	-- so that means our recenter will need offsets which will need to be linearly weighted by the chart parameters
	-- But adding this means I gotta call "recenterOnQuake" when the chart weights change ...
	-- TODO make an azimuthal with an extra 90' rotate lat that puts 0' lat lon in the middle, so that the center is in the center,
	--  then the need for this var will go away and roll will work.
	local chartLat0 = vars.weight_Azimuthal_equidistant * 90
	vars.targetlat0 = eq.latitude - chartLat0
	vars.targetlon0 = eq.longitude
end

App.refreshForceBuffer = |:|do
--DEBUG:print'refreshing force buffer'
	local eq = earthquakes![vars.earthquakeIndex]
	local earthPos = eq.planets[Planets.indexes.earth].pos
	for i,p in ipairs(eq.planets) do
		local v = eq.planets[i].pos - earthPos
		local pos = self.planetPosRelEarthCPUBuf.v + (i-1)
		pos.x = v.x
		pos.y = v.y
		pos.z = v.z
		pos.w = vars.calcPlanets[p.name] and p.mass or 0
--DEBUG:print('planet', i, 'name', p.name, 'mass', pos.w)
	end
	self.planetPosRelEarthBuffer:fromCPU(self.planetPosRelEarthCPUBuf.v)

	self.calcTideAndGravKernel.obj:setArg(2, int(0
		| (vars.calcTidesVert and ffi.C.calcFlags_calcTidesVert or 0)
		| (vars.calcTidesHorz and ffi.C.calcFlags_calcTidesHorz or 0)
		| (vars.calcGravVert and ffi.C.calcFlags_calcGravVert or 0)
		| (vars.calcGravHorz and ffi.C.calcFlags_calcGravHorz or 0)
		| (vars.calcCrossPos2D and ffi.C.calcFlags_calcCrossPos2D or 0)
		| (vars.calcCrossPos3D and ffi.C.calcFlags_calcCrossPos3D or 0)
		| (vars.calcCrossVel and ffi.C.calcFlags_calcCrossVel or 0)
		| (vars.calcRadialIntegral and ffi.C.calcFlags_calcRadialIntegral or 0)
		| (vars.calcSurfaceGradMagn and ffi.C.calcFlags_calcSurfaceGradMagn or 0)
	))
	self.calcTideAndGravKernel.obj:setArg(3, int(vars.displayComponent))
	self.calcTideAndGravKernel()

	if vars.calcSurfaceGradMagn then
		self.gradientKernel()

		-- now I could swap forceBuffer and dforceBuffer ... and reassign all the kernels that forceBuffer is assigned to ...
		-- or just copy
		self.forceBuffer:copyFrom(self.dforceBuffer)
	end

	self.forceMin = self.reduceMin(self.forceBuffer.obj)
	self.forceMax = self.reduceMax(self.forceBuffer.obj)

	self.rescaleKernel.obj:setArg(2, double(self.forceMin))
	self.rescaleKernel.obj:setArg(3, double(self.forceMax))
	self.rescaleKernel()

	self.rescaleForceBuffer:toCPU(self.rescaleForceCPUBuf.v)
	self.forceTex
		:bind()
		:subimage()
		:generateMipmap()
		:unbind()
end

App.event = |:,e| do
	App.super.event(self, e)
	if not ig.igGetIO()[0].WantCaptureKeyboard then
		if e[0].type == sdl.SDL_EVENT_KEY_DOWN then
			if e[0].key.key == sdl.SDLK_LEFT then
				vars.earthquakeIndex -= 1
				self:updateEarthquakeIndex()
			elseif e[0].key.key == sdl.SDLK_RIGHT then
				vars.earthquakeIndex += 1
				self:updateEarthquakeIndex()
			end
		end
	end
	--[[
	if not ig.igGetIO()[0].WantCaptureMouse then
		if e[0].type == sdl.SDL_EVENT_MOUSE_MOTION then
			-- find coordinate closest to mouse / re-render the chart with the chart coordinate underneath and pick it
			self.fbo:bind()
			self.fbo.check()
			gl.glClear(bit.bor(gl.GL_COLOR_BUFFER_BIT, gl.GL_DEPTH_BUFFER_BIT))

			local sceneObj = self.latLonGlobeObj
			for _,name in ipairs(weightFields) do
				sceneObj.uniforms[name] = vars[name]
			end
			sceneObj.uniforms.latlonroll0 = {vars.lat0, vars.lon0, vars.roll0}
			sceneObj.uniforms.chartIs3D = false	-- this is just whether to swap x y and z around , z = along view vs z = north pole
			sceneObj.uniforms.mvProjMat = self.view.mvProjMat.ptr
			sceneObj:draw()

			local mx, my = e[0].motion.x, e[0].motion.y
			gl.glReadPixels(mx, my, 1, 1, self.globeLatLonFBOTex.format, self.globeLatLonFBOTex.type, self.mouseLatLon.s)
			self.fbo:unbind()

			-- TODO find closest earthquake here?  or draw it to the buffer and pick it?
			-- in fact, I could bind the first color buffer and a second ID buffer, do one render for both, and just query the IDs here ... hmm ...
			-- and then we only need to draw upon mouse move/click callback

		--elseif e[0].type == sdl.SDL_EVENT_MOUSE_DOWN then
			-- look for closest quake
		end
	end
	--]]
end

local inputFloat=|l,t,k|
	--ig.luatableInputFloat(l, t, k)
	--ig.luatableInputFloatAsText(l, t, k)
	ig.luatableInputFloatAsText(l, t, k, ig.ImGuiInputTextFlags_EnterReturnsTrue)

App.updateGUI = |:| do
	local eq = earthquakes[vars.earthquakeIndex]
	ig.igSetNextWindowBgAlpha(.3)
	ig.igPushStyleColor_U32(ig.ImGuiCol_MenuBarBg, 0)
	if ig.igBeginMainMenuBar() then
		if ig.igBeginMenu'quakes:' then

			local changed
			local oldEarthquakeIndex = vars.earthquakeIndex
			changed = ig.luatableSliderFloat('earthquakeIndex s', vars, 'earthquakeIndex', 1, #earthquakes)
			changed = ig.luatableInputInt('earthquakeIndex t', vars, 'earthquakeIndex', 1, #earthquakes) or changed
			if changed then
				vars.earthquakeIndex ??= oldEarthquakeIndex	-- if we got bad input then don't crash
				self:updateEarthquakeIndex()
			end

			ig.igText('earthquake time = '..eq.time)
			ig.igText('earthquake julian day = '..eq.julianDay)
			ig.igText('earthquake magn = '..eq.mag)	-- TODO just a side panel or pop up that shows all the earthquake stats
			ig.igText('earthquake depth = '..eq.depth..' km')	-- TODO incorporate this into the display somehow ...
			ig.igText('earthquake place = '..eq.place)
			ig.igText('earthquake latitude = '..eq.latitude)
			ig.igText('earthquake longitude = '..eq.longitude)
			ig.igText('earthquake window start time = '..earthquakes[earthquakeWindowStartIndex].time)
			ig.igText('earthquake window end time = '..earthquakes[earthquakeWindowEndIndex].time)
			ig.igText('earthquake window start index = '..earthquakeWindowStartIndex)
			ig.igText('earthquake window end index = '..earthquakeWindowEndIndex)
			local numQuakesInWindow = earthquakeWindowEndIndex - earthquakeWindowStartIndex + 1
			ig.igText('earthquakes in window = '..numQuakesInWindow)

			local probsForEqSetSize = require 'birthday-problem'[calcCircles.quakeAlignWithPreviousGeodesicAngleThreshold]
			if probsForEqSetSize then
				ig.igText(
					(probsForEqSetSize[numQuakesInWindow] or 1)
					..' = odds of finding a geodesic within '..calcCircles.quakeAlignWithPreviousGeodesicAngleThreshold
					..'° (i.e. '
					..(360/calcCircles.quakeAlignWithPreviousGeodesicAngleThreshold)
					..' partitions) from '..numQuakesInWindow..' possible quakes'
				)
			end

			-- hr --
			ig.igText('flares in window = '..(flareWindowEndIndex == 0 and 0 or (flareWindowEndIndex - flareWindowStartIndex + 1)))
			ig.igText('flare window start time = '..flares[flareWindowStartIndex].time)
			ig.igText('flare window end time = '..flares[flareWindowEndIndex].time)
			ig.igText('flare window start index = '..flareWindowStartIndex)
			ig.igText('flare window end index = '..flareWindowEndIndex)


			ig.igEndMenu()
		end
		if ig.igBeginMenu'options:' then
			ig.luatableCheckbox('ortho', self.view, 'ortho')
			if ig.igButton'reset view' then
				self.view.ortho = true
				self.view.orthoSize = self.viewOrthoSize
				self.view.angle:set(0,0,0,1)
				self.view.orbit:set(0,0,0)
				self.view.pos:set(0,0,self.viewDist)
			end
			ig.luatableCheckbox('draw earth', vars, 'drawEarth')
			ig.luatableCheckbox('draw earthquakes', vars, 'drawEarthquakes')
			inputFloat('earthquakePointSize', vars, 'earthquakePointSize')

			ig.luatableCheckbox('draw great arcs', vars, 'drawGreatArcs')
			ig.luatableSliderFloat('great arc alpha', vars, 'greatArcAlpha', 0, 1)
			ig.luatableSliderFloat('lineWidth', vars, 'lineWidth', 0, 20)
			inputFloat('angleFade', vars, 'angleFade')

			ig.luatableCheckbox('draw flares', vars, 'drawFlares')
			inputFloat('flarePointSize', vars, 'flarePointSize')

			ig.igText'force calcs:'
			ig.igSameLine()
			if ig.luatableTooltipCheckbox('calcTidesVert', vars, 'calcTidesVert') then
				self:refreshForceBuffer()
			end
			ig.igSameLine()
			if ig.luatableTooltipCheckbox('calcTidesHorz', vars, 'calcTidesHorz') then
				self:refreshForceBuffer()
			end
			ig.igSameLine()
			if ig.luatableTooltipCheckbox('calcGravVert', vars, 'calcGravVert') then
				self:refreshForceBuffer()
			end
			ig.igSameLine()
			if ig.luatableTooltipCheckbox('calcGravHorz', vars, 'calcGravHorz') then
				self:refreshForceBuffer()
			end
			ig.igSameLine()
			if ig.luatableTooltipCheckbox('calcCrossPos2D', vars, 'calcCrossPos2D') then
				self:refreshForceBuffer()
			end
			ig.igSameLine()
			if ig.luatableTooltipCheckbox('calcCrossPos3D', vars, 'calcCrossPos3D') then
				self:refreshForceBuffer()
			end
			ig.igSameLine()
			if ig.luatableTooltipCheckbox('calcCrossVel', vars, 'calcCrossVel') then
				self:refreshForceBuffer()
			end
			ig.igSameLine()
			if ig.luatableTooltipCheckbox('calcRadialIntegral', vars, 'calcRadialIntegral') then
				self:refreshForceBuffer()
			end
			ig.igSameLine()
			if ig.luatableTooltipCheckbox('calcSurfaceGradMagn', vars, 'calcSurfaceGradMagn') then
				self:refreshForceBuffer()
			end

			ig.igText('force min='..self.forceMin..' max='..self.forceMax)
			ig.luatableSliderFloat('forceTexAlpha', vars, 'forceTexAlpha', 0, 1)

			ig.igText'Calc Planets: '
			for _,planetClass in ipairs(calcPlanetClasses) do
				ig.igSameLine()
				if ig.luatableTooltipCheckbox('calc '..planetClass.name, vars.calcPlanets, planetClass.name) then
					self:refreshForceBuffer()
				end
			end

			if ig.luatableCombo('displayComponent', vars, 'displayComponent', displayComponentNames) then
				self:refreshForceBuffer()
			end

			ig.luatableCheckbox('drawAnyPlanets', vars, 'drawAnyPlanets')
			for _,planetClass in ipairs(drawPlanetClasses) do
				ig.igSameLine()
				ig.luatableTooltipCheckbox('draw '..planetClass.name, vars.drawPlanets, planetClass.name)
			end
			ig.igText'Show Planet Angles: '
			for _,angle in ipairs(drawPlanetAngles) do
				ig.igSameLine()
				ig.luatableTooltipCheckbox('at angle '..angle, vars.drawPlanetAngles, angle)
			end
			inputFloat('julianBaseAngle', require 'time', 'julianBaseAngle')

			ig.luatableCheckbox('showDrapTex', vars, 'showDrapTex')
			ig.luatableSliderFloat('drapTexAlpha', vars, 'drapTexAlpha', 0, 1)

			if ig.luatableCheckbox('showOnlySelectedEarthquakeArcs', vars, 'showOnlySelectedEarthquakeArcs') then
				self:refreshVisibleCircles()
			end

			ig.luatableCheckbox('drawAxisCloud', vars, 'drawAxisCloud')
			inputFloat('axisCloudPointSize', vars, 'axisCloudPointSize')
			inputFloat('axisCloudHeightScale', vars, 'axisCloudHeightScale')

			ig.igEndMenu()
		end
		if ig.igBeginMenu'chart:' then

			ig.luatableCheckbox('normalize weights', vars, 'normalizeWeights')
			local changed
			for _,field in ipairs(weightFields) do
				if ig.luatableSliderFloat(field, vars, field, 0, 1) then
					changed = field
				end
			end
			if changed then
				self:recenterOnQuake()
			end
			if vars.normalizeWeights and changed then
				local restFrac = 1 - vars[changed]
				local totalRest = 0
				for _,field in ipairs(weightFields) do
					if field ~= changed then
						totalRest = totalRest + vars[field]
					end
				end
				for _,field in ipairs(weightFields) do
					if field ~= changed then
						if totalRest == 0 then
							vars[field] = 0
						else
							vars[field] = restFrac * vars[field] / totalRest
						end
					end
				end
			end

			if ig.luatableCheckbox('recenterOnQuake', vars, 'recenterOnQuake') then
				self:recenterOnQuake()
			end
			ig.luatableSliderFloat('lat0', vars, 'lat0', -180, 180)
			ig.luatableSliderFloat('lon0', vars, 'lon0', -180, 180)
			ig.luatableSliderFloat('roll0', vars, 'roll0', -180, 180)
			ig.luatableSliderFloat('latlonroll0convergeRate', vars, 'latlonroll0convergeRate', 0, 1)

			ig.igEndMenu()
		end
		if ig.igBeginMenu'circles:' then

			ig.igText('# all geodesics through selected quake = '..#eq.allCircles)

			if inputFloat('greatArcAngleMin', calcCircles, 'greatArcAngleMin') then
				self:invalidateCachedQuakeArcs()
				self:calcQuakeWindowIndexes()
			end
			if inputFloat('greatArcAngleMax', calcCircles, 'greatArcAngleMax') then
				self:invalidateCachedQuakeArcs()
				self:calcQuakeWindowIndexes()
			end
			if inputFloat('quakeAlignWithPreviousGeodesicAngleThreshold', calcCircles, 'quakeAlignWithPreviousGeodesicAngleThreshold') then
				self:invalidateCachedQuakeArcs()
				self:calcQuakeWindowIndexes()
			end
			if inputFloat('filterDuplicateTouchingArcsAngleThreshold', calcCircles, 'filterDuplicateTouchingArcsAngleThreshold') then
				self:invalidateCachedQuakeArcs()
				self:calcQuakeWindowIndexes()
			end
			if inputFloat('filterDuplicatePointsAngleThreshold', calcCircles, 'filterDuplicatePointsAngleThreshold') then
				self:invalidateCachedQuakeArcs()
				self:calcQuakeWindowIndexes()
			end
			if inputFloat('prevTimeWindowInDays', calcCircles, 'prevTimeWindowInDays') then
				self:invalidateCachedQuakeArcs()
				self:calcQuakeWindowIndexes()
			end
			if inputFloat('nextTimeWindowInDays', calcCircles, 'nextTimeWindowInDays') then
				self:invalidateCachedQuakeArcs()
				self:calcQuakeWindowIndexes()
			end

			ig.igEndMenu()
		end

		if ig.igBeginMenu('touching '..#eq.touchingCircles) then
			for i,t in ipairs(eq.touchingCircles) do
				ig.igPushID_Int(i)
				local c = t.circle
				local i1, i2 = table.unpack(c.indexes)
				local eq1 = earthquakes[i1]
				local eq2 = earthquakes[i2]
				ig.igText(i..':')
				ig.igSameLine()
				-- TODO tooltipButton text is always nothing so
				local click = ig.igButton('#'..i1)
				ig.hoverTooltip(eq1.place)
				if click then
					vars.earthquakeIndex = i1
					self:updateEarthquakeIndex()
				end
				ig.igSameLine()
				ig.igText'->'
				ig.igSameLine()
				local click = ig.igButton('#'..i2)
				ig.hoverTooltip(eq2.place)
				if click then
					vars.earthquakeIndex = i2
					self:updateEarthquakeIndex()
				end

				ig.igSameLine()
				ig.igText(t.angleFromArcInDeg..'° from arc.   3 Points are at angles: '
					..table{
						math.deg(t.circle.centerAngle * 2),
						math.deg(math.acos(eq1.xyznorm:dot(eq.xyznorm))),
						math.deg(math.acos(eq2.xyznorm:dot(eq.xyznorm))),
					}:sort():mapi(tostring):concat', '
				)


				ig.igPopID()
			end

			ig.igEndMenu()
		end
		if ig.igBeginMenu'angles:' then	-- angles to planets or other objects

			local earthPos = eq.planets[Planets.indexes.earth].pos
			for _,cl in ipairs(drawPlanetClasses) do	-- planets without earth (nan angle) and EM_Bary (same angle as moon)
				local planetIndex = Planets.indexes[cl.name]
				local planet = eq.planets[planetIndex]
				local planetDir = (planet.pos - earthPos):normalize()
				ig.igText('3D angle: '..math.deg(math.acos(
					eq.xyznorm:dot(planetDir)
				))..'°, 2D angle: '..math.deg(
					((math.atan2(planetDir.y, planetDir.x) - math.atan2(eq.xyznorm.y, eq.xyznorm.x) + math.pi) % (2 * math.pi)) - math.pi
				)..'°, angle to closest touching geodesic: '
					..eq.minAngleForPlanets[planetIndex]
				..'° | '..planet.name)
			end

			if inputFloat('trackEarthquakeIndex', vars, 'trackEarthquakeIndex') then
				self.trackEarthquakeIndexes:insert{
					index = vars.trackEarthquakeIndex,
				}
			end

			ig.igPushID_Str'trackEarthquakeIndexes_list'
			for ii,track in ipairs(self.trackEarthquakeIndexes) do
				local eq2 = earthquakes[track.index]
				if not track.minAngle then
					-- find the min angle from this track object to our current selected earthquake
					track.minAngle = 180
					for _,c in ipairs(circles) do
						local cosAngleFromAxis = c.axis:dot(eq2.xyznorm)	-- cos angle from axis = sine angle from plane
						local angleFromAxis = math.acos(cosAngleFromAxis)
						local angleFromArc = angleFromAxis - .5 * math.pi
						local angleFromArcInDeg = math.abs(math.deg(angleFromArc))	-- will be 0 to 90
						--planetAngleFromGeodesics[pi][math.ceil(angleFromArc)] += 1
						track.minAngle = math.min(track.minAngle, angleFromArcInDeg)
					end
				end

				ig.igPushID_Int(ii)

				local dobreak
				if ig.igButton'x' then
					self.trackEarthquakeIndexes:remove(ii)
					dobreak = true	-- can't break until popid or imgui will crap itself
				end

				ig.igSameLine()

				ig.igText('3D angle: '..math.deg(math.acos(
					eq.xyznorm:dot(eq2.xyznorm)
				))..'°, 2D angle: '..math.deg(
					((math.atan2(eq2.xyznorm.y, eq2.xyznorm.x) - math.atan2(eq.xyznorm.y, eq.xyznorm.x) + math.pi) % (2 * math.pi)) - math.pi
				)..'°, angle to closest touching geodesic: '
					..track.minAngle..'° | '..eq2.place)

				ig.igPopID()
				if dobreak then break end
			end
			ig.igPopID()

			ig.igEndMenu()
		end
		if ig.igBeginMenu('| #'..vars.earthquakeIndex
			..', mag='..eq.mag
			..', depth='..eq.depth..' km'
			..', place='..eq.place
			..', time='..eq.time) then
			ig.igEndMenu()
		end
		ig.igEndMainMenuBar()
	end
	ig.igPopStyleColor(1)

--[=[
	local bestEq
	local bestDistSq = math.huge
	for _,eq in ipairs(earthquakes) do
		-- TODO feedback of where quakes are being rendered, instead of lat lon dist
		local distSq = (eq.latitude - self.mouseLatLon.x)^2 + (eq.longitude - self.mouseLatLon.y)^2
		if bestDistSq > distSq then
			bestDistSq = distSq
			bestEq = eq
		end
	end
	if bestEq then
		ig.igBeginTooltip()
		ig.igText('earthquake time = '..bestEq.time)
		ig.igText('earthquake julian day = '..bestEq.julianDay)
		ig.igText('earthquake magn = '..bestEq.mag)	-- TODO just a side panel or pop up that shows all the earthquake stats
		ig.igText('earthquake depth = '..bestEq.depth..' km')	-- TODO incorporate this into the display somehow ...
		ig.igText('earthquake place = '..bestEq.place)
		ig.igText('earthquake latitude = '..bestEq.latitude)
		ig.igText('earthquake longitude = '..bestEq.longitude)
		ig.igEndTooltip()
	end
--]=]
end

return App():run()
