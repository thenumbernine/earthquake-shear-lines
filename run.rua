#!/usr/bin/env rua
local template = require 'template'
local sdl = require 'sdl'
local gl = require 'gl'
local Image = require 'image'
local GLSceneObject = require 'gl.sceneobject'
local GLArrayBuffer = require 'gl.arraybuffer'
local GLProgram = require 'gl.program'
local GLGeometry = require 'gl.geometry'
local GLTex2D = require 'gl.tex2d'
local GLGradientTex2D = require 'gl.gradienttex2d'
local GLFBO = require 'gl.fbo'
local GLGlobal = require 'gl.global'
local glreport = require 'gl.report'
local ig = require 'imgui'
local vec2f = require 'vec-ffi.vec2f'
local vec2d = require 'vec-ffi.vec2d'
local vec3d = require 'vec-ffi.vec3d'
local quatd = require 'vec-ffi.quatd'
local vector = require 'ffi.cpp.vector-lua'

local CLEnv = require 'cl.obj.env'
local clnumber = require 'cl.obj.number'

local Planets = require 'solarsystem.planets'
local Julian = require 'solarsystem.julian'

local basisFor = require 'basis'.basisFor

local charts = require 'charts'.charts
local chartCode = require 'charts'.chartCode
local chartCNames = require 'charts'.chartCNames
local cartesianToLatLonWGS84 = require 'charts'.cartesianToLatLonWGS84

local getDayCache = require 'earthquakes'.getDayCache
local checkTime = require 'earthquakes'.checkTime
local earthquakes = require 'earthquakes'.earthquakes
local checkDuration = 60*5	-- re-check every 5 mins

local flares = require 'flares'
local dayInSec = require 'basis'.dayInSec

local calcCircles = require 'circles'

local time = timer.time
local timegm = timer.timegm
local gmtime = timer.gmtime

--[[ me doing some calcs:
1) get all circles across all earthquakes
2) find all within a 3rd earthquake within an angle tolerance of 0.1 or whatever... honestly try 1 or 3 or 5 now.
3) look at distribution of angles that quakes strike at.
--]]


local intptr = ffi.new'int[1]'
local int = |x| do intptr[0] = x return intptr end

local doubleptr = ffi.new'double[1]'
local double = |x| do doubleptr[0] = x return doubleptr end

for _,name in ipairs(chartCNames) do
	chartCode ..= '\nuniform float weight_'..name..';'
end

chartCode ..= [[

//////// BEGIN GLSL THAT'S ALSO IN MY EARTH MAGNETIC FIELD MODEL CODE
// ported from WMM2020 GeomagnetismLibrary.c
// expects xyz in cartesian units earth-semimajor-axis
// output is in (radians, radians, km)
// TODO just use charts.WGS84:chartInv(x,y,z) ?  or use this there?
vec3 cartesianToLatLonWGS84(vec3 pos) {
	// lowercase WGS84_a is in km, uppercase WGS84_a is in m ... i know i need to fix this ...
	pos *= WGS84_a;	// convert from semimajor-axis units to m
	float modified_b = pos.z < 0. ? -WGS84_b : WGS84_b;
	float r = length(pos.xy);

	float e = (modified_b * pos.z - (WGS84_a * WGS84_a - modified_b * modified_b)) / (WGS84_a * r);
	float f = (modified_b * pos.z + (WGS84_a * WGS84_a - modified_b * modified_b)) / (WGS84_a * r);
	float p = (4. / 3.) * (e * f + 1.);
	float q = 2. * (e * e - f * f);
	float d = p * p * p + q * q;

	float v;
	if  (d >= 0.) {
		v = pow(sqrt(d) - q, 1./3.) - pow(sqrt(d) + q, 1./3.);
	} else {
		v = 2. * sqrt(-p) * cos(acos(q / (p * sqrt(-p))) / 3.);
	}

	if (v * v < abs(p)) {
		v = -(v * v * v + 2. * q) / (3. * p);
	}

	float g = (sqrt(e * e + v) + e) / 2.;
	float t = sqrt(g * g + (f - v * g) / (2. * g - e)) - g;

	float phi = atan((WGS84_a * (1. - t * t)) / (2. * modified_b * t));	// latitude

	float height = (r - WGS84_a * t) * cos(phi) + (pos.z - modified_b) * sin(phi);
	float lambda = atan(pos.y, pos.x);	// longitude
	lambda += M_PI;
	lambda = mod(lambda, 2. * M_PI);
	lambda -= M_PI;
	// longitude = lambda = range of [-pi, pi]
	return vec3(phi, lambda, height);
}
//////// END GLSL THAT'S ALSO IN MY EARTH MAGNETIC FIELD MODEL CODE

vec2 vec2exp(float rad) {
	return vec2(cos(rad), sin(rad));
}

vec3 rotateX(vec3 v, float rad) {
	vec2 cs = vec2exp(rad);
	return vec3(
		v.x,
		v.y * cs.x - v.z * cs.y,
		v.y * cs.y + v.z * cs.x);
}

vec3 rotateY(vec3 v, float rad) {
	vec2 cs = vec2exp(rad);
	return vec3(
		v.x * cs.x + v.z * cs.y,
		v.y,
		-v.x * cs.y + v.z * cs.x);
}

vec3 rotateZ(vec3 v, float rad) {
	vec2 cs = vec2exp(rad);
	return vec3(
		v.x * cs.x - v.y * cs.y,
		v.x * cs.y + v.y * cs.x,
		v.z);
}

// hmm, floating point accuracy issue ...
vec2 applyLatLonRoll0(vec2 latlon) {
#if 0 // wgs84
	vec3 pos = chart_WGS84(vec3(latlon, 0.));
	return cartesianToLatLonWGS84(pos / WGS84_a).xy * (180. /  M_PI);
#else // sphere
	vec3 pos = chart_sphere(vec3(latlon, 0.));
	pos.xyz = pos.zxy;

	vec2 latcs = vec2exp(latlonroll0.x * M_PI / 180.);
	vec2 loncs = vec2exp(latlonroll0.y * M_PI / 180.);
	vec2 rollcs = vec2exp(latlonroll0.z * M_PI / 180.);
	pos = rotateZ(pos, -latlonroll0.y * M_PI / 180.);	// heading / yaw
	pos = rotateY(pos, latlonroll0.x * M_PI / 180.);	// pitch / inclination
	pos = rotateX(pos, latlonroll0.z * M_PI / 180.);	// bank / roll

	// chartInv_sphere expects north pole to be z+, prime meridian to be x+
	pos.zxy = pos.xyz;
	return chartInv_sphere(pos).xy;
#endif
}

// hmm, floating point accuracy issue ...
vec2 applyLatLonRoll0Inv(vec2 latlon) {
#if 0 // wgs84
	vec3 pos = chart_WGS84(vec3(latlon, 0.));
	return cartesianToLatLonWGS84(pos / WGS84_a).xy * (180. /  M_PI);
#else // sphere
	vec3 pos = chart_sphere(vec3(latlon, 0.));
	pos.xyz = pos.zxy;

	vec2 latcs = vec2exp(latlonroll0.x * M_PI / 180.);
	vec2 loncs = vec2exp(latlonroll0.y * M_PI / 180.);
	vec2 rollcs = vec2exp(latlonroll0.z * M_PI / 180.);

	pos = rotateX(pos, -latlonroll0.z * M_PI / 180.);	// bank / roll
	pos = rotateY(pos, -latlonroll0.x * M_PI / 180.);	// pitch / inclination
	pos = rotateZ(pos, latlonroll0.y * M_PI / 180.);	// heading / yaw

	// chartInv_sphere expects north pole to be z+, prime meridian to be x+
	pos.zxy = pos.xyz;
	return chartInv_sphere(pos).xy;
#endif
}


]]

local drawPlanetClasses = table.filter(Planets.planetClasses, |c| c.name ~= 'earth' and c.name ~= 'EM_Bary')
-- should I do some geometry-index stuff too or nah?
local drawPlanetAngles = table{
	1, 5, 15, 30, 45, 60, 90, 120, 135, 150, 175, 179
}

-- this is only used for the ui, while the CL planetPos list has all of them, so that I can indivivdually index into it or something idk
local calcPlanetClasses = table.filter(Planets.planetClasses, |c| c.name ~= 'EM_Bary')

local displayComponentNames = table{
	'x',
	'y',
	'z',
	'r',
	'θ',
	'φ',
	'∠xy',
	'∠yz',
	'∠zx',
	'|xy|',
	'|yz|',
	'|zx|',
	'∠rθ',
	'∠θφ',
	'∠φr',
	'|rθ|',
	'|θφ|',
	'|φr|',
	'|xyz|',
}
displayComponentCNames = displayComponentNames:mapi(|name|
	'displayComponent_'..name
		:gsub('θ', 'theta')
		:gsub('φ', 'phi')
		:gsub('∠', 'angle_')
		:gsub('|(.*)|', 'length_%1')
)

local calcFlagsCode = [[
enum {
	calcFlags_calcTidesVert = 1,
	calcFlags_calcTidesHorz = 2,
	calcFlags_calcTides = calcFlags_calcTidesVert | calcFlags_calcTidesHorz,
	calcFlags_calcGravVert = 4,
	calcFlags_calcGravHorz = 8,
	calcFlags_calcGrav = calcFlags_calcGravVert | calcFlags_calcGravHorz,
	calcFlags_calcCrossPos2D = 16,
	calcFlags_calcCrossPos3D = 32,
	calcFlags_calcCrossVel = 64,
	calcFlags_calcRadialIntegral = 128,	// integrates previous result in spherical coordinates
	calcFlags_calcSurfaceGradMagn = 256,	// takes previous result, does df/dθ and df/dφ in spherical, calcs magnitude using spherical metric of diag(r^2, r^2 sin(θ)^2)
};
enum {
	]]..displayComponentCNames:mapi(|v,i| v..' = '..i):concat',\n\t'..',\n'..[[
};
]]
ffi.cdef(calcFlagsCode)

local weightFields = chartCNames:mapi(|name| 'weight_'..name)
local vars = table(
	weightFields:mapi(|name| (name == 'weight_Equirectangular' and 1 or 0, name)),
	{
		showOnlySelectedEarthquakeArcs = true ,	-- true = show only selected earthquake circle, false = show all
		normalizeWeights = true,
		drawEarth = true,
		drawEarthquakes = true,
		earthquakePointSize = .005,		-- but make it proportional to size in view maybe? like USGS does?
		drawGreatArcs = true,
		greatArcAlpha = .1,
		lineWidth = 1,
		angleFade = 1,
		drawFlares = true,
		flarePointSize = .005,
		forceTexAlpha = .5,

		showDrapTex = false,		-- keep it off by default for now ... it works but it adds too many moving pieces
		drapTexAlpha = .5,

		calcTidesVert = false,
		calcTidesHorz = false,
		calcGravVert = true,
		calcGravHorz = false,
		calcCrossPos2D = false,	-- cross force with moment arm
		calcCrossPos3D = false,	-- cross force with position (incl z along axis)
		calcCrossVel = false,
		calcRadialIntegral = false,	-- integrate along earth radius parameter from core to surface
		calcSurfaceGradMagn = false,

		displayComponent = #displayComponentNames,

		drawAnyPlanets = true,
		drawPlanets = drawPlanetClasses:mapi(|c|(
			true, 		-- draw all
			--c.name == 'sun' or c.name == 'moon',	-- only draw sun and moon
			c.name
		)),	-- drawPlanets[name] = true
		calcPlanets = table.mapi(Planets.planetClasses, |c|(
			c.name == 'sun' or c.name == 'moon' or c.name == 'earth',
			c.name
		)),	-- calcPlanets[name] = true
		drawPlanetAngles = drawPlanetAngles:mapi(|x|(
			x == 1 or x == 5 or x == 179,
			x
		)),
		drawAxisCloud = false,	-- only really useful if you are looking at/ analyzing data in 3D spherical/WGS84 chart view
		axisCloudPointSize = .02,
		axisCloudHeightScale = -1,
		lat0 = 0,		-- degrees
		lon0 = -155,	-- degrees
		roll0 = 0,		-- degrees
		targetlat0 = 0,
		targetlon0 = -155,
		targetroll0 = 0,
		latlonroll0convergeRate = 0.1,	-- what coefficient to converge every frame
		recenterOnQuake = false,
		earthquakeIndex = #earthquakes,

		trackEarthquakeIndex = -1,
	}
):setmetatable(nil)


local App = require 'imgui.appwithorbit'()
App.title = 'Earthquake Geodesics'
App.viewDist = 2

local earthquakeWindowStartIndex
local earthquakeWindowEndIndex
local flareWindowStartIndex = 0
local flareWindowEndIndex = 0
App.calcQuakeWindowIndexes = |:|do
	-- TODO with bisect
	local windowStartTime = earthquakes[vars.earthquakeIndex].ostime - calcCircles.prevTimeWindowInDays * dayInSec
	local windowEndTime = earthquakes[vars.earthquakeIndex].ostime + calcCircles.nextTimeWindowInDays * dayInSec

	earthquakeWindowStartIndex = vars!.earthquakeIndex
	for i=vars.earthquakeIndex,1,-1 do
		if earthquakes[i].ostime < windowStartTime then break end
		earthquakeWindowStartIndex = i
	end
	earthquakeWindowEndIndex = vars!.earthquakeIndex
	for i=vars.earthquakeIndex,#earthquakes do
		if earthquakes[i].ostime > windowEndTime then break end
		earthquakeWindowEndIndex = i
	end

	if #flares > 0 then
		flareWindowStartIndex = #flares
		for i=#flares,1,-1 do
			if flares[i].ostime < windowStartTime then break end
			flareWindowStartIndex = i
		end
		flareWindowEndIndex = flareWindowStartIndex
		for i=flareWindowStartIndex,#flares do
			if flares![i]!.ostime > windowEndTime then break end
			flareWindowEndIndex = i
		end
	end

	local eq = earthquakes![vars.earthquakeIndex]
	if not eq.touchingCircles then
		-- this function will compute eq.touchingCircles
		--and return the window's "allCircles", which I will store here
		-- now reclaculate all circles within our window
		calcCircles.calcCircles(earthquakes, vars.earthquakeIndex, earthquakeWindowStartIndex, earthquakeWindowEndIndex)

		-- should this be based on what quakes are within 60' and caused me to flag the geodesic?
		-- or should this be on what quakes are subsequently within 1' or 5' or so of that geodesic after-the-fact?
		-- doing the former first ...
		eq.circlesMadeByQuakes = {}
		for ci,c in ipairs(eq.allCircles) do
			for _,i in ipairs(c.indexes) do
				eq.circlesMadeByQuakes[i] ??= table()
				eq.circlesMadeByQuakes[i]:insert(ci)
			end
		end
	end
	self:refreshVisibleCircles()	-- TODO don't recalc all circles, just recalc indexes used
end

-- if we change a quake search parameter then delete all the cached arcs
App.invalidateCachedQuakeArcs = |:|do
	for _,eq in ipairs(earthquakes) do
		eq.allCircles = nil
		eq.touchingCircles = nil
		eq.circlesMadeByQuakes = nil
	end

-- [[ trying to calculate odds
	self.totalLikelihood = nil
	self.oddsTrue = nil
	self.oddsFalse = nil
	for _,eq in ipairs(earthquakes) do
		eq.probabilityOfFindingAnyGeodesic = nil
	end
--]]
end


local texWrap = {
	s = gl.GL_REPEAT,
	--t = gl.GL_CLAMP_TO_EDGE,
	t = gl.GL_CLAMP_TO_BORDER,
}

App.viewOrthoSize = 1.1
App.initGL = |:| do
	App.super.initGL(self)

	local billboardPointVtxBuf = GLArrayBuffer{
		dim = 2,
		usage = gl.GL_STATIC_DRAW,
		data = {-1, -1, 1, -1, -1, 1, 1, 1},
	}:unbind()

	self.view.ortho = true
	self.view.orthoSize = self.viewOrthoSize
	-- [=====[ BEGIN CLIP FROM GEOGRAPHIC-CHARTS
	local vertexes = table()
	local idivs = 100
	local jdivs = 200
	for i=0,idivs do
		local u = i/idivs
		--local phi = math.rad((u * 2 - 1) * 90)
		for j=0,jdivs do
			local v = j/jdivs
			--local lambda = math.rad((v * 2 - 1) * 180)
			vertexes:insert(u * 180 - 90)	-- lat, lon = u, v
			vertexes:insert(v * 360 - 180) -- transposed from texcoord space in texcoord space
		end
	end
	self.vertexBuf = GLArrayBuffer{
		data = vertexes,
		dim = 2,
	}:unbind()

	local geometries = table()
	for jbase=0,jdivs-1 do
		local indexes = table()
		for i=0,idivs do
			for jofs=1,0,-1 do
				local j = jbase + jofs
				indexes:insert(j + (jdivs + 1) * i)
			end
		end
		geometries:insert(GLGeometry{
			mode = gl.GL_TRIANGLE_STRIP,
			indexes = {
				data = indexes,
			},
			vertexes = self.vertexBuf,
		})
	end

	self.globeObj = GLSceneObject{
		program = {
			version = 'latest',
			precision = 'best',
			vertexCode = template([[
layout(location=0) in vec2 vertex;
out vec2 texcoordv;
out vec3 posv;

uniform mat4 mvProjMat;
uniform bool chartIs3D;
uniform vec3 latlonroll0;

<?=chartCode?>

void main() {
	vec2 latlonofs = applyLatLonRoll0Inv(vertex);

	//(lat, lon) in [0, 1]
	texcoordv = vec2(
		latlonofs.y / 360. + .5,
		latlonofs.x / 180. + .5
	);

	vec3 coords = vec3(
		mod(vertex.x + 90., 180.) - 90.,	// lat in deg, [-90, 90]
		mod(vertex.y + 180., 360.) - 180.,	// lon in deg, [-180, 180]
		0.);						// height in meters

	vec3 pos = 0.
<? for _,name in ipairs(chartCNames) do
?>		+ weight_<?=name?> * chart_<?=name?>(coords)
<? end
?>	;

	//from meters to normalized coordinates
	pos /= WGS84_a;

	if (chartIs3D) {
		pos = vec3(pos.z, pos.x, pos.y);
	}
	posv = pos;

	// lets see the grid over it
	pos *= .9999;

	gl_Position = mvProjMat * vec4(pos, 1.);
}

]], 		{
				chartCode = chartCode,
				chartCNames = chartCNames,
			}),

-- [=[
		geometryCode = [[
layout (triangles) in;
layout (triangle_strip, max_vertices = 3) out;

in vec2 texcoordv[];
out vec2 texcoordg;

in vec3 posv[];

void main() {
	vec3 dlen = vec3(
		length(posv[1] - posv[0]),
		length(posv[2] - posv[1]),
		length(posv[0] - posv[2]));
	if (dlen.x > .25 || dlen.y > .25 || dlen.z > .25)
	{
		return;
	}

	gl_Position = gl_in[0].gl_Position;
	texcoordg = texcoordv[0];
	EmitVertex();

	gl_Position = gl_in[1].gl_Position;
	texcoordg = texcoordv[1];
	if (texcoordv[1].x - texcoordv[0].x > .5) {
		texcoordg.x -= 1.;
	}
	if (texcoordv[1].x - texcoordv[0].x < -.5) {
		texcoordg.x += 1.;
	}
	EmitVertex();

	gl_Position = gl_in[2].gl_Position;
	texcoordg = texcoordv[2];
	if (texcoordv[2].x - texcoordv[0].x > .5) {
		texcoordg.x -= 1.;
	}
	if (texcoordv[2].x - texcoordv[0].x < -.5) {
		texcoordg.x += 1.;
	}
	EmitVertex();

	EndPrimitive();
}
]],
--]=]


			fragmentCode = template[[
in vec2 texcoordg;
out vec4 fragColor;

uniform sampler2D earthTex;

uniform sampler2D gradientTex;
uniform sampler2D forceTex;
uniform float forceTexAlpha;

uniform sampler2D drapTex;
uniform float drapTexAlpha;

uniform float alpha;	// final alpha

void main() {
	vec2 uv = vec2(texcoordg.x, 1. - texcoordg.y);
	fragColor = texture(earthTex, uv);

	float force = texture(forceTex, uv).r;
	vec4 forceColor = texture(gradientTex, vec2(force, .5));
	fragColor = mix(fragColor, forceColor, forceTexAlpha);

	// might have to rescale the uv here ...
	vec4 drapColor = texture(drapTex, uv);
	fragColor = mix(fragColor, drapColor, drapTexAlpha);

	fragColor.a = alpha;
}
]],
			uniforms = {
				earthTex = 0,
				forceTex = 1,
				gradientTex = 2,
				drapTex = 3,
				alpha = .5,
				forceTexAlpha = .5,
				drapTexAlpha = .5,
			},
		},
		vertexes = self.vertexBuf,
		geometries = geometries,
		texs = {
			GLTex2D{
				filename = 'earth-color.png',
				magFilter = gl.GL_LINEAR,
				--minFilter = gl.GL_NEAREST,
				minFilter = gl.GL_LINEAR_MIPMAP_LINEAR,
				generateMipmap = true,
				wrap = texWrap,
			}:unbind(),
		},
		uniforms = {
			weight_Equirectangular = 1,
			weight_Azimuthal_equidistant = 0,
			weight_Mollweide = 0,
			weight_WGS84 = 0,
		},
	}
	--]=====] END CLIP FROM GEOGRAPHIC-CHARTS

	-- [=====[ BEGIN EARTHQUAKES
	self.latLonPointShader = GLProgram{
			version = 'latest',
			precision = 'best',
			vertexCode = template([[
layout(location=0) in vec2 vertex;	// texcoord in [-1,1]

// divisor attributes:
in vec3 latlonrad;	// lat, lon, mag
in uvec2 time;	// lo/hi timestamp 32bit int

out vec2 texcoordv;
flat out float deltaJDay;
flat out uint idv;

uniform mat4 mvProjMat;
uniform bool chartIs3D;
uniform vec3 latlonroll0;
uniform float pointSize;
uniform uvec2 hiliteTime;
uniform uint idbase;

<?=chartCode?>

// compare two uint64_t's
int cmp(uvec2 a, uvec2 b) {
	if (a.y < b.y) return -1;
	if (a.y > b.y) return 1;
	if (a.x < b.x) return -1;
	if (a.x > b.x) return 1;
	return 0;
}

void main() {
	texcoordv = vertex;
	idv = uint(gl_InstanceID) + idbase;

	float alt = 1e+3;
	int c = cmp(time, hiliteTime);
	if (c < 0) {
		deltaJDay = -1.;
	} else if (c > 0) {
		deltaJDay = 1.;
	} else {
		deltaJDay = 0.;
		alt *= 2.;
	}

	vec2 latlonofs = applyLatLonRoll0(latlonrad.xy);

	vec3 coords = vec3(
		mod(latlonofs.x + 90., 180.) - 90.,	// lat in deg, [-90, 90]
		mod(latlonofs.y + 180., 360.) - 180.,	// lon in deg, [-180, 180]
		alt);				// height in meters

	vec3 pos = 0.
<? for _,name in ipairs(chartCNames) do
?>		+ weight_<?=name?> * chart_<?=name?>(coords)
<? end
?>	;
	pos /= WGS84_a;	//from meters to normalized coordinates

	if (chartIs3D) {
		pos = vec3(pos.z, pos.x, pos.y);
	}


	mat3 e = mat3(vec3(0.), vec3(0.), vec3(0.))
<? for _,name in ipairs(chartCNames) do
?>		+ weight_<?=name?> * chart_<?=name?>_basis(vec3(coords.xy, 0.))
<? end
?>	;
	float magn = latlonrad.z;
	pos += (vertex.x * e[0] + vertex.y * e[1]) * pointSize * magn;

	gl_Position = mvProjMat * vec4(pos, 1.);
}

]], 		{
				chartCode = chartCode,
				chartCNames = chartCNames,
			}),
			fragmentCode = [[
in vec2 texcoordv;
flat in float deltaJDay;
flat in uint idv;

layout(location=0) out vec4 fragColor;
layout(location=1) out uvec4 fragID;

uniform float alpha;
uniform uint idhi;

void main() {
	float lenSq = dot(texcoordv, texcoordv);
	if (lenSq > 1.) discard;
	if (deltaJDay == 0.) {
		fragColor = vec4(1., 1., 0., alpha);
	} else if (deltaJDay < 0.) {
		fragColor = vec4(1., 0., 0., alpha);
	} else { 	// if (deltaJDay > 0.) {
		fragColor = vec4(0., 1., 0., alpha);
	}
	if (lenSq > .9*.9) {
		fragColor = vec4(0., 0., 0., alpha);
	}

	//I suspect I'm going to have times (flares, axis cloud, etc) when I want to write color but not ID ...
	// can I discard midway through writing different output bound textures?
	fragID = uvec4(idv, idhi, 0, 0);
}
]],
		}:useNone()

require 'vec-ffi.vec2i'	-- time
	self.earthquakeLatLonPointObj = GLSceneObject{
		program = self.latLonPointShader,
		vertexes = billboardPointVtxBuf,
		geometry = {
			mode = gl.GL_TRIANGLE_STRIP,
		},
		uniforms = {
			idhi = 1,	-- 1 = earthquakes
		},
		attrs = {
			latlonrad = {
				divisor = 1,
				buffer = {
					dim = 3,
					useVec = true,
				},
			},
			time = {
				divisor = 1,
				buffer = {
					dim = 2,
					useVec = true,
					ctype = 'vec2i_t',
				},
			},
		},
	}
	do
		local latlonradGPU = self.earthquakeLatLonPointObj.attrs.latlonrad.buffer
		local timeGPU = self.earthquakeLatLonPointObj.attrs.time.buffer
		local latlonradCPU = latlonradGPU:beginUpdate()
		local timeCPU = timeGPU:beginUpdate()
		for i,eq in ipairs(earthquakes) do
			-- latitude: S = negative, N = positive
			-- longitude: W = negative, E = positive
			latlonradCPU:emplace_back():set(
				eq.latitude,
				eq.longitude,
				eq.mag
			)
			timeCPU:emplace_back():set(
				tonumber(eq.ostime & 0xffffffffLL),
				tonumber((eq.ostime >> 32) & 0xffffffffLL)
			)
		end
		assert.eq(#latlonradCPU, #earthquakes)
		latlonradGPU:endUpdate()
		timeGPU:endUpdate()
		self.earthquakeLatLonPointObj.instanceCount = #latlonradCPU
	end

	-- TODO for this and earthquakeLatLonPointObj, use instances
	self.flaresLatLonPointObj = GLSceneObject{
		program = self.latLonPointShader,
		vertexes = billboardPointVtxBuf,
		geometry = {
			mode = gl.GL_TRIANGLE_STRIP,
		},
		uniforms = {
			idhi = 2,	-- 2 = flares, but honestly, who wants to click on flares? hmm any way to make the ID draw bigger than the graphic?
		},
		attrs = {
			latlonrad = {
				divisor = 1,
				buffer = {
					dim = 3,
					useVec = true,
				},
			},
			time = {
				divisor = 1,
				buffer = {
					dim = 2,
					useVec = true,
					ctype = 'vec2i_t',
				},
			},
		},
	}
	do
		local latlonradGPU = self.flaresLatLonPointObj.attrs.latlonrad.buffer
		local timeGPU = self.earthquakeLatLonPointObj.attrs.time.buffer
		local latlonradCPU = latlonradGPU:beginUpdate()
		local timeCPU = timeGPU:beginUpdate()
		for i,f in ipairs(flares) do
			-- latitude: S = negative, N = positive
			-- longitude: W = negative, E = positive
			latlonradCPU:emplace_back():set(
				f.latitude,
				f.longitude,
				f.magn + 9	-- log10 watts, so A-class flare = -8
			)
			timeCPU:emplace_back():set(
				tonumber(f.ostime & 0xffffffffLL),
				tonumber((f.ostime >> 32) & 0xffffffffLL)
			)
		end
		assert.eq(#latlonradCPU, #flares)
		latlonradGPU:endUpdate()
		timeGPU:endUpdate()
		self.flaresLatLonPointObj.instanceCount = #latlonradCPU
	end

	local numCircleDivs = 200
	self.circlesObj = GLSceneObject{
		program = {
			version = 'latest',
			precision = 'best',
			vertexCode = template([[
layout(location=0) in float vertex;

in vec3 axis, axis2, axis3;	// axis dual = basis of circle
in vec3 color;	// base color
in float influence;	// additive influence,
in vec4 centerPos;	// .w = cos(centerAngle)

out vec3 posv;
out vec4 colorv;
out flat uint idv;

uniform float declinationFromAxis;	// ... in radians
uniform float angleFade;	// how much to fade out from the centerPos / centerAngle
uniform uint idbase;

uniform mat4 mvProjMat;
uniform bool chartIs3D;
uniform vec3 latlonroll0;	// used for texturing, TODO FIXME proper 3d transform

<?=chartCode?>

void main() {
	idv = uint(gl_InstanceID) + idbase;
	float theta = vertex * 2. * M_PI;

	float decl = cos(declinationFromAxis);
	float phi_r = sin(declinationFromAxis);

	vec3 v = axis * decl + phi_r * (axis2 * cos(theta) + axis3 * sin(theta));
	float cosAngle = dot(v, centerPos.xyz);
	float alpha = clamp(cosAngle * centerPos.w + angleFade, 0., 1.);
	colorv = vec4(color * influence, alpha);

	vec2 latlon = cartesianToLatLonWGS84(v).xy;
	// ... to degrees
	latlon.x *= 180. / M_PI;	//[-90, 90]
	latlon.y *= 180. / M_PI;	//[-180, 180]

	vec2 latlonofs = applyLatLonRoll0(latlon);

	//////// BEGIN CODE MATCHING CHART CODE ABOVE
	vec3 coords = vec3(
		mod(latlonofs.x + 90., 180.) - 90.,	// lat in deg, [-90, 90]
		mod(latlonofs.y + 180., 360.) - 180.,	// lon in deg, [-180, 180]
		2e+3);						// height in meters

	vec3 pos = 0.
<? for _,name in ipairs(chartCNames) do
?>		+ weight_<?=name?> * chart_<?=name?>(coords)
<? end
?>	;

	//from meters to normalized coordinates
	pos /= WGS84_a;

	if (chartIs3D) {
		pos = vec3(pos.z, pos.x, pos.y);
	}
	posv = pos;
	gl_Position = mvProjMat * vec4(pos, 1.);
	//////// END CODE MATCHING CHART CODE ABOVE
}
]],			{
				chartCode = chartCode,
				chartCNames = chartCNames,
			}),

-- [=[ but really just don't use this, just cull the vertexes in the array buffer
-- then again, this does let me split up line loops.
			-- lets see if we can hide lines that loop from lon=-180 to lon=+180 and go across the equirectangular/mollweide/most 2D projections
			-- TODO I could use this for the circle tesselation to begin with.  just pass the angle + axis.
			-- TODO TODO once I do that, I could also just do the cartesian-to-wgs84 in the fragment, then apply the charts in the fragment.
			geometryCode = [[
layout (lines) in;
layout (line_strip, max_vertices = 2) out;

in vec4 colorv[];
in vec3 posv[];
in flat uint idv[];
out vec4 colorg;
out flat uint idg;

void main() {
	float dlen = length(posv[1] - posv[0]);
	if (dlen > .25) {
		return;
	}

	gl_Position = gl_in[0].gl_Position;
	colorg = colorv[0];
	idg = idv[0];
	EmitVertex();

	gl_Position = gl_in[1].gl_Position;
	colorg = colorv[1];
	idg = idv[1];
	EmitVertex();

	EndPrimitive();
}
]],
--]=]
			fragmentCode = [[
in vec4 colorg;		// using geometry shader
in flat uint idg;
//in vec4 colorv;	// not using geometry shader
layout(location=0) out vec4 fragColor;
layout(location=1) out uvec4 fragID;
uniform float alpha;
uniform uint idhi;
void main() {
	fragColor = colorg;
	//fragColor = colorv;
	fragColor.a *= alpha;
	fragID = uvec4(idg, idhi, 0, 0);
}
]],
			uniforms = {
				idbase = 1,	-- never changes, not needed unless I am going to allow clicking on the planet angle circles
				idhi = 3,	-- 3 == geodesic lines
			},
		},
		-- TODO geometry shader the resolution? or can they even spit out that many vertexes?
		vertexes = {
			dim = 1,
			usage = gl.GL_STATIC_DRAW,
			data = (|n| range(n):mapi(|i| (i-.5)/n))(numCircleDivs),
		},
		geometry = {
			mode = gl.GL_LINE_LOOP,
		},
		attrs = {
			axis = {
				divisor = 1,
				buffer = {
					dim = 3,
					useVec = true,
				},
			},
			axis2 = {
				divisor = 1,
				buffer = {
					dim = 3,
					useVec = true,
				},
			},
			axis3 = {
				divisor = 1,
				buffer = {
					dim = 3,
					useVec = true,
				},
			},
			color = {
				divisor = 1,
				buffer = {
					dim = 3,
					useVec = true,
				},
			},
			influence = {
				divisor = 1,
				buffer = {
					dim = 1,
					useVec = true,
				},
			},
			centerPos = {
				divisor = 1,
				buffer = {
					dim = 4,
					useVec = true,
				},
			},
		},
	}

	gl.glEnable(gl.GL_DEPTH_TEST)

	-- [=[ build here
	-- show axii of circles
	self.pairCrossPointsObj = GLSceneObject{
		-- TODO why not use the earthquake lat lon point obj program?
		program = {
			version = 'latest',
			precision = 'best',
			vertexCode = template([[
layout(location=0) in vec2 vertex;	// billboard texcoord in [-1,1]^2
in vec3 latlonheight;				// lat in deg, lon in deg, height in m

out vec2 texcoordv;

uniform mat4 mvMat;
uniform mat4 mvProjMat;
uniform bool chartIs3D;
uniform vec3 latlonroll0;
uniform float pointSize;
uniform float heightScale;

<?=chartCode?>

void main() {
	texcoordv = vertex;
	vec2 latlonofs = applyLatLonRoll0(latlonheight.xy);

	//////// BEGIN CODE MATCHING CHART CODE ABOVE
	vec3 coords = vec3(
		mod(latlonofs.x + 90., 180.) - 90.,	// lat in deg, [-90, 90]
		mod(latlonofs.y + 180., 360.) - 180.,	// lon in deg, [-180, 180]
		latlonheight.z * heightScale);							// height in meters

	vec3 pos = 0.
<? for _,name in ipairs(chartCNames) do
?>		+ weight_<?=name?> * chart_<?=name?>(coords)
<? end
?>	;
	pos /= WGS84_a;	//from meters to normalized coordinates

	if (chartIs3D) {
		pos = vec3(pos.z, pos.x, pos.y);
	}

#if 0	// use chart basis
	mat3 e = mat3(vec3(0.), vec3(0.), vec3(0.))
<? for _,name in ipairs(chartCNames) do
?>		+ weight_<?=name?> * chart_<?=name?>_basis(vec3(coords.xy, 0.))
<? end
?>	;
#else	// use modelview basis
	mat3 e = transpose(mat3(mvMat));
#endif
	pos += (vertex.x * e[0] + vertex.y * e[1]) * pointSize;

	gl_Position = mvProjMat * vec4(pos, 1.);
}
]],			{
				chartCode = chartCode,
				chartCNames = chartCNames,
			}),
			fragmentCode = [[
in vec2 texcoordv;

out vec4 fragColor;

void main() {
	float lenSq = dot(texcoordv, texcoordv);
	if (lenSq > 1.) discard;
	if (lenSq > .9*.9) {
		fragColor = vec4(0., 0., 0., 1.);
	} else {
		fragColor = vec4(1., 1., 1., 1.);
	}
}
]],
},
		geometry = {
			mode = gl.GL_TRIANGLE_STRIP,
		},
		vertexes = billboardPointVtxBuf,
		attrs = {
			latlonheight = {
				divisor = 1,
				buffer = {
					dim = 3,
					useVec = true,
				},
			},
		},
	}
	--]=]



	-- while we're here, let's compute the tidal and gravitational forces of our planets ...
	-- TODO take it from my solarsystem project where I'm already doing this
	-- but compute shader? does GL support double buffers? I don't think so . . .
	-- maybe I have to use OpenCL now

	self.clsize = {200,100}		-- or maybe "forceTexDim" or something
	self.clvolume = self.clsize[1] * self.clsize[2]
	self.env = CLEnv{
		verbose = true,
		useGLSharing = false,
		precision = 'double',
		-- TODO how about a getter-for-cmdline-obj ?
		--getPlatform = CLEnv.getterForIdent(cmdline.platform, 'platform'),
		--getDevices = CLEnv.getterForIdent(cmdline.device, 'device'),
		--deviceType = CLEnv.getDeviceTypeFromCmdLine(...),
		size = self.clsize,
	}

	self.calcTideAndGravProgram = self.env:program{
		code = template(assert(path'calcs.cl':read()), {
			calcFlagsCode = calcFlagsCode,
			clsize = self.clsize,
			clnumber = clnumber,
			WGS84_e = math.sqrt(1. - charts.WGS84.b^2 / charts.WGS84.a^2),
			Planets = Planets,		-- whatever size the list the self.planetPosRelEarthBuffer is
		}),
	}

	self.calcTideAndGravProgram:compile()

	self.forceBuffer = self.env:buffer{name='forceBuffer', type='real'}
	self.dforceBuffer = self.env:buffer{name='dforceBuffer', type='real'}	-- for when you use gradients

	self.rescaleForceCPUBuf = vector('float', self.clvolume)
assert.len(self.rescaleForceCPUBuf, self.clvolume)
	self.rescaleForceBuffer = self.env:buffer{name='forceBuffer', type='float'}

	self.reduceBuffer = self.env:buffer{name='reduceBuffer', type='real'}
	self.reduceSwapBuffer = self.env:buffer{name='reduceSwapBuffer', type='real'}
	self.reduceResultPtr = ffi.new'real[1]'
	self.reduceResultPtr[0] = 0

	self.planetPosRelEarthCPUBuf = vector('real4', #Planets.planetClasses)
	self.planetPosRelEarthBuffer = self.env:buffer{
		name = 'planetPosRelEarthBuffer',
		type = 'real4',
		size = {#Planets.planetClasses},
	}	-- all planets, including earth, because maybe we want it too.

	self.calcTideAndGravKernel = self.calcTideAndGravProgram:kernel'calcTideAndGrav'
	self.calcTideAndGravKernel.obj:setArg(0, self.forceBuffer)
	self.calcTideAndGravKernel.obj:setArg(1, self.planetPosRelEarthBuffer)

	self.gradientKernel = self.calcTideAndGravProgram:kernel'gradient'
	self.gradientKernel.obj:setArg(0, self.dforceBuffer)
	self.gradientKernel.obj:setArg(1, self.forceBuffer)

	-- TODO instead of this, use GL sharing?
	self.rescaleKernel = self.calcTideAndGravProgram:kernel'rescale'
	self.rescaleKernel.obj:setArg(0, self.rescaleForceBuffer)
	self.rescaleKernel.obj:setArg(1, self.forceBuffer)

	self.reduceMin = self.env:reduce{
		count = self.clvolume,
		op = |x,y| 'min('..x..', '..y..')',
		initValue = 'INFINITY',
		buffer = self.reduceBuffer.obj,
		swapBuffer = self.reduceSwapBuffer.obj,
		result = self.reduceResultPtr,
	}

	self.reduceMax = self.env:reduce{
		count = self.clvolume,
		op = |x,y| 'max('..x..', '..y..')',
		initValue = '-INFINITY',
		buffer = self.reduceBuffer.obj,
		swapBuffer = self.reduceSwapBuffer.obj,
		result = self.reduceResultPtr,
	}

	local internalFormat = gl.GL_R32F
	local info = require 'gl.tex'.formatInfoForInternalFormat[internalFormat]
	self.forceTex = GLTex2D{
		width = self.clsize[1],
		height = self.clsize[2],
		magFilter = gl.GL_LINEAR,
		minFilter = gl.GL_LINEAR_MIPMAP_LINEAR,
		wrap = texWrap,
		internalFormat = info.internalFormat,
		format = info.format,
		type = info.types[1],
		data = self.rescaleForceCPUBuf.v,
	}:unbind()
	self.globeObj.texs[2] = self.forceTex
	self.gradientTex = GLGradientTex2D(
		256,
--[[ rainbow
		{
			{1,0,0,1},
			{1,1,0,1},
			{0,1,0,1},
			{0,1,1,1},
			{1,0,1,1},
		}
--]]
-- [[ sunset pic from https://blog.graphiq.com/finding-the-right-color-palettes-for-data-visualizations-fcd4e707a283#.inyxk2q43
-- also in efesoln-cl-lua
		table{
			vec3d(22,31,86),
			vec3d(34,54,152),
			vec3d(87,49,108),
			vec3d(156,48,72),
			vec3d(220,60,57),
			vec3d(254,96,50),
			vec3d(255,188,46),
			vec3d(255,255,55),
		}:mapi(|c| do
			local x,y,z = (c/255):unpack()
			--return table(x,y,z):append{1}
			return {x,y,z,1}
		end)
--]]
	):unbind()
	self.globeObj.texs[3] = self.gradientTex

	self.drawFBOObj = GLSceneObject{
		program = {
			version = 'latest',
			precision = 'best',
			vertexCode = [[
layout(location=0) in vec2 vertex;
out vec2 texcoordv;
void main() {
	texcoordv = vertex * .5 + .5;
	gl_Position = vec4(vertex, 0., 1.);
}
]],
			fragmentCode = [[
in vec2 texcoordv;
layout(location=0) out vec4 fragColor;
uniform sampler2D fboTex;
void main() {
	fragColor = texture(fboTex, texcoordv);
}
]],
		},
		uniforms = {
			fboTex = 0,
		},
		geometry = {
			mode = gl.GL_TRIANGLE_STRIP,
		},
		vertexes = billboardPointVtxBuf,
	}


	self.trackEarthquakeIndexes = table()

	self:updateEarthquakeIndex()

	self:refreshFBO()
end

-- call this on init and when the window resizes.
-- it will remake the FBO and its associated color attachment textures based on the window size.
App.refreshFBO=|:|do
	-- store color here
	local info = GLTex2D.formatInfoForInternalFormat[gl.GL_RGBA]
	self.colorFBOTex = GLTex2D{
		width = self.width,
		height = self.height,
		magFilter = gl.GL_LINEAR,
		minFilter = gl.GL_NEAREST,
		internalFormat = info.internalFormat,
		format = info.format,
		type = info.types[1],
	}:unbind()

	-- write out IDs when you render to this texture
	-- use it for click for detecting
	local info = GLTex2D.formatInfoForInternalFormat[gl.GL_RGBA32UI]
	self.clickIDFBOTex = GLTex2D{
		width = self.width,
		height = self.height,
		magFilter = gl.GL_NEAREST,
		minFilter = gl.GL_NEAREST,
		internalFormat = info.internalFormat,
		format = info.format,
		type = info.types[1],
	}:unbind()

	self.drawFBOObj.texs[1] = self.colorFBOTex
--self.drawFBOObj.texs[1] = self.clickIDFBOTex

	self.fbo = GLFBO{
		width = self.width,
		height = self.height,
		useDepth = true,
	}
		:bind()
		:setColorAttachmentTex2D(self.colorFBOTex.id, 0)
		:setColorAttachmentTex2D(self.clickIDFBOTex.id, 1)
		:setDrawBuffers(gl.GL_COLOR_ATTACHMENT0, gl.GL_COLOR_ATTACHMENT1)
		:unbind()
end

App.resize=|:, ...| do
	App.super.resize(self, ...)
	self:refreshFBO()
end

-- list of earthquakes[vars.earthquakeIndex].allCircles[] that are to be displayed
local circles

-- refresh the list of what circles we want to display right now
-- this is either all circles in the last period (3 days? 1 day? etc)
-- or it is all that are touching the currently selected quake
App.refreshVisibleCircles = |:| do
	local eq = earthquakes[vars.earthquakeIndex]
	if vars.showOnlySelectedEarthquakeArcs then
		-- show all circles touching our currently selected
		circles = eq.touchingCircles:mapi(|t| t.circle)
	else
		-- show all circles touching any active earthquakes in the last timeframe
		-- TODO also include future window ... but also TODO should we show future earthquakes too?
		-- TODO earthquake window slider relative to the previous quake?
		local circleIndexes = table()
		for i=earthquakeWindowStartIndex,earthquakeWindowEndIndex do
			local cis = eq.circlesMadeByQuakes[i]
			if cis then
				for _,ci in ipairs(cis) do
					circleIndexes[ci] = true
				end
			end
		end
		circles = circleIndexes:keys():sort():mapi(|ci| eq.allCircles[ci])
	end

	-- invalidate track objs' min angle to selected earthquake, cuz they are based on 'circles'
	for _,track in ipairs(self.trackEarthquakeIndexes) do
		track.minAngle = nil
	end

	-- [[ update the circles
	do
		local axisGPU = self.circlesObj.attrs.axis.buffer
		local axisCPU = axisGPU:beginUpdate()
		local axis2GPU = self.circlesObj.attrs.axis2.buffer
		local axis2CPU = axis2GPU:beginUpdate()
		local axis3GPU = self.circlesObj.attrs.axis3.buffer
		local axis3CPU = axis3GPU:beginUpdate()
		local colorGPU = self.circlesObj.attrs.color.buffer
		local colorCPU = colorGPU:beginUpdate()
		local influenceGPU = self.circlesObj.attrs.influence.buffer
		local influenceCPU = influenceGPU:beginUpdate()
		local centerPosGPU = self.circlesObj.attrs.centerPos.buffer
		local centerPosCPU = centerPosGPU:beginUpdate()

		for _,c in ipairs(circles) do
			axisCPU:emplace_back():set(c.axis:unpack())
			axis2CPU:emplace_back():set(c.axis2:unpack())
			axis3CPU:emplace_back():set(c.axis3:unpack())
			local t1 = earthquakes[c.indexes[1]].ostime
			local t2 = earthquakes[c.indexes[2]].ostime
			local tavg = (t1 + t2) >> 1
			if tavg < eq.ostime then
				colorCPU:emplace_back():set(c.color.x, 0, 0)
			else
				colorCPU:emplace_back():set(0, c.color.y, 0)
			end
			influenceCPU:emplace_back()[0] = c.influence
			centerPosCPU:emplace_back():set(
				c.centerPos.x,
				c.centerPos.y,
				c.centerPos.z,
				1. / math.cos(c.centerAngle)
			)
		end

		self.circlesObjInstanceCount = #axisCPU

		-- last, make room for each planet, for each angle, for if we draw it
		local earthPos = eq.planets[Planets.indexes.earth].pos
		for _,planetClass in ipairs(drawPlanetClasses) do
			for _,declAngle in ipairs(drawPlanetAngles) do
				local planetPos = eq.planets[Planets.indexes[planetClass.name]].pos
				local planetDir = (planetPos - earthPos):normalize()
				local axis2 = basisFor(planetDir)
				local axis3 = planetDir:cross(axis2)
				axisCPU:emplace_back():set(planetDir:unpack())
				axis2CPU:emplace_back():set(axis2:unpack())
				axis3CPU:emplace_back():set(axis3:unpack())
				colorCPU:emplace_back():set(table.unpack(planetClass.color))
				influenceCPU:emplace_back()[0] = 1
				centerPosCPU:emplace_back():set(0,0,0,1)
			end
		end

		-- finally finally, solar orbital plane
		do
			-- how to determine?  aveverage cross of planets?  least squares?  just rotate the earth's axis?
			--[[ using the coordinate system + fixed angle
			local orbitAxis = vec3d(0,0,1)
			orbitAxis = require 'basis'.rotateX(orbitAxis, math.rad((23 + 1/60*(26 + 1/60*(21.4119)))))
			orbitAxis = require 'basis'.rotateFromSolarToEarthFrame(orbitAxis, eq.julianDay)
			--]]
			-- [[ using a sum of cross products of planets, assuming they are all in the plane ... shoudl I weight them? should I just use one or two important ones?
			local orbitAxis = vec3d(0,0,0)
			local prevPlanetDir 
			for _,planetClass in ipairs(drawPlanetClasses) do
				local planetPos = eq.planets[Planets.indexes[planetClass.name]].pos
				local planetDir = (planetPos - earthPos):normalize()
				if prevPlanetDir then
					orbitAxis += planetDir:cross(prevPlanetDir)
				end
				prevPlanetDir = planetDir
			end
			orbitAxis = orbitAxis:normalize()
			--]]
			local axis2 = basisFor(orbitAxis)
			local axis3 = orbitAxis:cross(axis2)
			axisCPU:emplace_back():set(orbitAxis)
			axis2CPU:emplace_back():set(axis2:unpack())
			axis3CPU:emplace_back():set(axis3:unpack())
			colorCPU:emplace_back():set(1,1,1)
			influenceCPU:emplace_back()[0] = 1
			centerPosCPU:emplace_back():set(0,0,0,1)
		end

		axisGPU:endUpdate()
		axis2GPU:endUpdate()
		axis3GPU:endUpdate()
		colorGPU:endUpdate()
		influenceGPU:endUpdate()
		centerPosGPU:endUpdate()
	end
	--]]

	-- TODO FIXME where are these points going?
	-- [=[ now that we've refreshed the circles, refresh our torque axis points too
	do
		local sceneObj = self.pairCrossPointsObj
		local latlonheightGPU = sceneObj.attrs.latlonheight.buffer
		local latlonheightCPU = latlonheightGPU:beginUpdate()
--print('building points from ',#circles, 'circles')
		for _,c in ipairs(circles) do
			local torque = c.axis * c.axisLen
			-- hmm proper torque would be based on radius from earth ... so consider depth?
			-- hmmmmm
			-- if points are 180' or if they are next to each other then we want no infuence ...
			-- ... .maybe I souldn't nrmlize with the cross produt ...
			-- and then I should look at the point-cloud of the axis' ...
			for s=-1,1,2 do
				local x,y,z = (s * torque):unpack()
				--z,x,y = x,y,z	-- hmm ...
				-- and cartesianToLatLonWGS84 scales it up by WGS84.a ... hmm why
				local phi, lambda, height = cartesianToLatLonWGS84(x,y,z)
--print(x,y,z,phi,lambda)
				latlonheightCPU:emplace_back():set(
					(math.deg(phi) + 90) % 180 - 90,
					(math.deg(lambda) + 180) % 360 - 180,
					height	--  in meters
				)
			end
		end
		latlonheightGPU:endUpdate()
		sceneObj.geometry.instanceCount = #latlonheightCPU
	end
	--]=]
end

--[[
this represents Rz(heading) * Ry(pitch) * Rx(bank) * v
seems to be equivalent to my "applyLatLonRoll0Inv" which might not be an inverse after all
--]]
local eulerToQuat = |lat, lon, roll|do
	lat = math.rad(lat)
	lon = math.rad(lon)
	roll = math.rad(roll)
	local pitch = -lat
	local yaw = lon
	roll = -roll

    local cr = math.cos(roll * .5)
    local sr = math.sin(roll * .5)
    local cp = math.cos(pitch * .5)
    local sp = math.sin(pitch * .5)
    local cy = math.cos(yaw * .5)
    local sy = math.sin(yaw * .5)

    local q = quatd()
    q.w = cr * cp * cy + sr * sp * sy
    q.x = sr * cp * cy - cr * sp * sy
    q.y = cr * sp * cy + sr * cp * sy
    q.z = cr * cp * sy - sr * sp * cy

    return q
end
local quatToEuler = |q|do
    -- roll (x-axis rotation)
    local sinr_cosp = 2 * (q.w * q.x + q.y * q.z)
    local cosr_cosp = 1 - 2 * (q.x * q.x + q.y * q.y)
    local roll = math.atan2(sinr_cosp, cosr_cosp)

    -- pitch (y-axis rotation)
    local sinp = math.sqrt(1 + 2 * (q.w * q.y - q.x * q.z))
    local cosp = math.sqrt(1 - 2 * (q.w * q.y - q.x * q.z))
    local pitch = 2 * math.atan2(sinp, cosp) - math.pi * .5

    -- yaw (z-axis rotation)
    local siny_cosp = 2 * (q.w * q.z + q.x * q.y)
    local cosy_cosp = 1 - 2 * (q.y * q.y + q.z * q.z)
    local yaw = math.atan2(siny_cosp, cosy_cosp)

	local lat = -pitch
	local lon = yaw
	roll = -roll
	lat = math.deg(lat)
	lon = math.deg(lon)
	roll = math.deg(roll)
	return lat, lon, roll
end

local drapPath = path'goes_drap'
drapPath:mkdir()
local nextDrapCheckTime = timer.getTime() - 1
App.update = |:| do
	self.fbo:bind()
	assert(self.fbo:check())
	gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT)

	local eq = earthquakes[vars.earthquakeIndex]

-- [[
	self.totalLikelihood = self.totalLikelihood or 1
	self.oddsTrue = self.oddsTrue or 0
	self.oddsFalse = self.oddsFalse or 0
	-- TODO this is the odds of 2 (or more) matching.  we should calc the odds of the number of matches that we actually got.
	local probsForEqSetSize = require 'birthday-problem'[calcCircles.quakeAlignWithPreviousGeodesicAngleThreshold]
	if probsForEqSetSize then
		if not eq.probabilityOfFindingAnyGeodesic then
			local numQuakesInWindow = earthquakeWindowEndIndex - earthquakeWindowStartIndex + 1
			eq.probabilityOfFindingAnyGeodesic = probsForEqSetSize[numQuakesInWindow] or 1
			print(
				eq.probabilityOfFindingAnyGeodesic
				..' = odds of finding a geodesic within '..calcCircles.quakeAlignWithPreviousGeodesicAngleThreshold
				..'° (i.e. '
				..(360/calcCircles.quakeAlignWithPreviousGeodesicAngleThreshold)
				..' partitions) from '..numQuakesInWindow
				..' possible quakes, and we found '
				..#eq.touchingCircles
			)
			if #eq.touchingCircles > 0 then
				self.totalLikelihood *= eq.probabilityOfFindingAnyGeodesic
				self.oddsTrue += 1
			else
				self.totalLikelihood *= 1 - eq.probabilityOfFindingAnyGeodesic
				self.oddsFalse += 1
			end
			--print('...running total likelihood = '..self.totalLikelihood)	-- TODO i think this odds is the order-dependent odds of events happening, but I should be looking at order-independence or something, idk, i hate probability and statistics
			print('...so far we have found geodesics '..self.oddsTrue..' of '..(self.oddsTrue + self.oddsFalse)..' times = '..(self.oddsTrue / (self.oddsTrue + self.oddsFalse)))
		end
	end
--]]

	if vars.recenterOnQuake then
--[[ LERP - and all the coordinate problems that go with it
		vars.lat0 = math.mix(vars.lat0, vars.targetlat0, vars.latlonroll0convergeRate)
		vars.lon0 = math.mix(vars.lon0, vars.targetlon0, vars.latlonroll0convergeRate)
		vars.roll0 = math.mix(vars.roll0, vars.targetroll0, vars.latlonroll0convergeRate)
--]]
-- [[ SLERP ... involves some converting to and from euler angles and quaternions ...
		local q1 = eulerToQuat(vars.lat0, vars.lon0, vars.roll0)
		local q2 = eulerToQuat(vars.targetlat0, vars.targetlon0, vars.targetroll0)
		if math.abs(q1:dot(q2)) > .99999 then
			vars.lat0 = vars.targetlat0
			vars.lon0 = vars.targetlon0
			vars.roll0 = vars.targetroll0
		else
			local q = quatd():slerp(q1, q2, vars.latlonroll0convergeRate)
			vars.lat0, vars.lon0, vars.roll0 = quatToEuler(q)
		end
--]]
	end

	-- while we're here, try to remotely download & cache the DRAP image
	-- https://services.swpc.noaa.gov/images/animations/d-rap/global/d-rap/SWX_DRAP20_C_SWPC_20250607030500_GLOBAL.png
	-- check every frame or will that slow us down?
	if vars.showDrapTex
	and timer.getTime() > nextDrapCheckTime
	then
		nextDrapCheckTime = timer.getTime() + 1
--DEBUG:print('checking eq.drapTex', type(eq.drapTex), eq.drapTex)
		if type(eq.drapTex) == 'table' then
--DEBUG:print('...has texture')
		else
			local cacheName = ('%04d-%02d-%02d_%02d:%02d:%02d'):format(
				eq.date.year, eq.date.month, eq.date.day, eq.date.hour, eq.date.min, eq.date.sec)
			local p = drapPath/(cacheName..'.png')

			if p:exists() then
print(cacheName..' exists...')
print("our current state:", eq.drapTex)
				if eq.drapTex == 'loading' then
print('loading, checking pid for finished...')
					local done = not os.exec('kill -0 '..eq.drapTexWGetPID..' > /dev/null 2>&1')	-- ... or wget request and pid kill -0 test errors aka the pid is done
print('kill -0 failed, i.e. done?', done)
					if done then
						eq.drapTex = 'done'	-- finished loading
					end
				end

				if eq.drapTex == nil		-- if we never loaded i.e. chcking cache ...
				or eq.drapTex == 'done'		-- or if we just finished loading ...
				then
print('pid is done, checking file size...')
					-- then the process must have ended ...
					if p:attr().size == 0 then
print('file size is zero - error?')
						-- then something went wrong (also we could test for process exit code but then you'd have to write that somewhere upon exit ...)
						eq.drapTex = 'failed'
					else
print('file size is valid, done?')
					end
				end

				if eq.drapTex == nil		-- file exists and no loading was done
				or eq.drapTex == 'done' 	-- loading is finished
				then
				-- TODO not here, but wait until the wget pid finishes ....
--DEBUG:print("...exists, loading")
					eq.drapTex = GLTex2D{
						image = Image(p.path)
							:copy{x=12, y=9, width=689-12, height=338-9}
							:rgba(),
						magFilter = gl.GL_LINEAR,
						minFilter = gl.GL_NEAREST,
						wrap = texWrap,
					}:unbind()
				end
			else
print(cacheName.." doesn't exist...")
			end

			if eq.drapTex == nil then	-- didn't load but havne't tried to load ... then try to load
print("...hasn't been dl'd, dl'ing...")
				eq.drapTex = 'loading'	-- don't load twice
				local fn = ('%04d%02d%02d%02d%02d00'):format(
					eq.date.year, eq.date.month, eq.date.day, eq.date.hour, eq.date.min)
				os.exec('wget https://services.swpc.noaa.gov/images/animations/d-rap/global/d-rap/SWX_DRAP20_C_SWPC_'..fn..'_GLOBAL.png -O '..p..' & echo $! > pid')
				eq.drapTexWGetPID = path'pid':read():trim()
				path'pid':remove()
			-- else it should be 'loading' or 'failed'
			end
		end
	end

	if vars.drawEarth then
		local sceneObj = self.globeObj
		if type(eq.drapTex) == 'table' then
			sceneObj.texs[4] = eq.drapTex
		else
			sceneObj.texs[4] = nil
		end
		for _,name in ipairs(weightFields) do
			sceneObj.uniforms[name] = vars[name]
		end
		sceneObj.uniforms.latlonroll0 = {vars.lat0, vars.lon0, vars.roll0}
		sceneObj.uniforms.chartIs3D = false	-- this is just whether to swap x y and z around , z = along view vs z = north pole
		sceneObj.uniforms.mvProjMat = self.view.mvProjMat.ptr
		sceneObj.uniforms.forceTexAlpha = vars.forceTexAlpha
		sceneObj.uniforms.drapTexAlpha = vars.showDrapTex and vars.drapTexAlpha or 0
		sceneObj:draw()
	end

	do
		gl.glLineWidth(vars.lineWidth)
		--gl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE)
		gl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE_MINUS_SRC_ALPHA)
		gl.glEnable(gl.GL_BLEND)
		gl.glDepthMask(0)

		local sceneObj = self.circlesObj
		for _,name in ipairs(weightFields) do
			sceneObj.uniforms[name] = vars[name]
		end
		sceneObj.uniforms.declinationFromAxis = .5 * math.pi
		sceneObj.uniforms.latlonroll0 = {vars.lat0, vars.lon0, vars.roll0}
		sceneObj.uniforms.angleFade = vars.angleFade
		sceneObj.uniforms.chartIs3D = false	-- this is just whether to swap x y and z around , z = along view vs z = north pole
		sceneObj.uniforms.mvProjMat = self.view.mvProjMat.ptr
		sceneObj.uniforms.alpha = vars.greatArcAlpha
		if vars.drawGreatArcs then
			sceneObj.geometry.instanceCount = self.circlesObjInstanceCount
			sceneObj:draw()
		end
		gl.glDisable(gl.GL_BLEND)
		if vars.drawAnyPlanets then
			gl.glLineWidth(3)
			sceneObj.geometry.instanceCount = 1
			sceneObj.uniforms.angleFade = 1
			local earthPos = eq.planets[Planets.indexes.earth].pos
			for planetClassIndex,planetClass in ipairs(drawPlanetClasses) do
				if vars.drawPlanets[planetClass.name] then
					for declAngleIndex,declAngle in ipairs(drawPlanetAngles) do
						if vars.drawPlanetAngles[declAngle] then
							sceneObj.uniforms.declinationFromAxis = math.rad(declAngle)
							sceneObj.geometry.instanceOffset = self.circlesObjInstanceCount
								+ (declAngleIndex - 1)
								+ (planetClassIndex - 1) * #drawPlanetAngles
							sceneObj:draw()
						end
					end
				end
			end

			-- last draw the orbit plane
			sceneObj.uniforms.declinationFromAxis = .5 * math.pi
			sceneObj.geometry.instanceOffset = self.circlesObjInstanceCount + #drawPlanetClasses * #drawPlanetAngles
			sceneObj:draw()

			sceneObj.geometry.instanceCount = nil
			sceneObj.geometry.instanceOffset = nil
		end
		gl.glDepthMask(1)
		gl.glLineWidth(1)
	end

	if vars.drawEarthquakes then
		gl.glDepthFunc(gl.GL_LEQUAL)
		local sceneObj = self.earthquakeLatLonPointObj
		for _,name in ipairs(weightFields) do
			sceneObj.uniforms[name] = vars[name]
		end
		sceneObj.uniforms.latlonroll0 = {vars.lat0, vars.lon0, vars.roll0}
		sceneObj.uniforms.chartIs3D = false	-- this is just whether to swap x y and z around , z = along view vs z = north pole
		sceneObj.uniforms.mvProjMat = self.view.mvProjMat.ptr
		sceneObj.uniforms.pointSize = vars.earthquakePointSize
		sceneObj.uniforms.alpha = 1
		sceneObj.uniforms.hiliteTime = {
			tonumber(eq.ostime & 0xffffffffLL),
			tonumber((eq.ostime >> 32) & 0xffffffffLL)
		}
		sceneObj.uniforms.idbase = earthquakeWindowStartIndex		-- because `gl_InstanceID` isn't affected by glDrawArraysInstancedBaseInstance's baseInstance ...
		sceneObj.geometry.instanceOffset = earthquakeWindowStartIndex - 1
		sceneObj.geometry.instanceCount = earthquakeWindowEndIndex - earthquakeWindowStartIndex + 1
		sceneObj:draw()
		sceneObj.geometry.instanceOffset = nil
		sceneObj.geometry.instanceCount = nil
		gl.glDepthFunc(gl.GL_LESS)
	end

	if vars.drawFlares then
		gl.glDepthFunc(gl.GL_LEQUAL)
		gl.glEnable(gl.GL_BLEND)
		gl.glDepthMask(0)
		local sceneObj = self.flaresLatLonPointObj
		for _,name in ipairs(weightFields) do
			sceneObj.uniforms[name] = vars[name]
		end
		sceneObj.uniforms.latlonroll0 = {vars.lat0, vars.lon0, vars.roll0}
		sceneObj.uniforms.chartIs3D = false	-- this is just whether to swap x y and z around , z = along view vs z = north pole
		sceneObj.uniforms.mvProjMat = self.view.mvProjMat.ptr
		sceneObj.uniforms.pointSize = vars.flarePointSize
		sceneObj.uniforms.alpha = .2
		sceneObj.uniforms.hiliteTime = {
			tonumber(eq.ostime & 0xffffffffLL),
			tonumber((eq.ostime >> 32) & 0xffffffffLL)
		}
		sceneObj.uniforms.idbase = flareWindowStartIndex
		-- TODO also color the flares different or something
		sceneObj.geometry.instanceOffset = flareWindowStartIndex - 1
		sceneObj.geometry.instanceCount = flareWindowEndIndex - flareWindowStartIndex + 1
		sceneObj:draw()
		sceneObj.geometry.instanceOfffset = nil
		sceneObj.geometry.instanceCount = nil
		gl.glDepthMask(1)
		gl.glDisable(gl.GL_BLEND)
		gl.glDepthFunc(gl.GL_LESS)
	end

	-- [=[ TODO show torque axii of circle geodesics
	if vars.drawAxisCloud then
		local sceneObj = self.pairCrossPointsObj
		if sceneObj.geometry.instanceCount > 0 then
			for _,name in ipairs(weightFields) do
				sceneObj.uniforms[name] = vars[name]
			end
			sceneObj.uniforms.latlonroll0 = {vars.lon0, vars.lat0, vars.roll0}
			sceneObj.uniforms.chartIs3D = false	-- this is just whether to swap x y and z around , z = along view vs z = north pole
			sceneObj.uniforms.mvMat = self.view.mvMat.ptr
			sceneObj.uniforms.mvProjMat = self.view.mvProjMat.ptr
			sceneObj.uniforms.pointSize = vars.axisCloudPointSize
			sceneObj.uniforms.heightScale = vars.axisCloudHeightScale

			sceneObj:draw()
		end
	end
	--]=]

	self.fbo:unbind()

	gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT)
	self.drawFBOObj:draw()

	App.super.update(self)

	-- while we're here...
	-- ... re-download the latest day's earthquakes
	local t = time()
	if t > checkTime + checkDuration then
		checkTime = t
		local newTodaysEarthquakes, changed = getDayCache(t, true)
		if changed then
			print(os.date(), 'TODO upate me plz')
		end
	end

	glreport'here'
end

App.updateEarthquakeIndex = |:| do
	vars.earthquakeIndex = math.clamp(math.round(vars.earthquakeIndex), 1, #earthquakes)

	-- invalidate track objs' min angle to selected earthquake
	for _,track in ipairs(self.trackEarthquakeIndexes) do
		track.minAngle = nil
	end

	-- TODO redo circle' touchingindexes to scan both + and - in time by 1 day
	self:calcQuakeWindowIndexes()
	self:refreshForceBuffer()

	if vars.recenterOnQuake then
		self:recenterOnQuake()
	end
end

App.recenterOnQuake = |:|do
	local eq = earthquakes![vars.earthquakeIndex]
	-- ok this will put our quake at center for Equirectangular ... and maybe spherical and wgs84 ...
	-- but for Azimuthal I'll need to offset lat0 by 90' ...
	-- so that means our recenter will need offsets which will need to be linearly weighted by the chart parameters
	-- But adding this means I gotta call "recenterOnQuake" when the chart weights change ...
	-- TODO make an azimuthal with an extra 90' rotate lat that puts 0' lat lon in the middle, so that the center is in the center,
	--  then the need for this var will go away and roll will work.
	local chartLat0 = vars.weight_Azimuthal_equidistant * 90
	vars.targetlat0 = eq.latitude - chartLat0
	vars.targetlon0 = eq.longitude
end

App.refreshForceBuffer = |:|do
--DEBUG:print'refreshing force buffer'
	local eq = earthquakes![vars.earthquakeIndex]
	local earthPos = eq.planets[Planets.indexes.earth].pos
	for i,p in ipairs(eq.planets) do
		local v = eq.planets[i].pos - earthPos
		local pos = self.planetPosRelEarthCPUBuf.v + (i-1)
		pos.x = v.x
		pos.y = v.y
		pos.z = v.z
		pos.w = vars.calcPlanets[p.name] and p.mass or 0
--DEBUG:print('planet', i, 'name', p.name, 'mass', pos.w)
	end
	self.planetPosRelEarthBuffer:fromCPU(self.planetPosRelEarthCPUBuf.v)

	self.calcTideAndGravKernel.obj:setArg(2, int(0
		| (vars.calcTidesVert and ffi.C.calcFlags_calcTidesVert or 0)
		| (vars.calcTidesHorz and ffi.C.calcFlags_calcTidesHorz or 0)
		| (vars.calcGravVert and ffi.C.calcFlags_calcGravVert or 0)
		| (vars.calcGravHorz and ffi.C.calcFlags_calcGravHorz or 0)
		| (vars.calcCrossPos2D and ffi.C.calcFlags_calcCrossPos2D or 0)
		| (vars.calcCrossPos3D and ffi.C.calcFlags_calcCrossPos3D or 0)
		| (vars.calcCrossVel and ffi.C.calcFlags_calcCrossVel or 0)
		| (vars.calcRadialIntegral and ffi.C.calcFlags_calcRadialIntegral or 0)
		| (vars.calcSurfaceGradMagn and ffi.C.calcFlags_calcSurfaceGradMagn or 0)
	))
	self.calcTideAndGravKernel.obj:setArg(3, int(vars.displayComponent))
	self.calcTideAndGravKernel()

	if vars.calcSurfaceGradMagn then
		self.gradientKernel()

		-- now I could swap forceBuffer and dforceBuffer ... and reassign all the kernels that forceBuffer is assigned to ...
		-- or just copy
		self.forceBuffer:copyFrom(self.dforceBuffer)
	end

	self.forceMin = self.reduceMin(self.forceBuffer.obj)
	self.forceMax = self.reduceMax(self.forceBuffer.obj)

	self.rescaleKernel.obj:setArg(2, double(self.forceMin))
	self.rescaleKernel.obj:setArg(3, double(self.forceMax))
	self.rescaleKernel()

	self.rescaleForceBuffer:toCPU(self.rescaleForceCPUBuf.v)
	self.forceTex
		:bind()
		:subimage()
		:generateMipmap()
		:unbind()
end

local vec4ui = require 'vec-ffi.create_vec3'{dim=4, ctype='uint32_t'}
local clickID = vec4ui()
App.event = |:,e| do
	App.super.event(self, e)
	if not ig.igGetIO()[0].WantCaptureKeyboard then
		if e[0].type == sdl.SDL_EVENT_KEY_DOWN then
			if e[0].key.key == sdl.SDLK_LEFT then
				vars.earthquakeIndex -= 1
				self:updateEarthquakeIndex()
			elseif e[0].key.key == sdl.SDLK_RIGHT then
				vars.earthquakeIndex += 1
				self:updateEarthquakeIndex()
			end
		end
	end
	if not ig.igGetIO()[0].WantCaptureMouse then
		if e[0].type == sdl.SDL_EVENT_MOUSE_MOTION then
			local readBuffer = GLGlobal:get'GL_READ_BUFFER'	-- GL_BACK ... is that always the default?
			self.fbo:bind()
			assert(self.fbo:check())
			gl.glReadBuffer(gl.GL_COLOR_ATTACHMENT1)	-- read clickIDFBOTex

			local mx = e[0].motion.x
			local my = self.height - 1 - e[0].motion.y
			gl.glReadPixels(mx, my, 1, 1, self.clickIDFBOTex.format, self.clickIDFBOTex.type, clickID.s)

			self.fbo:unbind()
			gl.glReadBuffer(readBuffer)

			self.mouseOverEarthquakeIndex = nil
			self.mouseOverFlareIndex = nil
			self.mouseOverGeodesicIndex = nil
			if clickID.y == 1 then	-- earthquakes
				self.mouseOverEarthquakeIndex = clickID.x
			elseif clickID.y == 2 then	-- flares
				self.mouseOverFlareIndex = clickID.x
			elseif clickID.y == 3 then	-- great-arcs
				self.mouseOverGeodesicIndex = clickID.x
			end
		elseif e[0].type == sdl.SDL_EVENT_MOUSE_BUTTON_DOWN then
			if self.mouseOverEarthquakeIndex then
				vars.earthquakeIndex = self.mouseOverEarthquakeIndex
				self:updateEarthquakeIndex()
			end
		end
	end
end

local inputFloat=|l,t,k|
	--ig.luatableInputFloat(l, t, k)
	--ig.luatableInputFloatAsText(l, t, k)
	ig.luatableInputFloatAsText(l, t, k, ig.ImGuiInputTextFlags_EnterReturnsTrue)

App.updateGUI = |:| do
	local eq = earthquakes[vars.earthquakeIndex]
	ig.igSetNextWindowBgAlpha(.3)
	ig.igPushStyleColor_U32(ig.ImGuiCol_MenuBarBg, 0)
	if ig.igBeginMainMenuBar() then
		if ig.igBeginMenu'quakes:' then

			local changed
			local oldEarthquakeIndex = vars.earthquakeIndex
			changed = ig.luatableSliderFloat('earthquakeIndex s', vars, 'earthquakeIndex', 1, #earthquakes)
			changed = ig.luatableInputInt('earthquakeIndex t', vars, 'earthquakeIndex', 1, #earthquakes) or changed
			if changed then
				vars.earthquakeIndex ??= oldEarthquakeIndex	-- if we got bad input then don't crash
				self:updateEarthquakeIndex()
			end

			ig.igText('earthquake time = '..eq.time)
			ig.igText('earthquake julian day = '..eq.julianDay)
			ig.igText('earthquake magn = '..eq.mag)	-- TODO just a side panel or pop up that shows all the earthquake stats
			ig.igText('earthquake depth = '..eq.depth..' km')	-- TODO incorporate this into the display somehow ...
			ig.igText('earthquake place = '..eq.place)
			ig.igText('earthquake latitude = '..eq.latitude)
			ig.igText('earthquake longitude = '..eq.longitude)
			ig.igText('earthquake window start time = '..earthquakes[earthquakeWindowStartIndex].time)
			ig.igText('earthquake window end time = '..earthquakes[earthquakeWindowEndIndex].time)
			ig.igText('earthquake window start index = '..earthquakeWindowStartIndex)
			ig.igText('earthquake window end index = '..earthquakeWindowEndIndex)
			local numQuakesInWindow = earthquakeWindowEndIndex - earthquakeWindowStartIndex + 1
			ig.igText('earthquakes in window = '..numQuakesInWindow)

			local probsForEqSetSize = require 'birthday-problem'[calcCircles.quakeAlignWithPreviousGeodesicAngleThreshold]
			if probsForEqSetSize then
				ig.igText(
					(probsForEqSetSize[numQuakesInWindow] or 1)
					..' = odds of finding a geodesic within '..calcCircles.quakeAlignWithPreviousGeodesicAngleThreshold
					..'° (i.e. '
					..(360/calcCircles.quakeAlignWithPreviousGeodesicAngleThreshold)
					..' partitions) from '..numQuakesInWindow..' possible quakes'
				)
			end

			-- hr --
			ig.igText('flares in window = '..(flareWindowEndIndex == 0 and 0 or (flareWindowEndIndex - flareWindowStartIndex + 1)))
			ig.igText('flare window start time = '..flares[flareWindowStartIndex].time)
			ig.igText('flare window end time = '..flares[flareWindowEndIndex].time)
			ig.igText('flare window start index = '..flareWindowStartIndex)
			ig.igText('flare window end index = '..flareWindowEndIndex)


			ig.igEndMenu()
		end
		if ig.igBeginMenu'options:' then
			ig.luatableCheckbox('ortho', self.view, 'ortho')
			if ig.igButton'reset view' then
				self.view.ortho = true
				self.view.orthoSize = self.viewOrthoSize
				self.view.angle:set(0,0,0,1)
				self.view.orbit:set(0,0,0)
				self.view.pos:set(0,0,self.viewDist)
			end
			ig.luatableCheckbox('draw earth', vars, 'drawEarth')
			ig.luatableCheckbox('draw earthquakes', vars, 'drawEarthquakes')
			inputFloat('earthquakePointSize', vars, 'earthquakePointSize')

			ig.luatableCheckbox('draw great arcs', vars, 'drawGreatArcs')
			ig.luatableSliderFloat('great arc alpha', vars, 'greatArcAlpha', 0, 1)
			ig.luatableSliderFloat('lineWidth', vars, 'lineWidth', 0, 20)
			inputFloat('angleFade', vars, 'angleFade')

			ig.luatableCheckbox('draw flares', vars, 'drawFlares')
			inputFloat('flarePointSize', vars, 'flarePointSize')

			ig.igText'force calcs:'
			ig.igSameLine()
			if ig.luatableTooltipCheckbox('calcTidesVert', vars, 'calcTidesVert') then
				self:refreshForceBuffer()
			end
			ig.igSameLine()
			if ig.luatableTooltipCheckbox('calcTidesHorz', vars, 'calcTidesHorz') then
				self:refreshForceBuffer()
			end
			ig.igSameLine()
			if ig.luatableTooltipCheckbox('calcGravVert', vars, 'calcGravVert') then
				self:refreshForceBuffer()
			end
			ig.igSameLine()
			if ig.luatableTooltipCheckbox('calcGravHorz', vars, 'calcGravHorz') then
				self:refreshForceBuffer()
			end
			ig.igSameLine()
			if ig.luatableTooltipCheckbox('calcCrossPos2D', vars, 'calcCrossPos2D') then
				self:refreshForceBuffer()
			end
			ig.igSameLine()
			if ig.luatableTooltipCheckbox('calcCrossPos3D', vars, 'calcCrossPos3D') then
				self:refreshForceBuffer()
			end
			ig.igSameLine()
			if ig.luatableTooltipCheckbox('calcCrossVel', vars, 'calcCrossVel') then
				self:refreshForceBuffer()
			end
			ig.igSameLine()
			if ig.luatableTooltipCheckbox('calcRadialIntegral', vars, 'calcRadialIntegral') then
				self:refreshForceBuffer()
			end
			ig.igSameLine()
			if ig.luatableTooltipCheckbox('calcSurfaceGradMagn', vars, 'calcSurfaceGradMagn') then
				self:refreshForceBuffer()
			end

			ig.igText('force min='..self.forceMin..' max='..self.forceMax)
			ig.luatableSliderFloat('forceTexAlpha', vars, 'forceTexAlpha', 0, 1)

			ig.igText'Calc Planets: '
			for _,planetClass in ipairs(calcPlanetClasses) do
				ig.igSameLine()
				if ig.luatableTooltipCheckbox('calc '..planetClass.name, vars.calcPlanets, planetClass.name) then
					self:refreshForceBuffer()
				end
			end

			if ig.luatableCombo('displayComponent', vars, 'displayComponent', displayComponentNames) then
				self:refreshForceBuffer()
			end

			ig.luatableCheckbox('drawAnyPlanets', vars, 'drawAnyPlanets')
			for _,planetClass in ipairs(drawPlanetClasses) do
				ig.igSameLine()
				ig.luatableTooltipCheckbox('draw '..planetClass.name, vars.drawPlanets, planetClass.name)
			end
			ig.igText'Show Planet Angles: '
			for _,angle in ipairs(drawPlanetAngles) do
				ig.igSameLine()
				ig.luatableTooltipCheckbox('at angle '..angle, vars.drawPlanetAngles, angle)
			end
			inputFloat('julianBaseAngle', require 'basis', 'julianBaseAngle')

			ig.luatableCheckbox('showDrapTex', vars, 'showDrapTex')
			ig.luatableSliderFloat('drapTexAlpha', vars, 'drapTexAlpha', 0, 1)

			if ig.luatableCheckbox('showOnlySelectedEarthquakeArcs', vars, 'showOnlySelectedEarthquakeArcs') then
				self:refreshVisibleCircles()
			end

			ig.luatableCheckbox('drawAxisCloud', vars, 'drawAxisCloud')
			inputFloat('axisCloudPointSize', vars, 'axisCloudPointSize')
			inputFloat('axisCloudHeightScale', vars, 'axisCloudHeightScale')

			ig.igEndMenu()
		end
		if ig.igBeginMenu'chart:' then

			ig.luatableCheckbox('normalize weights', vars, 'normalizeWeights')
			local changed
			for _,field in ipairs(weightFields) do
				if ig.luatableSliderFloat(field, vars, field, 0, 1) then
					changed = field
				end
			end
			if changed then
				self:recenterOnQuake()
			end
			if vars.normalizeWeights and changed then
				local restFrac = 1 - vars[changed]
				local totalRest = 0
				for _,field in ipairs(weightFields) do
					if field ~= changed then
						totalRest = totalRest + vars[field]
					end
				end
				for _,field in ipairs(weightFields) do
					if field ~= changed then
						if totalRest == 0 then
							vars[field] = 0
						else
							vars[field] = restFrac * vars[field] / totalRest
						end
					end
				end
			end

			if ig.luatableCheckbox('recenterOnQuake', vars, 'recenterOnQuake') then
				self:recenterOnQuake()
			end
			ig.luatableSliderFloat('lat0', vars, 'lat0', -180, 180)
			ig.luatableSliderFloat('lon0', vars, 'lon0', -180, 180)
			ig.luatableSliderFloat('roll0', vars, 'roll0', -180, 180)
			ig.luatableSliderFloat('latlonroll0convergeRate', vars, 'latlonroll0convergeRate', 0, 1)

			ig.igEndMenu()
		end
		if ig.igBeginMenu'circles:' then

			ig.igText('# all geodesics through selected quake = '..#eq.allCircles)

			if inputFloat('greatArcAngleMin', calcCircles, 'greatArcAngleMin') then
				self:invalidateCachedQuakeArcs()
				self:calcQuakeWindowIndexes()
			end
			if inputFloat('greatArcAngleMax', calcCircles, 'greatArcAngleMax') then
				self:invalidateCachedQuakeArcs()
				self:calcQuakeWindowIndexes()
			end
			if inputFloat('quakeAlignWithPreviousGeodesicAngleThreshold', calcCircles, 'quakeAlignWithPreviousGeodesicAngleThreshold') then
				self:invalidateCachedQuakeArcs()
				self:calcQuakeWindowIndexes()
			end
			if inputFloat('filterDuplicateTouchingArcsAngleThreshold', calcCircles, 'filterDuplicateTouchingArcsAngleThreshold') then
				self:invalidateCachedQuakeArcs()
				self:calcQuakeWindowIndexes()
			end
			if inputFloat('filterDuplicatePointsAngleThreshold', calcCircles, 'filterDuplicatePointsAngleThreshold') then
				self:invalidateCachedQuakeArcs()
				self:calcQuakeWindowIndexes()
			end
			if inputFloat('prevTimeWindowInDays', calcCircles, 'prevTimeWindowInDays') then
				self:invalidateCachedQuakeArcs()
				self:calcQuakeWindowIndexes()
			end
			if inputFloat('nextTimeWindowInDays', calcCircles, 'nextTimeWindowInDays') then
				self:invalidateCachedQuakeArcs()
				self:calcQuakeWindowIndexes()
			end

			ig.igEndMenu()
		end

		if ig.igBeginMenu('touching '..#eq.touchingCircles) then
			for i,t in ipairs(eq.touchingCircles) do
				ig.igPushID_Int(i)
				local c = t.circle
				local i1, i2 = table.unpack(c.indexes)
				local eq1 = earthquakes[i1]
				local eq2 = earthquakes[i2]
				ig.igText(i..':')
				ig.igSameLine()
				-- TODO tooltipButton text is always nothing so
				local click = ig.igButton('#'..i1)
				ig.hoverTooltip(eq1.place)
				if click then
					vars.earthquakeIndex = i1
					self:updateEarthquakeIndex()
				end
				ig.igSameLine()
				ig.igText'->'
				ig.igSameLine()
				local click = ig.igButton('#'..i2)
				ig.hoverTooltip(eq2.place)
				if click then
					vars.earthquakeIndex = i2
					self:updateEarthquakeIndex()
				end

				ig.igSameLine()
				ig.igText(t.angleFromArcInDeg..'° from arc.   3 Points are at angles: '
					..table{
						math.deg(t.circle.centerAngle * 2),
						math.deg(math.acos(eq1.xyznorm:dot(eq.xyznorm))),
						math.deg(math.acos(eq2.xyznorm:dot(eq.xyznorm))),
					}:sort():mapi(tostring):concat', '
				)

				ig.igPopID()
			end

			ig.igEndMenu()
		end
		if ig.igBeginMenu'angles:' then	-- angles to planets or other objects

			local earthPos = eq.planets[Planets.indexes.earth].pos
			for _,cl in ipairs(drawPlanetClasses) do	-- planets without earth (nan angle) and EM_Bary (same angle as moon)
				local planetIndex = Planets.indexes[cl.name]
				local planet = eq.planets[planetIndex]
				local planetDir = (planet.pos - earthPos):normalize()
				ig.igText('3D angle: '..math.deg(math.acos(
					eq.xyznorm:dot(planetDir)
				))..'°, 2D angle: '..math.deg(
					((math.atan2(planetDir.y, planetDir.x) - math.atan2(eq.xyznorm.y, eq.xyznorm.x) + math.pi) % (2 * math.pi)) - math.pi
				)..'°, angle to closest touching geodesic: '
					..eq.minAngleForPlanets[planetIndex]
				..'° | '..planet.name)
			end

			if inputFloat('trackEarthquakeIndex', vars, 'trackEarthquakeIndex') then
				self.trackEarthquakeIndexes:insert{
					index = vars.trackEarthquakeIndex,
				}
			end

			ig.igPushID_Str'trackEarthquakeIndexes_list'
			for ii,track in ipairs(self.trackEarthquakeIndexes) do
				local eq2 = earthquakes[track.index]
				if not track.minAngle then
					-- find the min angle from this track object to our current selected earthquake
					track.minAngle = 180
					for _,c in ipairs(circles) do
						local cosAngleFromAxis = c.axis:dot(eq2.xyznorm)	-- cos angle from axis = sine angle from plane
						local angleFromAxis = math.acos(cosAngleFromAxis)
						local angleFromArc = angleFromAxis - .5 * math.pi
						local angleFromArcInDeg = math.abs(math.deg(angleFromArc))	-- will be 0 to 90
						--planetAngleFromGeodesics[pi][math.ceil(angleFromArc)] += 1
						track.minAngle = math.min(track.minAngle, angleFromArcInDeg)
					end
				end

				ig.igPushID_Int(ii)

				local dobreak
				if ig.igButton'x' then
					self.trackEarthquakeIndexes:remove(ii)
					dobreak = true	-- can't break until popid or imgui will crap itself
				end

				ig.igSameLine()

				ig.igText('3D angle: '..math.deg(math.acos(
					eq.xyznorm:dot(eq2.xyznorm)
				))..'°, 2D angle: '..math.deg(
					((math.atan2(eq2.xyznorm.y, eq2.xyznorm.x) - math.atan2(eq.xyznorm.y, eq.xyznorm.x) + math.pi) % (2 * math.pi)) - math.pi
				)..'°, angle to closest touching geodesic: '
					..track.minAngle..'° | '..eq2.place)

				ig.igPopID()
				if dobreak then break end
			end
			ig.igPopID()

			ig.igEndMenu()
		end
		if ig.igBeginMenu('| #'..vars.earthquakeIndex
			..', mag='..eq.mag
			..', depth='..eq.depth..' km'
			..', place='..eq.place
			..', time='..eq.time 
			..', julianDay='..eq.julianDay
		) then
			ig.igEndMenu()
		end
		ig.igEndMainMenuBar()
	end
	ig.igPopStyleColor(1)

	if self.mouseOverEarthquakeIndex then
		local overEq = earthquakes[self.mouseOverEarthquakeIndex]
		if overEq then
			ig.igBeginTooltip()
			ig.igText('earthquake id #'..self.mouseOverEarthquakeIndex)
			ig.igText('time = '..overEq.time)
			ig.igText('julian day = '..overEq.julianDay)
			ig.igText('magn = '..overEq.mag)	-- TODO just a side panel or pop up that shows all the earthquake stats
			ig.igText('depth = '..overEq.depth..' km')	-- TODO incorporate this into the display somehow ...
			ig.igText('place = '..overEq.place)
			ig.igText('latitude = '..overEq.latitude)
			ig.igText('longitude = '..overEq.longitude)
			ig.igEndTooltip()
		end
	elseif self.mouseOverFlareIndex then
		local overFlare = flares[self.mouseOverFlareIndex]
		if overFlare then
			ig.igBeginTooltip()
			ig.igText('flare id #'..self.mouseOverFlareIndex)
			ig.igEndTooltip()
		end
	elseif self.mouseOverGeodesicIndex then
		local circle = circles[self.mouseOverGeodesicIndex]
		if circle then
			ig.igBeginTooltip()
			local i1, i2 = table.unpack(circle.indexes)
			local eq1 = earthquakes[i1]
			local eq2 = earthquakes[i2]
			--ig.igText(i..':')	-- TODO lookup ID, or change 'circles' to be a list of IDs so we can get it that way
			--ig.igSameLine()
			-- TODO tooltipButton text is always nothing so
			ig.igText('#'..i1..' '..eq1.place)
			ig.igText('-> #'..i2..' '..eq2.place)
			ig.igEndTooltip()
		end
	end
end

return App():run()
