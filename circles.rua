local vec3d = require 'vec-ffi.vec3d'

local M = {}

local dayInSec = 60 * 60 * 24


-- when searching for great-arc circles, ignore point-pairs that are not within this angle distance apart
--M.greatArcAngleMin, M.greatArcAngleMax = 10, 90
--M.greatArcAngleMin, M.greatArcAngleMax = 0, 180
M.greatArcAngleMin, M.greatArcAngleMax = 10, 170

M.quakeMinAngleDistFromQuakesThatFormedTheGeodesic = 5	-- degrees separation minimum, so we don't have quakes that point at circles that basically formed from the same quake location at a dif time

-- tolerance of how close a quake must be to a previous circle to consider along the geodesic
--M.quakeAlignWithPreviousGeodesicAngleThreshold = 1	-- in radians
--M.quakeAlignWithPreviousGeodesicAngleThreshold = 2	-- in radians
M.quakeAlignWithPreviousGeodesicAngleThreshold = 5	-- in radians
--M.quakeAlignWithPreviousGeodesicAngleThreshold = 15	-- in radians

-- if we get two great-arcs touching our current quake (within `quakeAlignWithPreviousGeodesicAngleThreshold`)
--  then throw out the new one if their axii (+-) is within this angle apart.
-- ... but I think we do want duplicate-arcs to show where multiple-quakes-on-same-arc do align.
-- ... we just don't want duplicate-points, being used to generate those arcs... right?
M.filterDuplicateTouchingArcsAngleThreshold = 0
--M.filterDuplicateTouchingArcsAngleThreshold = 1
--M.filterDuplicateTouchingArcsAngleThreshold = 5
--M.filterDuplicateTouchingArcsAngleThreshold = 10

-- when searching for great-arc circles, ignore points within this many radians of previously-considered points
M.filterDuplicatePointsAngleThreshold = 0
--M.filterDuplicatePointsAngleThreshold = 1
--M.filterDuplicatePointsAngleThreshold = 5
--M.filterDuplicatePointsAngleThreshold = 10

-- how far back we want to look when comparing great-arcs
--M.timeWindowInDays = 1
M.timeWindowInDays = 3

local basisFor = require 'basis'.basisFor 

local cosMinAngleDistFromQuakesThatFormedTheGeodesic = math.cos(math.rad(M.quakeMinAngleDistFromQuakesThatFormedTheGeodesic))

M.calcCircles=|earthquakes|do
	local circlesInTimeWindow = table()	-- holds indexes into 'allCircles'
	local allCircles = table()
	local oldestEarthquakeIndex = 1
	for i,eq in ipairs(earthquakes) do
		local v = eq.xyznorm

		-- see how close it is to all other circles on file
		local touchingCircles = table()
		for ici,ci in ipairs(circlesInTimeWindow) do
			local c = allCircles[ci]
			
			-- make sure that the points that formed this great-arc are far from this point
			local tooCloseToArcGen 
			for k,ei in ipairs(c.indexes) do
				local cosAngle = earthquakes[ei].xyznorm:dot(v)
				if cosAngle > cosMinAngleDistFromQuakesThatFormedTheGeodesic then
					tooCloseToArcGen = true
					break
				end
			end
			if not tooCloseToArcGen then
				-- if we were right on the plane then we would be right at 90' with the axis.
				-- see how far the angle we make with the axis is from 90'
				local angle = math.acos(c.axis:dot(v))
				if math.abs(angle - .5 * math.pi) < math.rad(M.quakeAlignWithPreviousGeodesicAngleThreshold) then

					-- if a previous great-arc was already associated with this point and it is close enough to the current great-arc then skip the current one (uniques only)
					local dups
					if (M.filterDuplicateTouchingArcsAngleThreshold or 0) > 0 then
						local costh = math.cos(math.rad(M.filterDuplicateTouchingArcsAngleThreshold))
						for ici2=1,ici-1 do
							local c2 = allCircles[circlesInTimeWindow[ici2]]
							if math.abs(c.axis:dot(c2.axis)) > costh then
								dups = true
								break
							end
						end
					end
					if not dups then
						-- TODO take note (or even filter?) based on the angle distance between us and the prevoius points that it took to form this geodesic?
						-- what if all new quakes happen to be along geodesics but >90' of old geodesic points? (or whatever our geodesic creation angle criteria is)
						touchingCircles:insert{circle=ci, angle=angle}
					end
				end
			end
		end
		local numCirclesChecked = #circlesInTimeWindow

		-- now do our typical building of great-arcs based on our other angle criteria
		-- TODO do the building of great-arcs FIRST and then scan PLUS OR MINUS in our time window.
		local oldCircleCount = #circlesInTimeWindow
		for j=oldestEarthquakeIndex,i do
			-- TODO filter out repetitive points

			local eq2 = earthquakes[j]
			local v2 = eq2.xyznorm	-- spherical

			local dups
			-- filter out duplicate points for great-arc construction consideration ...
			if (M.filterDuplicatePointsAngleThreshold or 0) > 0 then
				local cosAngle = math.cos(math.rad(M.filterDuplicatePointsAngleThreshold))
				for k=oldestEarthquakeIndex,j-1 do
					local v3 = earthquakes[k].xyznorm	 -- spherical
					-- secant length to angle ...
					if v3:dot(v2) >= cosAngle then
						dups = true
						break
					end
				end
			end
			if not dups then
				local torque = v:cross(v2)	-- TODO times pair of earthquake magnitudes or something?
				local axisLen = torque:length()
				local axis = torque * (1 / (math.max(axisLen, 1e-15)))
				local influence = axisLen * 10^eq.mag * 10^eq2.mag
				local angle = math.acos(v:dot(v2))
				if math.rad(M.greatArcAngleMin) < angle and angle < math.rad(M.greatArcAngleMax) then	-- if I weight by cross then that'll make the 0' and 180' angles diminish ... nah, there's still a lot of noise unless I turn down the alpha ... then it's hard to highlight any geodesics ...
					local a1 = axis
					local a2 = basisFor(a1):normalize()
					local a3 = a1:cross(a2)
					local circle = {
						axis = axis,
						axis2 = a2,
						axis3 = a3,
						angle = math.pi * .5,
						indexes = {i, j},
						-- [[ used for rendering
						influence = influence,
						color = vec3d(1, .3, .07),
						centerPos = (v + v2):normalize(),	-- midpoint between two earthquake lines
						centerAngle = .5 * angle,			-- half the angle between them
						--]]
					}

					allCircles:insert(circle)
					circlesInTimeWindow:insert(#allCircles)
				end
			end
		end
		-- now recalculate the oldest point index t consider (basd on our time window)
		while oldestEarthquakeIndex < i
		and eq.ostime - earthquakes[oldestEarthquakeIndex].ostime > M.timeWindowInDays * dayInSec
		do
			oldestEarthquakeIndex+=1
		end
		-- and throw out old circles
		for j=oldCircleCount,1,-1 do
			local ci = circlesInTimeWindow[j]
			local c = allCircles[ci]
			if c.indexes[1] < oldestEarthquakeIndex
			or c.indexes[2] < oldestEarthquakeIndex
			then
				circlesInTimeWindow:remove(j)
			end
		end

		-- collect unique points to all circles of this point
		local uniquePointIndexes = {}
		uniquePointIndexes[i] = true
		for _,t in ipairs(touchingCircles) do
			local ci = t.circle
			local c = allCircles[ci]
			uniquePointIndexes[c.indexes[1]] = true
			uniquePointIndexes[c.indexes[2]] = true
		end
		eq.touchingCircles = touchingCircles
		eq.uniquePoints = uniquePoints	-- do I need a list of all points that are on all circles that are touching this point? or nah?
	end
	
	return allCircles
end

return M
