--[[
what to track ...
- over a time range, sequentially go through all earthquakes
- as you add them, look through all previous points and consider the great-arc with this point (subject to angle constraints)
- report how well this new great-arc compares to older ones (i.e. is this new earthquake on a great-arc that already exists?)
	- by comparing dot of its axis with previous circles' axis
- as we get too old, throw out old points and their respective great-arcs
--]]


local Julian = require 'solarsystem.julian'
local time = require 'time'.time
local timegm = require 'time'.timegm
local gmtime = require 'time'.gmtime
local dayInSec = require 'time'.dayInSec
--[[
print('time()', time())	-- this is time since 1970 ... your timezone ... right?
print('gmtime', tolua(gmtime()))
print('timegm(gmtime)', tolua(timegm(gmtime())))
os.exit()
--]]

-- [=======[ download data
path'cache':mkdir()
local getDayCache = |t, force| do
	local tt = gmtime(t)
	local datestr = ('%04d-%02d-%02d'):format(tt.year, tt.month, tt.day)
	local csvpath = path('cache/'..datestr..'.csv')
	local csvstr
	local changed
	if force or not csvpath:exists() then
		print('downloading '..datestr..'...')
		local https = require 'ssl.https'
		csvstr = assert(https.request('https://earthquake.usgs.gov/fdsnws/event/1/query.csv?starttime='..datestr..'%2000:00:00&endtime='..datestr..'%2023:59:59&minmagnitude=2.5&orderby=time'))

		if force then
			if csvpath:exists() then
				changed = assert(csvpath:read()) ~= csvstr
			end
		else
			-- if no force and it's a new file, then flag it for 'changed'
			changed = true
		end

		assert(csvpath:write(csvstr))
	else
		-- cached?  don't set the 'changed' flag
		print('reading cache '..csvpath)
		csvstr = assert(csvpath:read())
	end
	local csvdata = assert(require 'csv'.string(csvstr))
	csvdata:setColumnNames(csvdata.rows:remove(1))

	-- map from csv index to k/v object
	return csvdata.rows:mapi(|eq| do
		local neq = {}
		for _,k in ipairs(csvdata.columns) do
			neq[k] = tonumber(eq[k]) or eq[k]
		end
		return neq
	end), changed
end


local earthquakes = table()
local checkTime = time()
local prevDays = 31
--local prevDays = 365
do	-- I wish for-loops worked with cdata primitives ...
	local t = checkTime - prevDays * dayInSec
	while t <= checkTime - dayInSec do
		local deq = getDayCache(t)
		earthquakes:append(deq)
		t += dayInSec
	end
end
do	-- always re-download today
	local deq = getDayCache(checkTime, true)
	earthquakes:append(deq)
end
print('total', #earthquakes)
--]=======]

local latLonToXYZ = require 'charts'.latLonToXYZ

timer('calc xyz', ||do
	for _,eq in ipairs(earthquakes) do
		-- add preprocessed fields
		local Y,m,d,H,M,S = eq.time:match'^(%d%d%d%d)%-(%d%d)%-(%d%d)T(%d%d):(%d%d):(%d%d%.%d%d%d)Z$'
		assert(Y)	-- ... and the others should be there too
		local mustbenumber = |x| do
			return tonumber(x) or error("failed to parse "..tostring(x))
		end
		eq.date = {
			year = mustbenumber(Y),
			month = mustbenumber(m),
			day = mustbenumber(d),
			hour = mustbenumber(H),
			min = mustbenumber(M),
			sec = mustbenumber(S),
		}
		eq.ostime = timegm(eq.date)
assert.eq(ffi.typeof(eq.ostime), ffi.typeof'int64_t')
		eq.julianDay = Julian.fromCalendar(eq.date)
		eq.xyz = latLonToXYZ(eq)
		eq.xyznorm = eq.xyz:normalize()
		eq.circles = {}	-- keys are a set of indexes of circles in allCircles that use this point for construction (i.e. it is exactly on)
	end
	earthquakes:sort(|a,b| a.ostime < b.ostime)	-- oldest first
end)

return {
	-- for getting earthquakes
	getDayCache = getDayCache,
	checkTime = checkTime,
	-- the initial earthquake set
	earthquakes = assert(earthquakes),
}
